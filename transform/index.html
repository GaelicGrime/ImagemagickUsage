<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Transformations -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/transform/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Image Transformations</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#art"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Art-like Transformations</A>
    <UL>
    <LI><A HREF="#raise"         >Turn images into raised or sunken buttons</A>
    <LI><A HREF="#inside_border" >Adding an Inside Border</A>
    <LI><A HREF="#spread"        >Random Pixel Spread</A>
    <LI><A HREF="#vignette"      >Vignette photo transform</A>
    <LI><A HREF="#polaroid"      >Complex Polaroid Transform</A>
    <LI><A HREF="#paint"         >Oil Painting, blobs of color</A>
    <LI><A HREF="#charcoal"      >Charcoal, artists sketch of a scene</A>
    <LI><A HREF="#sketch"        >Pencil Sketch Transform</A>
    <LI><A HREF="#emboss"        >Emboss, creating a metallic impression</A>
    <LI><A HREF="#stegano"       >Stegano, hiding a secrets within an image</A>
    <LI><A HREF="#encipher"      >Encrypting Image Data</A>
    <LI><A HREF="#pixelate"      >Pixelate Images</A>
    <LI><A HREF="#gridding"      >Grids of Pixels</A>
    <LI><A HREF="#spacing_tiles" >Spacing out Tiles</A>
    </UL>
<DD><A HREF="#vision"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Computer Vision Transformations</A>
    <UL>
    <LI><A HREF="#edge"        >Edge Detection</A>
    <LI><A HREF="#canny"       >Canny Edge Detector</A>
    <LI><A HREF="#edge_jitter" >Edge Outlines from Anti-Aliased Shapes</A>
    <LI><A HREF="#edge_bitmap" >Edge Outlines from Bitmap Shapes</A>
    <LI><A HREF="#edge_vector" >Edging Using a Raster to Vector Converter</A>
    <LI><A HREF="#hough"       >Hough Line Detector</A>
    <LI><A HREF="#lat"         >Local Adaptive Thresholding (lat)</A>
    </UL>
<DD><A HREF="#shade"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Shade 3D Highlighting</A>
    <UL>
    <LI><A HREF="#shade"           >Using Shade</A>
    <LI><A HREF="#shade_mask"      >Masked Shaded Shapes</A>
    <LI><A HREF="#shade_shape"     >Shaded Shape Images</A>
    <LI><A HREF="#shade_blur"      >Rounding Shade Edges</A>
    <LI><A HREF="#shade_overlay"   >Creating Overlay Highlights</A>
    <LI><A HREF="#shade_highlight" >Using a Dawn Shade Highlight</A>
    </UL>
<DD><A HREF="#fx"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Using FX, the DIY Image Operator</A>
    <UL>
    <LI><A HREF="#fx"          >FX Basic Usage</A>
    <LI><A HREF="#fx_escapes"  >FX Expressions as Percent Escapes</A>
    <LI><A HREF="#fx_builtins" >FX-like Built-in Methods</A>
    <LI><A HREF="#fx_other"    >Accessing data from other images</A>
    </UL>
<DD><A HREF="#evaluate"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Evaluate and Function, Fast FX Operators</A>
    <UL>
    <LI><A HREF="#evaluate" >Evaluate, Simple Math Operations</A>
        <DL><DD>
            <A HREF="#evaluate_set"      >Set</A>,&nbsp;
            <A HREF="#evaluate_add"      >Add</A>,&nbsp;
            <A HREF="#evaluate_subtract" >Subtract</A>,&nbsp;
            <A HREF="#evaluate_multiply" >Multiply</A>,&nbsp;
            <A HREF="#evaluate_divide"   >Divide</A>
        </DL>
    <LI><A HREF="#evaluate_math" >Evaluate Math Functions</A>
        <DL><DD>
            <A HREF="#evaluate_pow"      >Pow</A>,&nbsp;
            <A HREF="#evaluate_log"      >Log</A>,&nbsp;
            <A HREF="#evaluate_sin"      >Sin</A>,&nbsp;
            <A HREF="#evaluate_cos"      >Cos</A>
        </DL>
    <LI><A HREF="#function" >Function, Multi-Argument Evaluate</A>
        <DL><DD> <A HREF="#function_polynomial" >Polynomial</A>,&nbsp; <A
            HREF="#function_sinusoid"   >Sinusoid</A>,&nbsp; <A
            HREF="#function_arcsin"     >ArcSin</A>,&nbsp; <A
            HREF="#function_arctan"     >ArcTan</A>
        </DL>
    </UL>
<DD><A HREF="#gradient_math"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Mathematics on Gradients</A>
    <UL>
    <LI><A HREF="#math_attenuate" >Attenuate a Biased Gradients</A>
    <LI><A HREF="#math_multiply"  >Multiply Biased Gradients</A>
    <LI><A HREF="#math_addition"  >Adding Biased Gradients</A>
    <LI><A HREF="#math_freq_mod"  >Frequency Modulation</A>
    </UL>
</DL></P>

These operations produce major changes to the overall appearance of the image
either for visual, or art-like effects. However while the overall look of the
image has changed, often dramatically, the original image itself is still
generally visible in the result. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="art"></A>
<H2>Art-Like Transformations</H2>

<A NAME="raise"></A>
<H3>Raise or Sunk Borders</H3>

The "<CODE><A HREF="../option_link.cgi?raise" >-raise</A></CODE>" operator is
such a simple image transformation, that it almost isn't.  All it does is
as a rectangular bevel highlight to an existing image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -raise 5  rose_raise.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_raise.gif"
    ><IMG SRC="rose_raise.gif"
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

An inverted sunken effect can be generated using the 'plus' form of the
operator...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  +raise 5  rose_sunken.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_sunken.gif"
    ><IMG SRC="rose_sunken.gif"
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This operator is a bit like <A HREF="../crop/#frame" >Framing</A> an image,
but instead of adding extra pixels as a border, the "<CODE><A
HREF="../option_link.cgi?raise" >-raise</A></CODE>" operator re-colors the
edge pixels of the image. This makes it an image transform. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  In actual fact <A HREF="../crop/#frame" >Image Framing</A> is achieved
  by adding a Border, then raising it!
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The operator only works on rectangular images, and will fail for images with
  a transparent background, as the color modifications will also be transparent.
  Basically is it a rather dumb operator!
</I></FONT></TD></TR></TABLE></P>


<A NAME="inside_border"></A>
<H3>Adding an Inside Border</H3>

Rather than adding a border around the outside of an image an user wanted to
add one to overlay the edges of an image.  The solution was to draw a
rectangle around the image.  As the built in rose in is 70x46 pixels, this is
the result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -fill none -stroke navy -strokewidth 11  \
          -draw 'rectangle 0,0 69,45'   inside_border.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="inside_border.jpg"
     ><IMG SRC="inside_border.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The width of the border added is controlled by the "<CODE><A
HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>" of the
rectangle.  That is

<DIV ALIGN=center><PRE>{stroke width}  =  {border width} * 2 - 1</PRE></DIV></P>

As such the above 6 pixel border needed a "<CODE><A
HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>" of 11. </P>


If you don't know the size of the image, then you can <A HREF="../crop/#shave"
>Shave</A> the image then add the <A HREF="../crop/#border" >Border</A> as
normal.  This is probably easier, though prehaps not as versatile.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -bordercolor green -shave 6x6 -border 6x6 inside_border2.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="inside_border2.jpg"
     ><IMG SRC="inside_border2.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="spread"></A>
<H3>Random Pixel Spread</H3>

The "<CODE><A HREF="../option_link.cgi?spread" >-spread</A></CODE>"  would
replace each pixel the color of a random nearby color from the source image.
This random selection was made as per the use of <A
HREF="../misc/#interpolate" >Pixel Interpolation</A> and <A
HREF="../misc/#virtual-pixel" >Virtual-Pixel Setting</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE REPLACE>
  convert -size 80x40 xc:red xc:blue -append -spread 5 spread_interpolated.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="spread_interpolated.png"
     ><IMG SRC="spread_interpolated.png"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you were to examine the pixels image you will see that some pixels may have
a mix of red and blue colors. That is they are interpolated, not simply spread
or swapped. This is more pronounce smaller distance values. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Also note that "<CODE><A HREF="../option_link.cgi?spread" >-spread</A></CODE>"
also makes use of the <A HREF="../misc/#virtual-pixel" >Virtual-Pixel
Setting</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE REPLACE>
  convert -size 80x80 xc: -virtual-pixel black -spread 10 spread_virtual.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="spread_virtual.png"
     ><IMG SRC="spread_virtual.png"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see you get a randomized border, mostly of pure black virtual
pixels Though there are a few grey pixels interpolated from the border between
the real pixels of the image and virtual pixels. </P>

To get a more traditional spread pixels effect, you can prevent this color
mixing by forcing the color lookup of specific pixels by using "<CODE><A
HREF="../option_link.cgi?interpolate" >-interpolate</A> <A
HREF="../misc/#nearest" >Nearest</A></CODE>".  To avoid the problems with
virtual pixels and posible 'edge color bias', I recommend you use "<CODE><A
HREF="../option_link.cgi?virtual-pixel" >-virtual-pixel</A> <A
HREF="../misc/#mirror" >Mirror</A></CODE>". </P>

As such this is a more traditonal random 'spread' of pixels...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE REPLACE>
  convert rose: -interpolate nearest -virtual-pixel mirror \
                -spread 5   spread_rose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="spread_rose.png"
     ><IMG SRC="spread_rose.png"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<BR>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

The main problem with the above is that you can lose some pixel data from the
image.  That is the pixels are not 'swapped' but randomally copied, which
means a specific pixel in the image may become duplicated or lost. </P>

As of IM v6.9.2-2 you can use "<CODE><A HREF="../option_link.cgi?spread"
>+spread</A></CODE>" to actually swap pixels within the image, meaning that no
pixel in the image will be duplicated or lost.  Every pixel in the original
image is still present, just displaced to to new location.</P>

However due to the way pixels are processed, pixels may be 'double-swapped'.
That is a specific pixel may be swapped, but then selected to be swapped again
with a later pixel. That means a specific pixel could drift further than was
requested by the spread argument. </P>

This double swapping also mean that pixels were likely to spread further
toward the lower right corner. That movement is of course balanced but
a smaller drift of a large number of pixels toward the upper-left.</P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
For example, here I spread pixels with the original prepended as a referance.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE REPLACE>
  convert -size 40x40 xc:red xc:blue -append \
          \( +clone +spread 5 \) +append spread_bias.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="spread_bias.png"
     ><IMG SRC="spread_bias.png"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how some red pixels are spread downward more, though you also get a few
blue pixels spreading upward more than expected too ( though toward the left
side of the image).  This problem is more pronounce when you use a smaller
distance argument to spread. </P>

A solution to this double-swap problem is not easy, and we are looking for
a 'limited area shuffle' algorithm to solve it.  But in the mean time you can
at least mitigate the directional bias by doing the spread twice, with a the
<A HREF="../warping/#transverse" >Transverse</A> (top-left to bottom right
diagonal mirror) distortion.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE REPLACE>
  convert -size 40x40 xc:red xc:blue -append \
          \( +clone +spread 5 -transverse -spread 5 -transverse \) \
          +append spread_no_bias.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="spread_no_bias.png"
     ><IMG SRC="spread_no_bias.png"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course this does makes the spread more pronounced, and less linear, but at
least it is without a directional bias, or pixel duplication/loss. </P>

The above addition was developed from a Forum Discussion: t=28043 </P> IM
Forum Discussion <A HREF="../forum_link.cgi?f=2&t=28043" >rearrange vertical
pixel row</A> . </P>



<A NAME="vignette"></A>
<H3>Vignette Photo Transform</H3>

A special operator to make an image circular with a soft blurry outline.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -background black -vignette 0x5  rose_vignette.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_vignette.gif"
     ><IMG SRC="rose_vignette.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By using a zero (or very small) sigma you can remove the blur, and generate
ellipse or oval frames.  However note that it does not actually use the
largest ellipse posible, so you may want to DIY it.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -background black -vignette 0x0  rose_vignette_0.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_vignette_0.gif"
     ><IMG SRC="rose_vignette_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can use it with transparency (and PNG format)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -alpha Set -background none -vignette 0x3  rose_vignette.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_vignette.png"
     ><IMG SRC="rose_vignette.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

An alternative argument method is to use a very large number for the second
<I>sigma</I> component, and then use the first <I>radius</I> to define the
spread of the blur.  This produces a 'linear' distribution rather than a
more common Gaussian distribution to the vignette blurring.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -background black -vignette 5x65000  rose_vignette_linear.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_vignette.gif"
     ><IMG SRC="rose_vignette.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Another technique for a more rectangular vignette, producing soft edges to the
image is demonstrated in <A HREF="../thumbnails/#soft_edges" >Thumbnails with
Soft Edges</A>. </P>


<A NAME="polaroid"></A>
<H3>Complex Polaroid Transformation</H3>

Thanks to the work done by Timothy Hunter, (of RMagick fame), a "<CODE><A
HREF="../option_link.cgi?polaroid" >-polaroid</A></CODE>" transformation
operator, was added to IM v6.3.2.

<DIV ALIGN=right><FONT SIZE=-2>
Polaroid&reg; is a registered trademark of the Polaroid Corporation.
</FONT></DIV></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, here I give a polaroid look to a photo thumbnail. The image is
looking up the <A HREF="../img_photos/spiral_stairs_sm.jpg" >spiral staircase (downward),
inside the Arc de Triumph, Paris</A>.  It is a very long staircase!.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert spiral_stairs_sm.jpg -thumbnail 120x120 \
          -bordercolor white -background black  +polaroid  poloroid.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid.png"
     ><IMG SRC="poloroid.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note the resulting image has a semi-transparent shadow, so you either have
  to use a PNG format image, or "<CODE><A HREF="../option_link.cgi?flatten"
  >-flatten</A></CODE>" the result onto a fixed background color for GIF or
  JPG formats.
</I></FONT></TD></TR></TABLE></P>

This operator is very complex, as it adds border (as per the "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" setting),
'curls' the paper, and adds an inverse curl to the shadow.  The shadow color
can be controlled by the "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color setting. </P>

As you saw above the plus form of the operator will rotate the result by a
random amount.  This operator makes a <A HREF="../img_photos/INDEX.html"
>Index of Photos</A> much more interesting and less static than you would
otherwise get.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

The minus form of the operator lets you control the angle of rotation of the
image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert spiral_stairs_sm.jpg -thumbnail 120x120 \
          -bordercolor AliceBlue -background SteelBlue4 -polaroid 5 \
          poloroid_5.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid_5.png"
     ><IMG SRC="poloroid_5.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

If the image has "<CODE><A HREF="../option_link.cgi?caption"
>-caption</A></CODE>" meta-data, that text will also be added into the lower
border of the polaroid frame, via the "<CODE><A HREF="../text/#caption"
>caption:</A></CODE>" image creation operator.  That is it will be word
wrapped to the width of the photo.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -caption '%c %f\n%wx%h' spiral_stairs_sm.jpg -thumbnail 120x120 \
          -bordercolor Lavender  -background gray40  +polaroid \
          poloroid_captioned.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="poloroid_captioned.png"
      ><IMG SRC="poloroid_captioned.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

The other standard text settings (as per "<CODE><A HREF="../text/#caption"
>caption:</A></CODE>"), allows you to control the look of the added caption.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert spiral_stairs_sm.jpg -thumbnail 120x120 -font Candice -pointsize 18 \
          -bordercolor Snow -background black -fill dodgerblue -stroke navy \
          -gravity center  -set caption "Spiral Stairs\!"  -polaroid 10 \
          poloroid_controls.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid_controls.png"
     ><IMG SRC="poloroid_controls.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The image meta-data attribute "<CODE><A HREF="../option_link.cgi?caption"
  >-caption</A></CODE>" was used due to the internal use of "<CODE><A
  HREF="../text/#caption" >caption:</A></CODE>" text to image generator.
  </P>

  On the other hand  the IM command "<CODE><A HREF="../montage/#montage"
  >montage</A></CODE>" uses "<CODE><A HREF="../option_link.cgi?label"
  >-label</A></CODE>" as it uses the non-word wrapping "<CODE><A
  HREF="../text/#label" >label:</A></CODE>" text to image generator.

</I></FONT></TD></TR></TABLE></P>

The transforms use of <A HREF="../warping/#rotate" >Rotate</A> and <A
HREF="../warping/#wave" >Wave</A> shearing distortions to add a little 'curl'
to the photo image has a tendency to produce horizontal lines of fuzziness in
text of the image generated.  This is a well known <A
HREF="../distorts/summery" >Image Distortion</A> problem (see <A
HREF="../warping/#rotate_line" >Rotating a Thin Line</A>), and one that can be
solved by using a <A HREF="../distorts/#super_sampling" >super sampling</A>
technique. </P>

Basically we generate the polaroid twice as large as what we really want, then
we just resize the image to its final normal size.  The reduction in the image
size effectively sharpens the resulting image, and more importantly the
caption text. </P>

However to make this work we not only need an image at least twice the final
size, but also we may need to a larger border to the image, and draw the text
at twice its normal "<CODE><A HREF="../option_link.cgi?density"
>-density</A></CODE>".  Do not increase the fonts "<CODE><A
HREF="../option_link.cgi?pointsize" >-pointsize</A></CODE>" as that does not
enlarge the text in quite the same way.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -caption 'Spiral Staircase, Arc de Triumph, Paris, April 2006' \
          spiral_stairs_sm.jpg  -thumbnail 240x240 \
          -bordercolor Lavender -border 5x5   -density 144  \
          -gravity center  -pointsize 8   -background black \
          -polaroid -15     -resize 50%     poloroid_modified.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid_modified.png"
     ><IMG SRC="poloroid_modified.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see, even though we used a much smaller font pointsize, the caption
text is very sharp, clear and readable. The same for any other fine detail
that may have been present in the original image.  The only disadvantage of
this is that the shadow of the resulting image will be smaller, and less
fuzzy. </P>

For total control of the polaroid transformation, you can do all the steps
involved yourself.  The original technique documented on Tim Hunter's page, <A
HREF="http://rmagick.rubyforge.org/Polaroid/polaroid.html" >RMagick Polaroid
Effect</A>.  The steps are: create and append caption, add borders, curl photo
with wave, add a reversed curled shadow, and finally rotate image. </P>

For more examples, and other DIY methods, see <A
HREF="../thumbnails/#polaroid" >Polaroid Thumbnail Examples</A>, and <A
HREF="../montage/#polaroid" >A Montage of Polaroid Photos</A>.  You may also
be interested in some of the polaroid examples in <A
HREF="http://rubblewebs.co.uk/imagemagick/other.php" >RubbleWeb IM Examples,
Other</A>.  </P>


<A NAME="paint"></A>
<H3>Oil Painting, blobs of color</H3>

The "<CODE><A HREF="../option_link.cgi?paint" >-paint</A></CODE>" operator is
designed to convert pictures into paintings made by applying thick 'blobs' of
paint to a canvas. The result is a merging of neighbourhood colors into larger
single color areas. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -paint 1   rose_paint_1.gif
  convert rose:  -paint 3   rose_paint_3.gif
  convert rose:  -paint 5   rose_paint_5.gif
  convert rose:  -paint 10  rose_paint_10.gif
  convert rose:  -blur 0x3 -paint 10  rose_blur_paint_10.gif
</CODE></PRE></TD></TR></TABLE>
   <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="rose_paint_1.gif"
     ><IMG SRC="rose_paint_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_paint_3.gif"
     ><IMG SRC="rose_paint_3.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_paint_5.gif"
     ><IMG SRC="rose_paint_5.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_paint_10.gif"
     ><IMG SRC="rose_paint_10.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="rose_blur_paint_10.gif"
     ><IMG SRC="rose_blur_paint_10.gif"
           ALIGN=middle VSPACE=05 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Notice that at a high radius for the paint blobs, the blobs start to get a
squarish look to them. This effect can be smoothed somewhat by blurring the
image slightly before hand, as shown in the last image above. </P>

It is an interesting effect and could be used to make some weird and wonderful
background images. For example see its use in <A
HREF="../backgrounds/#paint_raw10" >Background Examples</A>. </P>

On final warning.  While "<CODE><A HREF="../option_link.cgi?paint"
>-paint</A></CODE>" is supposed to produce areas of a single solid color, at
large radius values, it has a tendency to produce a vertical gradient in some
areas.  This is most annoying, and may be a bug.  Does anyone know? </P>

There are alternative to using "<CODE><A HREF="../option_link.cgi?paint"
>-paint</A></CODE>".  One is to use "<CODE>-statistic Mode</CODE>" instead,
which assigns each pixel with the 'predominate color' within the given
rectangular neighbourhood, and can produce a nicer result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -statistic Mode 10 rose_paint_mode.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_paint_mode.gif"
     ><IMG SRC="rose_paint_mode.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Another is to use some of the <A HREF="../morphology/" >Morphology
Methods</A>, and more specifically the <A HREF="../morphology/#intensity"
>Intensity Variant for Color Images</A>.

Here for example is an 'OpenIntensity' Morphology on the rose.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -morphology OpenI Disk rose_paint_open.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_paint_open.gif"
     ><IMG SRC="rose_paint_open.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here I use 'CloseIntensity' with a slightly smaller 'Disk'.
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -morphology CloseI Disk:2.5 rose_paint_close.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_paint_close.gif"
     ><IMG SRC="rose_paint_close.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You don't have to use 'disks', but can design your own 'brush' shaped kernel
for the blobs that it creates.  For example what about using a diagonal line
brush. </P>


<A NAME="charcoal"></A>
<H3>Charcoal, artists sketch of a scene</H3>

The charcoal effect is meant to simulate artist's charcoal sketch of the given
image. </P>

The "<CODE><A HREF="../option_link.cgi?charcoal" >-charcoal</A></CODE>" operator
is in some respects similar to edge detection transforms used by <A
HREF="#vision">Computer Vision</A>.  Basically it tries to convert the major
borders and edges of object in the image into pencil and charcoal shades. </P>

The one argument is supposed to represent the thickness of the edge lines.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -charcoal 1   rose_charcoal_1.gif
  convert rose:  -charcoal 3   rose_charcoal_3.gif
  convert rose:  -charcoal 5   rose_charcoal_5.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_charcoal_1.gif"
     ><IMG SRC="rose_charcoal_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_charcoal_3.gif"
     ><IMG SRC="rose_charcoal_3.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_charcoal_5.gif"
     ><IMG SRC="rose_charcoal_5.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

For a better example of using a charcoal transformation on a real image see
<A HREF="../photos/#charcoal" >Charcoal Sketch of a Photo</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Technically the "<CODE><A HREF="../option_link.cgi?charcoal"
  >-charcoal</A></CODE>" operator is a "<CODE><A
  HREF="../option_link.cgi?edge" >-edge</A></CODE>" operator with some
  thresholding applied to a grey-scale conversion of the original image.
</I></FONT></TD></TR></TABLE></P>

<A NAME="sketch"></A>
<H3>Pencil Sketch Transform</H3>

The "<CODE><A HREF="../option_link.cgi?sketch" >-sketch</A></CODE>" operator
basically applies a pattern of line strokes to an image to generate what looks
like an artistic pencil sketch.  Arguments control the length and angle of the
strokes. </P>

However it is best applied to a larger image with distinct and shadings. </P>

See <A HREF="../photos/#pencil" >Pencil Sketch</A> for a full example of this
operator and how it works internally. </P>


<A NAME="emboss"></A>
<H3>Emboss, creating a metallic impression</H3>

The "<CODE><A HREF="../option_link.cgi?emboss" >-emboss</A></CODE>" operator
tries to generate the effect of an acid impression of a grey-scale image on a
sheet of metal.  It is in many respects very similar to the "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator we will look at <A
HREF="#shade" >below</A>, but without the 3D looking edges. </P>

Its argument is a radius/sigma, with only the sigma being important. I not
found the argument very useful, and may in fact be buggy.  The argument has
also changed in a recent version of IM.  I just don't know what is going on.
Help me understand if you can.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -emboss 0x.5  rose_emboss_0x05.gif
  convert rose:  -emboss 0x.9  rose_emboss_0x09.gif
  convert rose:  -emboss 0x1   rose_emboss_0x10.gif
  convert rose:  -emboss 0x1.1 rose_emboss_0x11.gif
  convert rose:  -emboss 0x1.2 rose_emboss_0x12.gif
  convert rose:  -emboss 0x2   rose_emboss_0x20.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_emboss_0x05.gif"
      ><IMG SRC="rose_emboss_0x05.gif"
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_emboss_0x09.gif"
     ><IMG SRC="rose_emboss_0x09.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_emboss_0x10.gif"
     ><IMG SRC="rose_emboss_0x10.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_emboss_0x11.gif"
     ><IMG SRC="rose_emboss_0x11.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_emboss_0x12.gif"
     ><IMG SRC="rose_emboss_0x12.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_emboss_0x20.gif"
     ><IMG SRC="rose_emboss_0x20.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
The operator is a grey-scale operator, meaning it will be applied to the three
color channels, separately. As such should only be applied to grey-scale
images. As you saw above, color images can produce some weird effects.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -colorspace Gray  -emboss 0x.5  rose_g_emboss_0x05.gif
  convert rose: -colorspace Gray  -emboss 0x.9  rose_g_emboss_0x09.gif
  convert rose: -colorspace Gray  -emboss 0x1   rose_g_emboss_0x10.gif
  convert rose: -colorspace Gray  -emboss 0x1.1 rose_g_emboss_0x11.gif
  convert rose: -colorspace Gray  -emboss 0x1.2 rose_g_emboss_0x12.gif
  convert rose: -colorspace Gray  -emboss 0x2   rose_g_emboss_0x20.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose_grey.gif"
     ><IMG SRC="../images/rose_grey.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_g_emboss_0x05.gif"
     ><IMG SRC="rose_g_emboss_0x05.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_g_emboss_0x09.gif"
     ><IMG SRC="rose_g_emboss_0x09.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_g_emboss_0x10.gif"
     ><IMG SRC="rose_g_emboss_0x10.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_g_emboss_0x11.gif"
     ><IMG SRC="rose_g_emboss_0x11.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_g_emboss_0x12.gif"
     ><IMG SRC="rose_g_emboss_0x12.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_g_emboss_0x20.gif"
     ><IMG SRC="rose_g_emboss_0x20.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<PRE> If anyone knows exactly what the emboss algorithm is supposed to do,
please let me know.

</PRE>

<A NAME="stegano"></A>
<H3>Stegano, hiding a secret image within an image</H3>

The "<CODE><A HREF="../option_link.cgi?stegano" >-stegano</A></CODE>" operator
is really more of a 'fun' operator.  For example it could be use by a spy to
hide info in the 'chaos' of a random image. </P>

First a warning...
<DIV ALIGn=center><B>
   Do not use JPEG, GIF, or any other 'lossy' image encoding with Stegano
</B></DIV></P>

For example, lets generate a cryptic message (image) that you want to send to
your fellow spy...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
              <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -gravity center -size 50x40 label:"Watch\nthe\nPidgeon" message.gif
</CODE><CODE EXECUTE NOWARN OUT=message_size.txt
>  identify message.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="message.gif"
     ><IMG SRC="message.gif"       WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="message_size.txt"
      ><IMG SRC="message_size.txt.gif"
            ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

Note that we will also need the size of the message image (36x43 pixels), thus
the identify in the above. </P>

Next the put it into some image with some offset.  The offset (and message
size) used is the cryptographic 'key' for the hidden message.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite message.gif rose: -stegano +15+2  rose_message.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_message.png"
     ><IMG SRC="rose_message.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now you can send that image to your compatriot, who presumably already knows the
messages size and offset. </P>

We can the recover the message hidden in the image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x40+15+2 stegano:rose_message.png message_recovered.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="message_recovered.gif"
     ><IMG SRC="message_recovered.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The larger the containing image the better the recovered image will be, so
hiding small images in larger ones is better than the example shown above.</P>

Just to show you how the hidden message was distributed throughout the
container image, lets do a comparison of the combined image against the
original.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
              <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=rose_diff_pae.txt>
  compare -metric PAE rose:  rose_message.png   rose_difference.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="rose_difference.png"
     ><IMG SRC="rose_difference.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rose_diff_pae.txt"
     ><IMG SRC="rose_diff_pae.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

Which shows how the message image was encrypted and distributed all over the
container image to hide it. </P>

Also the '<CODE>PAE</CODE>' metric returned by the above shows that the
largest difference was only a single color value out of the 8 bit color values
used for this image.  </P>

That is tiny.  So tiny that a small change or modification to the image will
destroy the message hidden within.  It is such a small difference, you can't
even use JPEG with its lossy compression as the image format, or any other
lossy image format (including GIF) for the container image. </P>

Also if you had the wrong 'offset key' you will not get the message...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x40+14+2 stegano:rose_message.png message_bad.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="message_bad.gif"
     ><IMG SRC="message_bad.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also limit what area of the image the message is to be hidden by using
a <A HREF="../masking/#region" >Region</A> setting.  The same setting will
also be needed when attempting to recover the message.  This would probably
make finding and decoding the hidden message in a large image, especially if
restricted to a 'busy' area, an order of magnatitude harder to determine. </P>

However be warned that this is not a very cryptographically secure technique.
Especially if the original source image is also available. Frequency analysis
of the image will generally let an attacker know there is a hidden message.
</P>

As a method of image copyright protection, the <A HREF="#stegano" >Stegano
Operator</A> is also useless, as the smallest change to the image will destroy
the message, and thus its effectiveness. </P>

As a spy tool it is also not very good, with such a small number of
'combinations' for a reasonable sized image. Anyone who knows roughly what you
are doing could probably crack it quickly.  Better to stick to well known and
time tested cryptographic methods. </P>

It's only real practical use is as a fun tool, or as a way to add very small
amounts of noise to an existing image. </P>


<A NAME="encipher"></A>
<H3>Encrypting Image Data</H3>

The operators "<CODE><A HREF="../option_link.cgi?encipher"
>-encipher</A></CODE>" and "<CODE><A HREF="../option_link.cgi?decipher"
>-decipher</A></CODE>" will basically encrypt image data into a garbled mess.
</P>

That is the image content itself is no longer recognisable at all until the
image is later decrypted. This can be used for example to protect sensitive
images on public services, so that only others with the secret pass-phrase can
later view it. </P>

But first a warning...
<DIV ALIGn=center><B>
   Do not use JPEG, GIF, or any other 'lossy' image encoding with Encryption
</B></DIV></P>

For example lets encrypt that secret message image we created above, using
a pass-phrase I have saved in a, not quite so 'secret', file "<A
HREF="pass_phrase.txt">pass_phrase.txt</A>".

<!-- <CODE EXECUTE NO_TXT2GIF>
  echo "This is a secret pass-phrase, for image encryption" > pass_phrase.txt
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert message.gif    -encipher pass_phrase.txt  \
          -depth 8 png24:message_hidden.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="message.gif"
     ><IMG SRC="message.gif"       WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_hidden.png"
     ><IMG SRC="message_hidden.png"  WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The encrypted image assumes it is saved using a 8 bit image file format.  As
  such it is recommended to enforce that limitation by setting "<CODE><A
  HREF="../option_link.cgi?depth" >-depth</A> 8</CODE>" before the final save
  to the output file. </P>

  The "<CODE>png24</CODE>" was also needed in the above to ensure that the
  output is not a palette or colormapped "png8:" image, which also does not
  work properly.
</I></FONT></TD></TR></TABLE></P>

As you can see the resulting image looks like complete garbage, with no
indication of the images real content. </P>

Now you can publish that image on the web, and only someone who knows the
exact original pass-phrase can restore the image data...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert message_hidden.png -decipher pass_phrase.txt message_restored.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="message_restored.gif"
     ><IMG SRC="message_restored.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However be warned that if the image data is corrupted in some way, you will
not be able to restore it. That includes if the PNG saved using a gray-scale
image format type.  As such, only a non-lossy image format can be used, such
as PNG, MIFF, TIFF, or even <A HREF="../files/#txt" >Pixel Enumeration
Text</A>.  However using a lossy image format, such as JPEG, PNG8, and GIF,
will corrupt the image data, thus destroy the resulting encryption. </P>

Note that any meta-data that may be describing the image, will still be in the
clear.   That means, you could encrypt images using the images own 'comment'
string as the pass-phrase or use that comment encrypted using some smaller
password.  Its a simple idea that could make the pass-phrase more variable.
</P>

Encrypting an image can be just one step.  Taking the result just that little
further can produce an image that will not simply decrypt, without some extra
processing.  For example here I use some <A HREF="../warping/#simple" >Simple
Non-Destructive Distorts</A> to confuse anyone trying to decrypt the image in
the normal way.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  echo "password" | convert message.gif -encipher - \
                      -transpose  -depth 8   png24:message_obfuscate.png
  echo "password" | convert message_obfuscate.png -transpose \
                      -decipher -  message_restored_2.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="message.gif"
     ><IMG SRC="message.gif"       WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_obfuscate.png"
     ><IMG SRC="message_obfuscate.png"  WIDTH=40  HEIGHT=50
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_restored_2.png"
     ><IMG SRC="message_restored_2.png"  WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

If you did not include the "<CODE><A HREF="../option_link.cgi?transpose"
>-transpose</A></CODE>" in the decryption command above, the image will not
have deciphered correctly.  Also note that due to the streaming cipher used
(see the expert note below)  using just a "<CODE><A
HREF="../option_link.cgi?roll" >-roll</A></CODE>" of some sort will not
prevent the image from being decrypting, at least partially. </P>

Note that in the above I did not use a file to hold the 'pass-phrase' but fed
the phrase into the "<CODE>convert</CODE>" command using standard input, which
allows you use some other program or command to get the phrase from the
user, generate it, or some other method, instead of using text file with the
pass-phrase in the clear.  </P>

The pass-phrase could also be generated from other freely downloadable files
and images. For example you could decrypt your image using the signature, or
comment string of a well known, freely downloadable reference image.  For
instance here I use the signature of the "<CODE>rose.gif</CODE>" image to
encrypt and later decrypt the "<CODE>message.gif</CODE>" image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  identify -format %# rose.gif |\
    convert message.gif  -encipher - -depth 8    png24:message_signed.png
  identify -format %# rose.gif |\
    convert message_signed.png   -decipher -   message_restored_3.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="message.gif"
     ><IMG SRC="message.gif"       WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"       WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_signed.png"
     ><IMG SRC="message_signed.png"  WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"       WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_restored_3.png"
     ><IMG SRC="message_restored_3.png"  WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As of IM v6.4.8-0 the file used by "<CODE><A
HREF="../option_link.cgi?encipher" >-encipher</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?decipher" >-decipher</A></CODE>" can be a binary
file. As such you could even directly use an image itself as the the
passphrase.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert message.gif   -encipher rose.gif  -depth 8  png24:message_binary.png
  convert message_binary.png   -decipher rose.gif   message_restored_4.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="message.gif"
     ><IMG SRC="message.gif"       WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"       WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_binary.png"
     ><IMG SRC="message_binary.png"  WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"       WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="message_restored_4.png"
     ><IMG SRC="message_restored_4.png"  WIDTH=50  HEIGHT=40
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.4.8-0 a binary file would stop at the first 'NULL' character it
  finds.  Something that would happen rather early if a PNG image was used.
</I></FONT></TD></TR></TABLE></P>


This technique is exact (unless some of the data was destroyed in
transmission).  And as such you can use it to encrypt an image containing
other hidden information such as a <A HREF="#stegano" >Stegano Image</A>.
This means even if authorities do decrypt the image, or force you to reveal
the password, they will see actual image, but that image may not be the final
hidden one.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?encipher" >-encipher</A></CODE>" and
  "<CODE><A HREF="../option_link.cgi?decipher" >-decipher</A></CODE>"
  operators was added to IM v6.3.8-6, but required you to include a
  "<CODE>--enable-cipher</CODE>" option in the build configuration.
  However by IM v6.4.6 (when did it change?) this configuration item was no
  longer needed and it became a standard configuration setting.  As such you
  can probably use it immedaitally.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The cipher was implemented using a self-synchronizing stream cipher
  implemented from a block cipher. </P>

  This means that you can still decipher even a partial download of the image,
  which was destroyed by transmission error, even though some part of the
  image may have been destroyed.  You also do not need to downloaded the whole
  image to decrypt and examine the parts that was successfully downloaded.
  </P>

  But you do need the pass-phase to have any chance at all of successfully
  decrypting the image, as it is a very very strong encryption. </P>

</I></FONT></TD></TR></TABLE></P>

<A NAME="pixelate"></A>
<H3>Pixelate an Image</H3>

Pixelating an image is basicaly used to convert an image into a set of large
colored 'pixels' that only shows a vague outline of the original image. </P>

Both techniques involve shrinking the image (to generate fewer pixels), then
enlarging them in such a way so as to create 'pixel block' using either
a <A HREF="../resize/#scale" >Scaling Operator</A> or <A
HREF="../resize/#sample" >Sampling Operator</A> to generate the block of
color.  It is just how the image is reduced that determines exactly what color
wil be used.  A single pixel sample, or a merged average color.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -sample 25%  -scale 70x46\!  rose_pixelate_sampled.gif
  convert rose:  -scale  25%  -scale 70x46\!  rose_pixelate_scaled.gif
  convert rose:  -resize 25%  -scale 70x46\!  rose_pixelate_resized.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"       WIDTH=76  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_pixelate_sampled.gif"
     ><IMG SRC="rose_pixelate_sampled.gif"      WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_pixelate_scaled.gif"
     ><IMG SRC="rose_pixelate_scaled.gif"       WIDTH=76  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_pixelate_resized.gif"
     ><IMG SRC="rose_pixelate_resized.gif"      WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see, the 'sampled' areas will have much more distinct (aliased)
'pixels', while the other two uses a merged or averaged color, which tends to
produce more muted, but more accurite color representation for each 'pixel'.
</P>

See also  <A HREF="../photos/#anonymity" >Protect Someones Anonymity</A> for
an example of using this on just a smaller masked area of the image, such as
a persons face. </P>


<A NAME="gridding"></A>
<H3>Grids of Pixels</H3>

Gridding an image is very similar to pixelating an image.  In this case we
want only want to enlarge the image, to generate distinct pixel-level view
of an image's details.  Typically a very small image. </P>

The simplest way is like the previous example, simply <A
HREF="../resize/#scale" >Scale</A> a small image, to enlarge the pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -crop 10x10+12+20 +resize  grid_input.png
  convert grid_input.png  -scale  1000%  grid_scale.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="grid_input.png"
     ><IMG SRC="grid_input.png"       WIDTH=10  HEIGHT=10
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="grid_scale.png"
     ><IMG SRC="grid_scale.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The problem with a simple scaling, is that in areas where pixels are similar
in color, you can have trouble seeing the individual 'pixel blocks'. </P>

What we need to add a border around the pixels, to separate them. </P>

For this we need to overlay a generated tile mask. See <A
HREF="../canvas/#tile_memory" >Tiling with an Image already In Memory</A> for
various methods of using a generated tiling image, in a single command. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here we generate a white on black 'grid' which is overlayed using <A
HREF="../compose/#screen" >Screen Composition</A> (overlay white, while
leaving black areas as-is).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x10 xc: -draw 'rectangle 1,1 9,9' -write mpr:block +delete \
          grid_input.png -scale 1000% -size 101x101 tile:mpr:block \
          +swap -compose screen -composite grid_blocks.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="grid_blocks.png"
     ><IMG SRC="grid_blocks.png"    WIDTH=101 HEIGHT=101
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the size used to generate the tile is
<CODE><I>scale</I>*<I>image_size</I>+<I>gap_size</I></CODE> (in this case
10*10+1 =&gt; 101). </P>

I also <A HREF="../basics/#swap" >Swapped</A> the two images so that the final
image size comes from the tile image, rather than from the scaled image which
is one pixel smaller in size. However this may lose any image meta-data that
was in the original image as I used the tiled image for the destination. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here I generate circular 'spots' of color, but this time used a <A
HREF="../compose/#multiply" >Multiply Composition</A> (overlay black, while
leaving white areas as-is).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x10 xc: -draw 'circle 5,5 1,3' -negate \
               -write mpr:spot +delete \
          grid_input.png -scale 1000% -size 101x101 tile:mpr:spot \
          +swap -compose multiply -composite grid_spots.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="grid_spots.png"
     ><IMG SRC="grid_spots.png"    WIDTH=101 HEIGHT=101
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can make the grid border transparent by also negating the tiled overlay
(black areas become transparent) and use a <A HREF="../compose/#copyopacity"
>CopyOpacity Composition</A> instead of  <A HREF="../compose/#multiply"
>Multiply</A>. </P>

Other colors can also be added, but for this to work you have to use a tile
image that actually contains real transparency.  For this you need to convert
the black and white tile image into a <A HREF="../masking/#shapes" >Shaped
Mask</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, here I use <A HREF="../morphology/#basic" >Basic Morphology
Operator</A> to generate a diamond shaped 'holes' in a colored overlay.  For
this a single 'seed' pixel is drawn and expanded using a <A
HREF="../morphology/#diamond" >Diamond Morphology Kernel</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x10 xc: -draw 'point 5,5' -morphology Erode:4 Diamond \
          -background Navy -alpha shape -write mpr:diamond +delete \
          grid_input.png -scale 1000% -splice 1x1+0+0 \
          -size 101x101 -background none tile:mpr:diamond \
          -alpha set -compose Over -composite grid_diamonds.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="grid_diamonds.png"
     ><IMG SRC="grid_diamonds.png"    WIDTH=101 HEIGHT=101
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that the "<CODE>tile:</CODE>" coder will replace any transparency in
  the image with the current background color.  If you want to preserve the
  transparency of the tiling image, either set "<CODE>-background none</CODE>"
  or "<CODE>-compose Src</CODE>". The former is easier.
</I></FONT></TD></TR></TABLE></P>

Note techniqually, the alpha shaping can be done either before saving the tile
image, or after tiling the tile image, before overlaying it.  The choice is
yours. </P>

One final technique is to use a bad resampling filter to produce a <A
HREF="../distorts/#distort_failure" >Resampling Failure</A> to generate
aliased circles of each pixel.  This is not great technique (mis-using image
processing failure), but it does form a Grid of Pixels. </P>

<A NAME="spacing_tiles"></A>
<H3>Spacing Out Tiles</H3>

A similar problem is spacing out a grid of tiles in an image.  this is not
simply scaling up individual pixels into 'pixel blocks' but inserting space
between rectangluar areas of an image.  That is <A HREF="../crop/#splice"
>Splicing</A> extra pixels into an image at regular intervals. </P>

Currently the best solution is to break up the image into <A
HREF="../crop/#crop_strip" >Rows and Columns</A> and <A HREF="../crop/#splice"
>Splicing</A> in the extra spacing onto each tile before <A
HREF="../layers/#append" >Appending</A> the tiles back together. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -background SkyBlue \
          -crop 10x0 +repage -splice 3x0 +append \
          -crop 0x10 +repage -splice 0x3 -append \
          grid_tile.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"       WIDTH=76  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="grid_tile.png"
     ><IMG SRC="grid_tile.png"      WIDTH=91  HEIGHT=61
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Here is another method which also separates the original image into tiles, but
then uses some <A HREF="#fx_escapes" >DIY FX Expressions</A> to calculate the
new postion of a tile, from its old position.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=middle><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 10x10 \
          -set page '+%[fx:page.x+3*page.x/10]+%[fx:page.y+3*page.y/10]' \
          -background skyblue -layers merge +repage  grid_tile_fx.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="grid_tile_fx.png"
     ><IMG SRC="grid_tile_fx.png"    WIDTH=88 HEIGHT=58
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The number '<CODE>3</CODE>' in the above is the gap width to add, and
'<CODE>10</CODE>' is the tile size.  All that you need is to add a border or
other edge to the result. </P>

With a little more work you can even add some random 'jitter' to the placement
of each tile in the above grid, for a less regular effect. </P>

The problem with both these methods is that generating lots of small images,
only to join them back together does generate a lot of work.  Especially for
very small tiles sizes. </P>

A better method that has been proposed is a special extension to the <A
HREF="../crop/#splice" >Splice Operator</A>, in the IM Forum Discussion <A
HREF="../forum_link.cgi?f=2&t=21060&p=85371" >Splice (adding tile gridding
gaps)</A>. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="vision"></A>
<H2>Computer Vision Transformations</H2>

<A NAME="edge"></A>
<H3>Edge Detection</H3>

The "<CODE><A HREF="../option_link.cgi?edge" >-edge</A></CODE>" operator
highlights areas of color gradients within an image.  It is a grey-scale
operator, so is applied to each of the three color channels separately.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mask.gif -edge 1   mask_edge_1.gif
  convert mask.gif -edge 2   mask_edge_2.gif
  convert mask.gif -edge 3   mask_edge_3.gif
  convert mask.gif -edge 10  mask_edge_10.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mask.gif"
     ><IMG SRC="mask.gif"                    WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="mask_edge_1.gif"
     ><IMG SRC="mask_edge_1.gif"             WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mask_edge_2.gif"
     ><IMG SRC="mask_edge_2.gif"             WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mask_edge_3.gif"
     ><IMG SRC="mask_edge_3.gif"             WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mask_edge_10.gif"
     ><IMG SRC="mask_edge_10.gif"            WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see, the edge is added only to areas with a color gradient that is
more than 50% white!  I don't know if this is a bug or intentional, but it
means that the edge in the above is located almost completely in the white
parts of the original mask image.  This fact can be extremely important when
making use of the results of the "<CODE><A HREF="../option_link.cgi?edge"
>-edge</A></CODE>" operator. </P>

For example if you are edge detecting an image containing an black outline,
the "<CODE><A HREF="../option_link.cgi?edge" >-edge</A></CODE>" operator will
'twin' the black lines, producing a weird result.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert piglet.gif  -colorspace Gray  -edge 1 -negate  piglet_edge.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/piglet.gif"
     ><IMG SRC="../images/piglet.gif"        WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="piglet_edge.gif"
     ><IMG SRC="piglet_edge.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

However by negating the image before doing the edge detecting, the twined lines
go inward and join together, removing the 'twin line' effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert piglet.gif -colorspace Gray \
                 -negate -edge 1 -negate    piglet_edge_neg.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="piglet_edge_neg.gif"
     ><IMG SRC="piglet_edge_neg.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

I have found that the edges tend to be too sharp, generating a non-smooth edge
to the resulting images. As such I find a very very slight blur to the result
improves the look quite a bit.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert piglet_edge_neg.gif  -blur 0x.5  piglet_edge_blur.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="piglet_edge_blur.gif"
     ><IMG SRC="piglet_edge_blur.gif"        WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here I have applied edge detection to a color image, and a grey-scale version
to show you its effects on photo-like images.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:                   -edge 1  rose_edge.gif
  convert rose: -colorspace Gray  -edge 1  rose_edge_grey.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rose_edge.gif"
     ><IMG SRC="rose_edge.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_edge_grey.gif"
     ><IMG SRC="rose_edge_grey.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see without converting the image to grey-scale the edges for the
different color channels are generated completely independent of each other.
</P>

<A NAME="canny"></A>
<H3>Canny Edge Detector</H3>

As on IM v6.8.9-0, IM now supports the canny edge detector.  (See <A
HREF="../forum_link.cgi?f=4&t=25405" >Announcment Examples</A> on the IM
Forum). This is a very advanced edge detection algorithm, that produces a very
strong (binary) single pixel wide lines at all sharp edges, with very little
noise interferance. </P>

For example, here we apply it to the test images we used above..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mask.gif           -canny 0x1+10%+30%  mask_canny.gif
  convert piglet.gif         -canny 0x1+10%+30%  piglet_canny.gif
  convert piglet.gif -negate -canny 0x1+10%+30%  piglet_canny_neg.gif
  convert rose:              -canny 0x1+10%+30%  rose_canny.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mask.gif"
     ><IMG SRC="mask.gif"                    WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="mask_canny.gif"
     ><IMG SRC="mask_canny.gif"             WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="piglet_canny.gif"
     ><IMG SRC="piglet_canny.gif"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="piglet_canny_neg.gif"
     ><IMG SRC="piglet_canny_neg.gif"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_canny.gif"
     ><IMG SRC="rose_canny.gif"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see it produces a much sharper result than the <A HREF="#edge"
>Edge Operator</A> above.  The fuzzy anti-aliased edge has little to no
effect, on the result producing thin bitmap lines.

Also as the piglet image shows it is not placed on one specific side as the
previous edge operator did.  As a result, negating the input image has no
effect.  But like all edge detectors it can have problems with real world
images with 'busy' backgrounds, such as the built-in rose image. </P>

This clean result is very important later in <A HREF="#hough" >Hough Line
Detection</A>. </P>


<A NAME="edge_jitter"></A>
<H3>Edge Outlines from Anti-Aliased Shapes</H3>

The biggest problem with normal edge detection methods is that the result is
highly aliased. That is it generates a very staircase like pixel effects,
regardless of if the shape is smooth (anti-aliased) or aliased.  </P>

For example here is a smooth anti-aliased voice balloon ("WebDings" font
character '<CODE>(</CODE>' ).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 -gravity center -font WebDings label:')' voice.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="voice.gif"
     ><IMG SRC="voice.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here is its edge detected image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert voice.gif -edge 1 -negate   voice_edge.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="voice_edge.gif"
     ><IMG SRC="voice_edge.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see it looks horrible, with some minor anti-aliasing on the outside
of the edge, and a total aliased (staircase) look on the inside of the line.
</P>

The negating the image generated a similar outline around the outside of the
image, but also has strong aliasing outside of the line.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert voice.gif -negate -edge 1 -negate   voice_edge_negate.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="voice_edge_negate.gif"
     ><IMG SRC="voice_edge_negate.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

An alternative when you already have an image with an anti-aliased edge,
is to generate the difference image of a 'jittered' clone of the original
shape.  For example here we find the difference image between the original,
image and one that has been offset (or jittered) to the right by 1 pixel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert voice.gif \( +clone -roll +1+0 \) -compose difference -composite \
          -negate   voice_jitter_horiz.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="voice_jitter_horiz.gif"
     ><IMG SRC="voice_jitter_horiz.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the this does not produce a good edge for horizontal sloped edges.
However by combining both a horizontal and a vertical jittered difference
image, we can get a very good anti-aliased outline of the shape.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert voice.gif \
          \( -clone 0 -roll +1+0 -clone 0 -compose difference -composite \) \
          \( -clone 0 -roll +0+1 -clone 0 -compose difference -composite \) \
          -delete 0  -compose screen -composite -negate  voice_jitter_edge.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="voice_jitter_edge.gif"
     ><IMG SRC="voice_jitter_edge.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This technique also has the advantage of working regardless of if the mask is
negated or not. </P>

Note however that the result has a 1/2 pixel offset relative to the original
image, so it may require some further 'distortion' processing to re-align
either the original shape, or the outline if the two needs to be combined
to get the result you want. </P>


<A NAME="edge_bitmap"></A>
<H3>Edge Outlines from Bitmap Shapes</H3>

Bitmap images are much harder, as they don't have any anti-aliased pixels
that can be used to produce a smooth outline. </P>

For example here is a fancy 'Heart' shape that was extracted from the
"WebDings" font (character '<CODE>Y</CODE>').  However I purposefully
generated it as an aliased bitmap, to simulate a horrible bitmap image
downloaded from the network.  Such as the outline of a GIF image containing
transparency.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert +antialias -size 80x80 -gravity center \
          -font WebDings label:Y   heart.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart.gif"
     ><IMG SRC="heart.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

So we have this horrible image, but we want to find the images outline rather
than its shape.  Direct use of edge detection will only generate a pure bitmap
edge around the outside of the bitmap shape.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart.gif -edge 1 -negate   heart_edge.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_edge.gif"
     ><IMG SRC="heart_edge.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

A negated edge generates an edge image but for the inside of the black area.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart.gif -negate -edge 1 -negate   heart_edge_negate.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_edge_negate.gif"
     ><IMG SRC="heart_edge_negate.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By adding both of the above you get a 2 pixel edge centered on the bitmap
shapes edge.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart.gif \( +clone -negate \) -edge 1 \
          -compose add -composite  -negate  heart_edge_double.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_edge_double.gif"
     ><IMG SRC="heart_edge_double.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the resulting image is highly aliased with 'staircase' like
effects in the outline, even though the original image is itself not too bad
in this regard.  This is not a good solution. </P>

A slightly better edge can be created by using an '<CODE><A
HREF="../morphology/#edge-in" >EdgeIn</A></CODE>' morphology method, or others
like it.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart.gif  -negate -morphology EdgeIn Diamond -negate heart_edgein.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_edgein.gif"
     ><IMG SRC="heart_edgein.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And a similar effect can be achieved by just using resizes to blur the edge in
the right way, before using a <A HREF="../color_mods/#solarize" >Solarize</A>
to extract the mid-gray pixels that form the edge. A thicker edge can be
generated by adding a "<CODE>-filter Cubic</CODE>" setting, or some other <A
HREF="../filter/#filter" >Resampling Filters</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart.gif -resize 400% -resize 25% \
          -solarize 50% -evaluate multiply 2 -negate heart_resize.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_resize.gif"
     ><IMG SRC="heart_resize.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or for more controlled fuzzier effect you can just blur the shape and extract
the edge in a similar way.  I find a blur of '<CODE>0.7</CODE>' about the
best, with a 3 pixel limit to speed things up.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart.gif -blur 3x.7 -solarize 50% -level 50%,0 heart_blur.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_blur.gif"
     ><IMG SRC="heart_blur.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the use of <A HREF="../color_mods/#level" >Level Operator</A>, which is
the equivalent of the "<CODE>-evaluate multiply 2 -negate</CODE>" used in the
previous example. </P>

With an anti-aliased border you can now re-add the original shape if you just
want to smooth the original shape rather than get its outline. Just remember
that the outline is positioned exactly along the edge of the original image, so
will be half a pixel larger in size that the previous examples.  </P>

<I>Do you know of any other ways of generating an anti-aliased outline from a
shape (anti-aliased, or bitmap).  If so please mail it to me, or the IM forum.
You will be credited.</I> </P>


<A NAME="edge_vector"></A>
<H3>Edging using a Raster to Vector Converter</H3>

One of the most ideal solutions is to use a non-IM '<I>raster to vector</I>'
conversion program to convert this bitmap shape into a vector outline.
Programs that can do this include: "<CODE>ScanFont</CODE>",
"<CODE>CorelTrace</CODE>", "<CODE>Streamline</CODE>" by Abobe, and "<CODE><A
HREF="http://vectormagic.com/home" >Vector Magic</A></CODE>". Most of these
however cost you at least some money. "VectorMagick" and another tracing
program "<A HREF="http://www.autotracer.org/" >AutoTracer</A>" have free to
use online image converters available.  Other free solutions are "<CODE><A
HREF="http://autotrace.sourceforge.net/" >AutoTrace</A></CODE>", or "<CODE><A
HREF="http://potrace.sourceforge.net/" >PoTrace</A></CODE>". More suggestions
are welcome. </P>

These trace programs are simple to use, but typically requires some form of
pre and post image setup.  They have a limited number of input formats, and
outputs a vector image which will create a 'smoothed' form of the input image.
I prefer the "<CODE>AutoTrace</CODE>" as it does not scale the resulting SVG
data, and thus producing a standard line thickness, however you can not use it
in a 'pipeline'. </P>

For best results it is a good idea to ensure we only feed it a basic bitmap
image, which we can ensure by thresholding the input image, while we convert
it to an image format autotrace understands.  I can then convert that image
into a SVG vector image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=heart_svg.gif ERR=/dev/null>
  convert heart.gif -colorspace gray -threshold 50% heart_tmp.pbm
  autotrace -output-format svg -output-file heart.svg heart_tmp.pbm
  convert heart.svg heart_svg.gif
  rm -f heart_tmp.pbm
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD>
  <A HREF="heart.gif"
     ><IMG SRC="heart.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
</TD><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="heart.svg"
     ><IMG SRC="heart.svg.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD><TD>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
</TD><TD>
  <A HREF="heart_svg.gif"
     ><IMG SRC="heart_svg.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>
<!-- <CODE EXECUTE NOIMAGE>
  txt2gif -fmt heart.svg
</CODE> -->

As of IM v6.4.2-6 you can do the above sequence directly using the
"<CODE>autotrace:</CODE>" image input delegate.  This only requires the
"<CODE>autotrace</CODE>" command to be installed.  For example

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert autotrace:heart.gif  heart_traced.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="heart_traced.gif"
      ><IMG SRC="heart_traced.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If your IM was built with the "<CODE><A
HREF="http://autotrace.sourceforge.net/" >AutoTrace</A></CODE>" delegate
library, you can also have IM directly generate the SVG image from an image in
memory. For details of this see <A HREF="../draw/#svg_output" >SVG Output
Handling</A>.  For example....

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=/dev/null>
  convert heart.gif  heart_2.svg
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="heart_2.svg"
     ><IMG SRC="heart_2.svg.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>
<!-- <CODE EXECUTE NOIMAGE>
  txt2gif -fmt heart_2.svg
</CODE> -->

Now the SVG output will of course represent a smoothed version of the original
image, which is not what we actually want in this example.  But as we now have
the shape of the bitmap in <I>vector form</I>, we can simply adjust the SVG
'<CODE>style</CODE>' attributes so as to '<CODE>stroke</CODE>' the outline,
rather than '<CODE>fill</CODE>' the shape.  The modified SVG can then be fed
back into ImageMagick again to recreate the clean outline raster image.  </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT ERR=/dev/null>
  cat heart.svg |
    sed 's/"fill:#000000[^"]*"/"fill:none; stroke:black;"/' |
      convert svg:- heart_outline.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_outline.gif"
     ><IMG SRC="heart_outline.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Yes it is a little awkward, but the smooth anti-aliased result is well worth
the effort.  It would be nice if outline or some other modifications could be
specified as options to the "<CODE>autotrace</CODE>" command itself, but that
is currently not a feature. </P>

You can also further modify the SVG output to thickening the edge, or specify
some other stroke or background color, change the fill color of the vector
edge shape.  For example here we generate a thicker outline of the shape with
a red fill, all nicly anti-aliased.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT ERR=/dev/null>
  cat heart.svg |
    sed 's/"fill:#000000;[^"]*"/"fill:red; stroke:black; stroke-width:5;"/' |
        convert svg:- heart_outline_thick.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_outline_thick.gif"
     ><IMG SRC="heart_outline_thick.gif"       WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Such a perfect looking heart could not have been generated from a bitmap shape
in any other way. </P>

We could also just extract the '<CODE>d="..."</CODE>' path element to use
directly as a <A HREF="../draw/#paths" >SVG Path String</A> in the <A
HREF="../draw/#intro" >Draw Command</A>. This would then allow you to use any
of the other IM draw settings with that vector outline, giving you complete
control of the final result. </P>

For another example of using the "<CODE><A
HREF="http://autotrace.sourceforge.net/" >AutoTrace</A></CODE>" program, see
<A HREF="../morphology/#autotrace_skeleton" >Skeleton using Autotrace</A>.
</P>

<A NAME="hough"></A>
<H3>Hough Line Detector</H3>

The Hough Line Detector ("<CODE><A HREF="../option_link.cgi?hough-lines"
>-hough-lines</A></CODE>" added IM v6.8.9-1), is a very complex transform with
a lot of stages (for details see <A
HREF="http://en.wikipedia.org/wiki/Hough_transform" >Wikipedia, Hough
Transform</A>).  Basically it is designed to examine an image, looking for
white lines on a black background, and try to return the exact location of any
line segments (linear sequences pixels) present in the image.  This can be
very important for things like removing image rotations, or determining the
perspective transformation in an image, so it can be repeated, or removed.
</P>

Here is the full set of options to the operator

<CENTER>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -background {<I>background</I>} -stroke {<I>line_color</I>} <!--
-->-hough-lines {<I>W</I>}x{<I>H</I>}+{<I>threshold</I>}
</CODE></PRE></TD></TR></TABLE>
</CENTER></P>

The colors (<I>background</I> and <I>line_color</I>) is used to set the colors
of lines in the resulting image (if you actually draw them). The
argument to the Hough Operator (<I>W</I>}x{<I>H</I>}+{<I>threshold</I>) is
used to define the size and treshold of the filter used to find 'peaks' in the
intermedite 'search image'.  that is is controls how well it actuall 'finds'
the lines we are trying to detect (see below). You would adjust these help
find the line detection.  </P>

For example lets try to find the lines in a rectangular shaped image.

First we need to reduce the image to lines, and for a clean result the <A
HREF="#canny" >Canny Edge Detector</A> is recommened.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shape_rectangle.gif -canny 0x1+10%+30% rectangle.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/shape_rectangle.gif"
     ><IMG SRC="../images/shape_rectangle.gif"                    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rectangle.gif"
     ><IMG SRC="rectangle.gif"                    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Now lets apply the Hough Line Detector to this image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rectangle.gif -background black -stroke red \
          -hough-lines 5x5+20   rectangle_lines.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rectangle_lines.gif"
     ><IMG SRC="rectangle_lines.gif"       WIDTH=100   HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see 5 lines were found, 2 of which are very close together.  The
reason for the extra line is that the rectangle in the image is not perfect.
</P>

Now while I am displaying an raster (GIF) image result, the Hough Operator
actually generates a vector image in <A HREF="../draw/#mvg" >Magick Vector
Graphics Format</A>.  This means you can list the line information for further
processing.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE TXT2GIF>
  convert rectangle.gif -background black -stroke red \
          -hough-lines 5x5+20   rectangle_lines.mvg
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rectangle_lines.mvg"
     ><IMG SRC="rectangle_lines.mvg.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that the lines are drawn from one edge (with floating point values) to
another edge of the image. And from this you can see that the second and third
lines are the two that are close.  </P>

The comment in the MVG output gives you the accumulated number of pixels that
the line 'hits' in the image, and thus is a good indication of how strong
the line is in the image.  This value will always be larger than the treshold
value you give to the "<CODE><A HREF="../option_link.cgi?hough-line"
>-hough-line</A></CODE>" operator. From this you can see the first and last
lines (which are close matches) are both roughly equal in strength, so it
would be hard to pick one of them over another. </P>

If this happens to you, I suggest you try to improve your edge detection step.
</P>

Note that MVG image does not have any colors defined. The color settings in
this example were not actually used.  The colors are only used if you actually
'draw' the vectors when converting the above result into a 'raster' image, as
we did before. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

You can also see the intermedate 'search image', or 'accumulator' that is
looking for white pixels in every orientation, by using a special <A
HREF="../basics/#define" >define</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rectangle.gif \
          -define hough-lines:accumulator=true -hough-lines 5x5+20 \
          -delete 0 -contrast-stretch 0.1% rectangle_accumulator.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rectangle_accumulator.gif"
     ><IMG SRC="rectangle_accumulator.gif"       WIDTH=180
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The define will just append the 'search image' to the image result, which in
this case we delete.  We also applied some contast to the 'accumulated values'
to make them more visible. This is the image that the arguments to the Hough
Detector is searching. </P>

The image is always 180 pixels wide (1 pixel per degree of line angle),  while
the height is twice the diagonal length of the image.  As such the location of
the peak will directly define the angle of the line, and the perpendicular
distance of the line relative to the center point of the input image.  That is
the X coordinate is the angle in degrees, and the Y coordinate the distance
from center from -diagonal distance, to +diagonal distance. </P>

If you look closely at the lower-right peak you can see why we ended up with
two lines instead of one.  The peak here is 'twined' with a slight gap between
them. </P>

The algorithm is based on the script "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/houghlines/"
>houghlines</A></CODE>" by Fred Wienhaus, though with a different
'perpendicular distance' accumulation handling. </P>

<HR WIDTH=30%><!-- ------------ -->

<A NAME="lat"></A>
<H3>Local Adaptive Thresholding</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

The "<CODE><A HREF="../option_link.cgi?lat" >-lat</A></CODE>" operator, tries
to adaptively threshold each pixel based on the value of pixels in a
surrounding window.  This is commonly used to threshold images with an uneven
background (i.e., uneven illumination).  It is based on the assumption that
pixels in a small window will have roughly the same background color and
roughly the same foreground color. </P>

<PRE>For example.
   convert input.png -lat 17 output.png
</PRE>

In the above a 17 pixel square 'window' is used to determine the average color
of the image at each point, if the pixel is darker than this average it is
made black, if lighter than this average it is made white. </P>

A small window size will make the threshold more sensitive to small changes in
illuminations, is faster to compute but is adversely affected by noise in the
image.

<PRE>Example</PRE>

A larger window size will make the threshold less sensitive to small
changes in illumination, is slower to compute and less affected by noise in the
image.  This has the effect of making the threshold value selection more or
less sensitive to small changes in pixel values.

<PRE>Example</PRE>

<PRE>
The window does not need to be square.  for example...
  convert input.png -lat 15x25 output.png
</PRE>

You can also provide an offset which will be added to the calculated average
color, making the local threshold value for each pixel either lighter or
darker.  This can be used for example to reduce the effect of noise or the
effect of small changes in pixel values. </P>

<PRE>
  convert input.png -lat 15x25+2%
</PRE>

These small changes normally occur when a scanner or digital camera is used to
acquire the image.  Use a positive offset value to make the adaptive
thresholding less sensitive to small variations in pixel values.  Use a
negative threshold to make the adaptive threshold more sensitive to small
variations in pixel values.  </P>

Alternatively, one could reduce the noise in the image before processing it
with "-lat". </P>

<PRE>
In summary, each pixel is thresholded using the following logic:
  AVG = average value of each pixel in the window
  IF (input pixel is > AVG + OFFSET)
     Output pixel is BLACK
  else
     Output pixel is WHITE

---

An alternative is to subtract a blurred copy of the original image
using (Modulus) Subtraction, then thresholding.

   convert rose: -colorspace gray -lat 10x10+0% x:

is roughly equivalent to...

   convert rose: -colorspace gray \( +clone -blur 10x65535 \) \
           -compose subtract -composite -threshold 50%  x:

The special "-blur 10x65535"  is a linear averaging blur limiting itself to a
10x10 window.

The 'Subtract' composition being a mathematical modulus type of operation will
wrap the values that goes negative back round to a value greater than 50%.

If you want to include an offset you can do so by also subtracting a solid
color background image by using a -flatten...  for example

   convert rose: -colorspace gray -lat 10x10+10% x:

is roughly equivalent to...

   convert rose: -colorspace gray \( +clone -blur 10x65535 \) \
           -compose subtract -background gray10 -flatten -threshold 50%  x:

</PRE>

The above was modified from initial notes provided by D Hobson
&lt;dhobson&#64;yahoo.com&gt; </P>

<HR WIDTH=30%><!-- ------------ -->
<PRE>
   -adaptive-sharpen
        Sharpen images only around the edges of the images

   -segment cluster-threshold x smoothing-threshold
         Segmentation of the color space (not image objects)
         This can produce very verbose output.
         This applies the "fuzzy c-means algorithm" if you want to know more.

Also related is -despeckle. to remove single off color pixels.

Generate a 3d stereogram of two images (one for each eye)
This is also known as an anaglyph
  composite left.jpg right.jpg -stereo anaglyph.jpg

</PRE>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="shade"></A>
<H2>Shade 3D Highlighting</H2>

<H3>Shade Usage</H3>

The "<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator
I have always thought one of the most interesting operators provided by
ImageMagick.  The documentation of this operator only gave a rough hint as to
its capabilities.  It too me a lot of personal research to make sense of the
operator, and even figure out how best to use the power that it can provide
IM users. </P>

Basically what this operator does is assume that the given image is something
called a 'height field'.   That is a grey-scale image representing the surface
of some object, or terrain.  The color '<CODE>white</CODE>' represents the
highest point in an image, while '<CODE>black</CODE>' the lowest point. </P>

This representation come out of the 1980 computer vision research, where a
photo with a strong 'camera light' was used, making near points bright, and
points far away dark. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As a grey-scale image is needed by "<CODE><A
  HREF="../option_link.cgi?shade" >-shade</A></CODE>", the operator will
  automatically remove any color from the input image.  Similarly any
  transparency that may be present in the image is completely useless and
  ignored by the operator.
</I></FONT></TD></TR></TABLE></P>

Now "<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>" takes this
grey-scale height field and shines a light down onto it.  The result is
a representation of light shades that would thus be produced.
Remember you must think of the input image as a 'surface' for the output to
make any sense. </P>

For our demonstrations we will need a 'height field' image so lets draw one.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 64 -background black -fill white \
          label:A  -trim +repage -bordercolor black -border 10x5 \
          shade_a_mask.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="shade_a_mask.gif"
      ><IMG SRC="shade_a_mask.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This image is also equivalent of a 'mask' of an shape, is often not only used
as input to "<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>", but
also for <A HREF="../masking/#masks" >Masking Images</A> to cut out the same
shape from the shaded results. See <A HREF="#shade_mask" >Masking a Shade
Image</A> below. </P>

To the "<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator
this image will look like a flat black plain, with a flat white plateau rising
vertically upward. Only the edges of this image will thus produce interesting
effects. </P>

To this effect the two arguments defines the direction from which the light is
shining. </P>

The first argument is the <I>direction</I> from which the light comes.  As
such a '<CODE>0</CODE>' degree angle will be from the east (of left),
'<CODE>90</CODE>' is anti-clockwise from the north (or top), and so on.   For
example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_a_mask.gif   -shade    0x45   shade_direction_0.gif
  convert shade_a_mask.gif   -shade   45x45   shade_direction_45.gif
  convert shade_a_mask.gif   -shade   90x45   shade_direction_90.gif
  convert shade_a_mask.gif   -shade  135x45   shade_direction_135.gif
  convert shade_a_mask.gif   -shade  180x45   shade_direction_180.gif
</CODE></PRE></TD></TR></TABLE><TR><TD>
  <A HREF="shade_a_mask.gif"
     ><IMG SRC="shade_a_mask.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_direction_0.gif"
     ><IMG SRC="shade_direction_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_direction_45.gif"
     ><IMG SRC="shade_direction_45.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_direction_90.gif"
     ><IMG SRC="shade_direction_90.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_direction_135.gif"
     ><IMG SRC="shade_direction_135.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_direction_180.gif"
     ><IMG SRC="shade_direction_180.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You get the idea.  The light can come from any direction. </P>

The other argument is the <I>elevation</I>, and represents angle the light
source makes with the ground.  You can think of it as how high the sun is
during the day, so that '0' is dawn, and '90' is directly overhead.

<DIV ALIGN=center>
  <IMG SRC="../img_diagrams/shade_elevation.gif"        WIDTH=300 HEIGHT=170
       ALIGN=middle VSPACE=2 HSPACE=5 ALT="[diagram]"></A>
</DIV></P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_a_mask.gif   -shade  90x0    shade_elevation_0.gif
  convert shade_a_mask.gif   -shade  90x15   shade_elevation_15.gif
  convert shade_a_mask.gif   -shade  90x30   shade_elevation_30.gif
  convert shade_a_mask.gif   -shade  90x45   shade_elevation_45.gif
  convert shade_a_mask.gif   -shade  90x60   shade_elevation_60.gif
  convert shade_a_mask.gif   -shade  90x75   shade_elevation_75.gif
  convert shade_a_mask.gif   -shade  90x90   shade_elevation_90.gif
</CODE></PRE></TD></TR></TABLE><TR><TD>
  <A HREF="shade_elevation_0.gif"
     ><IMG SRC="shade_elevation_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_elevation_15.gif"
     ><IMG SRC="shade_elevation_15.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_elevation_30.gif"
     ><IMG SRC="shade_elevation_30.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_elevation_45.gif"
     ><IMG SRC="shade_elevation_45.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_elevation_60.gif"
     ><IMG SRC="shade_elevation_60.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_elevation_75.gif"
     ><IMG SRC="shade_elevation_75.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_elevation_90.gif"
     ><IMG SRC="shade_elevation_90.gif"
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see with an <I>elevation</I> of '<CODE>0</CODE>' the shape is only
highlighted on the side from which the light is coming.  Everything else is
black, as no light shines on any other surface. I call this a 'Dawn Highlight'
and has its own special uses. </P>

This brings us to the first item of note.  An image that is "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" will often have more dark,
or shadowed areas, than highlighted areas. The shading is not equal. </P>

As the light gets higher over the 'height field' image. The overall brightness
of the image will become whiter, until at 'high-noon' or an <I>elevation</I> of
'<CODE>90</CODE>' any flat areas are brilliantly white, and only slopes and
edges are shaded to a grey color, with a mid grey as a maximum, or
'cliff-like' slope change. </P>

This 'noon' image is another special case that is a bit like an edge detection
system, though it is between 2 and 4 pixels wide for sharp edges.  I have used
this image in the past for generating a mask for the the beveled edge of
"<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>" images, so as to
make flat areas transparent.  </P>

If the <I>elevation</I> angle goes beyond '<CODE>90</CODE>' degrees, you will
get the same result as if the light was from the other direction.  As such the
argument '<CODE>0x135</CODE>' will produce exactly the same result as
'<CODE>180x45</CODE>'.  A negative <I>elevation</I> angle will also produce the
same results, as if the light is coming up from below, onto a 'translucent'
like surface. As such '<CODE>0x-45</CODE>' will be the same as
'<CODE>0x45</CODE>'.  In other words for a particular shade there are usually
4 other arguments that will also produce the same result. </P>

From the above I would consider an argument of '<CODE>120x45</CODE>' to be
about the best for direct use of the shade output.  For example here it
creates some beveled text...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 320x100 xc:black \
          -font Candice -pointsize 72 -fill white \
          -draw "text 25,65 'Anthony'" \
          -shade 120x45  shade_anthony.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shade_anthony.jpg"
     ><IMG SRC="shade_anthony.jpg"        WIDTH=320  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

One of the major problems with "<CODE><A HREF="../option_link.cgi?shade"
>-shade</A></CODE>" is the thickness of the bevel that is actually produced.
A sharp edge such as I used above will always produce a bevel of about 4
pixels wide, both into and out of the masked area.  There is no way to adjust
this thickness, short of resizing images before and after using the "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator.. </P>

If you would like to find out just how bright 'flat areas' will be from a
specific <I>elevation</I> lighting angle, then you can use the following
command, to shade a flat solid color surface.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=shade_elevation_45.txt>
  convert -size 50x50 xc:white -draw 'circle 25,25 20,10' \
          -blur 0x2  -shade 0x45   -gravity center -crop 1x1+0+0 txt:-
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shade_elevation_45.txt"
     ><IMG SRC="shade_elevation_45.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

As you can see a <I>elevation</I> of '<CODE>45</CODE>' degrees produces a quite
bright flat color of about 70% grey, which is a reasonable grey level for
general viewing.  However if you plan to use shade for generating 3-D
highlights of various shapes, then the actual grey level becomes very
important.  This will be looking at later in <A HREF="#shade_overlay"
>Creating Overlay Highlights</A>. </P>

That is basically it, for the "<CODE><A HREF="../option_link.cgi?shade"
>-shade</A></CODE>" operator.  However using it effectively presents a whole
range of techniques and possibilities, which we will look at next. </P>

<A NAME="shade_mask"></A>
<H3>Masking Shaded Shapes</H3>

As mentioned above, a simple 'mask' shape is often used with "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" to generate complex 3-D
effects from a simple shape. For example lets do this to a directly shaded
mask image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_direction_135.gif  shade_a_mask.gif \
          -alpha Off -compose CopyOpacity -composite   shade_beveled.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shade_direction_135.gif"
     ><IMG SRC="shade_direction_135.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="shade_a_mask.gif"
     ><IMG SRC="shade_a_mask.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
 <A HREF="shade_beveled.png"
    ><IMG SRC="shade_beveled.png"
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Notice that about half the bevel generated by the "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator, actually falls
outside the masked area.  In other words, a straight bevel is halved when
masked. </P>

On the other hand the vertical or 'midday' shade image (using
'<CODE>90</CODE>' degree <I>elevation</I> angle) can be used to just extract
the beveled edge, leaving the center of the image hollow.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_direction_135.gif \
          \( shade_elevation_90.gif -normalize -negate \) \
          -alpha Off -compose CopyOpacity -composite   shade_beveled_edge.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shade_direction_135.gif"
     ><IMG SRC="shade_direction_135.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="shade_elevation_90.gif"
     ><IMG SRC="shade_elevation_90.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_beveled_edge.png"
     ><IMG SRC="shade_beveled_edge.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note however that the 'midday' shade image, while providing a way to mask the
location (and intensity) of the effects of the "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator does not actually
cover those effects completely. </P>

By combining the 'midday' shade image with the original mask you can increase
the size of that mask slightly to produce a better masked beveled image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_direction_135.gif \
          \( shade_elevation_90.gif -normalize -negate \
             shade_a_mask.gif -compose screen -composite \) \
          -alpha Off -compose CopyOpacity -composite   shade_beveled_plus.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="shade_beveled_plus.png"
     ><IMG SRC="shade_beveled_plus.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Remember with IM v6 you can generate the 'shade' image I generated previously
all in the same command.  As such the above could have been completely
generated from scratch.  For example.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 72 -background black -fill white \
          label:X  -trim +repage -bordercolor black -border 10x5 \
          \( -clone 0 -shade  135x45 \) \
          \( -clone 0 -shade  0x90  -normalize -negate \
             -clone 0 -compose screen -composite \) \
          -delete 0 -alpha Off -compose CopyOpacity -composite \
          shade_beveled_X.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="shade_beveled_X.png"
     ><IMG SRC="shade_beveled_X.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="shade_shape"></A>
<H3>Shaded Shape Images</H3>

The <A HREF="../masking/#alpha_extract" >Alpha Extract Operator</A> will not
only extract the alpha channel from a shaped images as a gray scale mask, but
also has the side effect of preserving the shape in the 'turned-off' alpha
channel. As it is 'turned off' it will not be touched by many image processing
operators, including "<CODE><A HREF="../option_link.cgi?shade"
>-shade</A></CODE>", preserving its detail.  </P>

What this means is that for shaped images, you can extract the shape, do the
work, then simply recover the transparency AFTER you have finished all the
image processing, simply by turning the <A HREF="../basics/#alpha_on" >Alpha
On</A> again! </P>

For example here I draw a 'Heart' on a transparent background, do some blurring
and shading of the image, then restore the original shaped outline of the
image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 -gravity center -background None \
          -font WebDings label:Y \
          -alpha Extract -blur 0x6 -shade 120x21 -alpha On \
          -normalize +level 15%  -fill Red -tint 100%    shade_heart.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="shade_heart.png"
     ><IMG SRC="shade_heart.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

All I can say is WOW, what a time saver! A lot simplier than the previous
command with all its extra processing and image cloning. </P>


<A NAME="shade_blur"></A>
<H3>Rounding Shade Edges</H3>

As you saw in the last example, by blurring the image shape mask, the 'slope'
of edge 'cliffs' will be smoothed out, as if worn down by time.  This produces
a nice rounded effect to the shade image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          shade_circle_mask.gif
  convert shade_circle_mask.gif            -shade 120x45  shade_blur_0.gif
  convert shade_circle_mask.gif -blur 0x1  -shade 120x45  shade_blur_1.gif
  convert shade_circle_mask.gif -blur 0x2  -shade 120x45  shade_blur_2.gif
  convert shade_circle_mask.gif -blur 0x3  -shade 120x45  shade_blur_3.gif
  convert shade_circle_mask.gif -blur 0x4  -shade 120x45  shade_blur_4.gif
  convert shade_circle_mask.gif -blur 0x5  -shade 120x45  shade_blur_5.gif
</CODE></PRE></TD></TR></TABLE><TR><TD>
  <A HREF="shade_circle_mask.gif"
     ><IMG SRC="shade_circle_mask.gif"      WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_blur_0.gif"
     ><IMG SRC="shade_blur_0.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_blur_1.gif"
     ><IMG SRC="shade_blur_1.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_blur_2.gif"
     ><IMG SRC="shade_blur_2.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_blur_3.gif"
     ><IMG SRC="shade_blur_3.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_blur_4.gif"
     ><IMG SRC="shade_blur_4.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shade_blur_5.gif"
     ><IMG SRC="shade_blur_5.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see blurring not only rounds-off the edges, but makes the lighting
effects dimmer.  You can maximize the contrast of the result by normalizing
the it, so as to bring the brightest and darkest points back to pure white and
black colors respectively.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_blur_3.gif   -normalize  shade_blur_3n.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shade_blur_3.gif"
     ><IMG SRC="shade_blur_3.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_blur_3n.gif"
     ><IMG SRC="shade_blur_3n.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The only draw back with this is that this also generally darkens the shaded
image.  This is something which we'll need to take into account in <A
HREF="#shade_overlay" >Creating Overlay Highlights</A>. </P>

Lets finish off this shade image by directly masking it as well..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shade_blur_3n.gif shade_circle_mask.gif \
          -alpha Off -compose CopyOpacity -composite   shade_blur_3n_mask.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shade_blur_3n.gif"
     ><IMG SRC="shade_blur_3n.gif"           WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_blur_3n_mask.png"
     ><IMG SRC="shade_blur_3n_mask.png"      WIDTH=50  HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see blurring the mask image will round off the edges of the
resulting shape very nicely.



<A NAME="shade_overlay"></A>
<H3>Creating Overlay Highlighting</H3>

The output from the "<CODE><A HREF="../option_link.cgi?shade"
>-shade</A></CODE>" operator is very nice, but it is rare that you actually
want a plain grey scale image of your shape.  What is needs is some color.
</P>

This however is not so easy as the two major ways of adding color, <A
HREF="../color_mods/#tint" >Color Tinting Mid-Tones</A> to just recolor a
grey-scale, or '<A HREF="../compose/#overlay" >Overlay</A>' alpha composition,
to replace the grey areas with an image, both rely on a special form of
grey-scale image.  That is a perfect mid-tone grey ('<CODE>grey50</CODE>') is
replaced by the color or image, while whiter or darker greys, whiten and
darken the color or image as appropriate. </P>

These special grey-scale 'overlay highlight' images with perfect mid-tone
greys for un-modified areas is not so straight forward to create using
"<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>".  However the
following are some of the more simpler ways I have discovered. </P>

Using a 30 degree elevation lighting angle with "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>", is one way of producing a
perfect mid-tone grey for flat areas of the shape being shaded. </P>

For example here I shade an image, then extract the top-left pixel to check
the resulting color of a 'flat' part of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=shade_30.txt>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          -blur 0x2  -shade 120x30           shade_30.png
  convert shade_30.png   -gravity center -crop 1x1+0+0 txt:-
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="shade_30.png"
     ><IMG SRC="shade_30.png"
           ALIGN=middle VSPACE=20 HSPACE=0 BORDER=0 ALT="[IM Image]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="shade_30.txt"
     ><IMG SRC="shade_30.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD></TR></TABLE></P>

Unfortunately  changing the rounding effect of the "<CODE><A
HREF="../option_link.cgi?blur" >-blur</A></CODE>" in the above command tends
to also vary the result highlight intensity of the shade image. That is using
a large blur not only produces a well rounded looking edge, but also made the
highlight so dim as to be near invisible. </P>

This means that you need to add lots more contrast to the output of the
"<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>" image produced,
to make the highlight effective as an overlay image. To fix this we need a way
remove this contrast effect from the rounding adjustment.  The typical way to
do this is to just  "<CODE><A HREF="../option_link.cgi?normalize"
>-normalize</A></CODE>" the image, but doing this to 30 degree shade image,
results in the 'flat' areas will no longer being a perfect grey.  For
example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=shade_30_norm.txt>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          -blur 0x2  -shade 120x30 -normalize   shade_30_norm.png
  convert shade_30_norm.png   -gravity center -crop 1x1+0+0 txt:-
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="shade_30_norm.png"
     ><IMG SRC="shade_30_norm.png"
           ALIGN=middle VSPACE=20 HSPACE=0 BORDER=0 ALT="[IM Image]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="shade_30_norm.txt"
     ><IMG SRC="shade_30_norm.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD></TR></TABLE></P>

After some further experimentation however I found that using a 21.78 degree
shade elevation angle, will after being normalized, produce the desired perfect
mid-tone grey level as well as a good strong highlighting effect.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=shade_21_norm.txt>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          -blur 0x2  -shade 120x21.78 -normalize   shade_21_norm.png
  convert shade_21_norm.png   -gravity center -crop 1x1+0+0 txt:-
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="shade_21_norm.png"
     ><IMG SRC="shade_21_norm.png"
           ALIGN=middle VSPACE=20 HSPACE=0 BORDER=0 ALT="[IM Image]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="shade_21_norm.txt"
     ><IMG SRC="shade_21_norm.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD></TR></TABLE></P>

As the shade image is now run though the "<CODE><A
HREF="../option_link.cgi?normalize" >-normalize</A></CODE>" operator, the
"<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>" value used for
'rounding edges' will no longer effect final intensity of the result.  A much
better method. </P>

In summery, <A HREF="../option_link.cgi?normalize" >normalizing</A> a shade
image will shift the mid-tones away from a perfect-grey color. </P>

Now we can adjust the output intensity of the highlights produces output
completely independent to the other adjustments.  Typically as the
normalized result is extreme, we will need a controlled de-normalization,
or anti-contrast control, to reduce the highlight to the desired level. </P>

The simplest method for adjusting the resulting highlight, is to <A
HREF="../color_mods/#tinting" >color tint</A> the image with a perfect grey.
This will shift all the color levels in the image toward the central pure
mid-tone grey color. </P>

For example...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          \( +clone -blur 0x2 -shade 120x21.78 -normalize  \) \
          +swap -alpha Off -compose CopyOpacity -composite  shade_tint_0.png
  convert shade_tint_0.png -fill grey50  -colorize 10%  shade_tint_10.png
  convert shade_tint_0.png -fill grey50  -colorize 30%  shade_tint_30.png
  convert shade_tint_0.png -fill grey50  -colorize 50%  shade_tint_50.png
  convert shade_tint_0.png -fill grey50  -colorize 80%  shade_tint_80.png
</CODE></PRE></TD></TR></TABLE><TR><TD>
  <A HREF="shade_tint_0.png"
     ><IMG SRC="shade_tint_0.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_tint_10.png"
     ><IMG SRC="shade_tint_10.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_tint_30.png"
     ><IMG SRC="shade_tint_30.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_tint_50.png"
     ><IMG SRC="shade_tint_50.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_tint_80.png"
     ><IMG SRC="shade_tint_80.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

An alternative to just linearly tinting the highlight, is to reduce its
general effect while preserving the extreme bright/dark spots of the highlight
by using <A HREF="../color_mods/#sigmoidal" >Sigmoidal Non-liner Contrast</A>
instead.  This should give a more 'natural' look to the highlight effect, and
can make the highlight brighter, as if the surface was more reflective.  </P>

However to make this technique more effective, we need make sure we do not
have pure white and black colors in the shade result.  This can be achieved by
first using a "<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>" of '<CODE>0%</CODE>' rather than "<CODE><A
HREF="../option_link.cgi?normalize" >-normalize</A></CODE>", and also
de-normalizing that result by a small amount, as we did above. </P>

This may seem to be just adding complexity to the generation of the
highlight overlay image, but emphasizing the bright spots in the highlight
makes the extra processing worth the effort. </P>

For example...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          \( +clone -blur 0x2 -shade 120x21.78 -contrast-stretch 0% \) \
          +swap -alpha Off -compose CopyOpacity -composite shade_sig_0.png

  convert shade_sig_0.png  -sigmoidal-contrast 10x50%  shade_sig-10.png
  convert shade_sig_0.png  -sigmoidal-contrast  5x50%  shade_sig-5.png
  convert shade_sig_0.png  -sigmoidal-contrast  2x50%  shade_sig-2.png

  convert shade_sig_0.png  +sigmoidal-contrast  2x50%  shade_sig+2.png
  convert shade_sig_0.png  +sigmoidal-contrast  5x50%  shade_sig+5.png
  convert shade_sig_0.png  +sigmoidal-contrast 10x50%  shade_sig+10.png
</CODE></PRE></TD></TR></TABLE><TR><TD>
  <A HREF="shade_sig-10.png"
     ><IMG SRC="shade_sig-10.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_sig-5.png"
     ><IMG SRC="shade_sig-5.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_sig-2.png"
     ><IMG SRC="shade_sig-2.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/left.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="<==">
  <A HREF="shade_sig_0.png"
     ><IMG SRC="shade_sig_0.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shade_sig+2.png"
     ><IMG SRC="shade_sig+2.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_sig+5.png"
     ><IMG SRC="shade_sig+5.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="shade_sig+10.png"
     ><IMG SRC="shade_sig+10.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see that the overall highlighting is reduced in intensity, but the
bright spot from reflected light remains as bright as ever, just reduced in
size. The result is a much more natural 'shiny' look to the shape. </P>

The only drawback with this technique is that a shadow 'spot' is also
generated though this is often not as noticeable. </P>

Finally we can combine the a 'highlight spot' with a general highlight
reduction to produce a highly configurable set of highlight overlay generator
controls...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x50 xc:black -fill white -draw 'circle 25,25 20,10' \
          \( +clone -blur 0x4 -shade 120x21.78 -contrast-stretch 0% \
             +sigmoidal-contrast 7x50% -fill grey50 -colorize 10%  \) \
          +swap -alpha Off -compose CopyOpacity -composite shade_overlay.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="shade_overlay.png"
     ><IMG SRC="shade_overlay.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<DL>
<DT>In summary, the above example has four separate controls...
<DD>"<CODE><A HREF="../option_link.cgi?blur"
    >blur</A></CODE>" :
    Rounding the shape edges (0.001=beveled  2=smoothed  10=rounded)
<DD>"<CODE><A HREF="../option_link.cgi?shade"
    >shade</A></CODE>" :
    The direction the light is coming from (120=top-left  60=top-right)
<DD>"<CODE><A HREF="../option_link.cgi?sigmoidal-contrast"
    >sigmoidal</A></CODE>" :
    surface reflective control highlight spots (1=flat 5=good 10=reflective )
<DD>"<CODE><A HREF="../option_link.cgi?colorize"
    >colorize</A></CODE>" :
    Overall contrast of the highlight ( 0%=bright  10%=good  50%=dim )
</DL></P>


Note while the above examples have been shaped to the original 'circle' shape,
the transparency should only be restored AFTER '<A HREF="../compose/#overlay"
>Overlay</A>' compositing has been applied, not before. </P>

Also if you plan to use a highlight repeatedly on the same shape (after any
rotation is performed), you can pre-generate the highlight overlay once for
each shape you plan to use, saving the result for multiple re-use. An example
of this re-use of shading overlay is with the generation of 3D DVD covers from
flat source images in the <A HREF="../forum_link.cgi?t=11726" >IM Discussion
Forums</A>. </P>

I also highly recommend you experiment with the above techniques, as they are
key to making your flat shaped images, much more realistic looking. If you
come up with other ideas for highlighting, please let me know. </P>

<PRE>
FUTURE:
   Color Tinting the Overlay image
   Overlay Alpha Composition with an Image
</PRE>


<A NAME="shade_highlight"></A>
<H3>Using a Dawn Shade Highlight</H3>

In <A HREF="#shade_mask" >Masking Shade Images</A> above we showed how useful
a 'mid-day' or 'high-noon' shade image (using an <I>elevation</I> of
'<CODE>90</CODE>'), can be useful for masking and location and extent of the
effects produced by "<CODE><A HREF="../option_link.cgi?shade"
>-shade</A></CODE>.  However the horizontal or 'dawn' shade images  (using an
<I>elevation</I> of '<CODE>0</CODE>')of a shape can also be quite useful as
well. </P>

It can for example be used as a mask for either white or black images to
generate separate highlight and shading effects on shapes.  This also can be
used ensure a shape gets roughly equal amounts of light and dark areas (or
even unequal amounts), as I produce them in seperatally but in a completely
controled way.  </P>

<PRE>FUTURE: more detail here</PRE>


See the first <A HREF="../advanced/#3d-logos" >Advanced 3D Logo</A> for an
example of using this technique. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="fx">
<H2>Using FX, The DIY Image Operator</H2>
</A>

The new IM version 6 image list operator "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" is a general DIY operator that does not fit into any specific
category of IM operators, as it can be used to create just about any image
operation.  Examples of its use are thought these pages, but here we will look
specifically at its capabilities and how you can use them. </P>

The command is so generic in its abilities, that it can,
<UL>
<LI>create canvases, gradients, mathematical colormaps.
<LI>move color values between images and channels.
<LI>adjust image colors in just about any way imaginable
<LI>translate, flip, mirror, rotate, scale, shear and generally distort images.
<LI>merge or composite multiple images together.
<LI>tile image(s) in weird and wonderful ways.
<LI>convolve or merge neighboring pixels together.
<LI>generate image metrics or 'fingerprints'
<LI>compare images in unusual ways.
</UL></P>

Of course many of these techniques are already part of IM, producing a faster
and more flexible result. But if it isn't built-in the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" allows you to generate your own
version of the desired operation. In fact I and others have often used it to
prototype new operations that are later built into IM's core library.
As an example see <A HREF="../bugs/ordered-dither/#diy" >DIY New Ordered Dither
Replacement</A> where I used "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" to develop a revised version of the <CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>"
operator. </P>

The operator is essentially allows you to perform free-form mathematical
operations on one or more images.  For the official summary of the command see
<A HREF="https://legacy.imagemagick.org/script/fx.php" >FX, The Special Effects
Image Operator</A> on the <A HREF="https://legacy.imagemagick.org/" >ImageMagick
Web Site</A>. </P>

<H3>FX Basic Usage</H3>

The command takes an image sequence of as many input images you like. Typically
one or two images, and replaces ALL the input images with a copy of the first
image, which has been modified by the results of the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" function. That is any meta-data
that is in the first image will be preserved in the result of the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator.</P>

For mathematical ease of use, all color values provided are normalized into
a 0.0 to 1.0 range of values. Results are also expected to be in this range.
</P>

This includes the transparency or alpha channel, which goes from 0.0 (meaning
fully transparent) to 1.0 (meaning fully opaque).  The values represent 'alpha
transparency' and is actually the negative of how IM normally stores the
transparency internally (as matte values). It is however more mathematically
correct and easier to use in this form. </P>

The "<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting
defines what channel(s) in the first (also called the 'zeroth' or
"<CODE>u</CODE>") image, is replaced with the result of the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator.  This is limited, by
default, to just the color channels ('<CODE>RGB</CODE>') of the original image.
Any existing transparency in that image will not be modified, unless the
"<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting is
changed, to include the alpha ('<CODE>A</CODE>') channel.  </P>

The expression is executed once for each pixel, as well an once for each color
channel in the pixel that is being processed. Also as the expression is
re-parsed each time it is executed, a complex expression could take some time
to process on a large image. </P>

For example, here we define a black image, but then set the blue channel
to be half-bright to form a 'navy blue' color instead.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  -size 64x64 xc:black -channel blue -fx '1/2' fx_navy.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_navy.gif"
     ><IMG SRC="fx_navy.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here we we take a black-white gradient, and then set the blue and green
channels to zero, so it becomes a black-red gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  -size 64x64 gradient:black-white \
           -channel blue,green    -fx '0'    fx_red.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_red.gif"
     ><IMG SRC="fx_red.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  To make the "<A HREF="../option_link.cgi?channel"
  ><CODE>-channel</CODE></A>" setting more like the "<A
  HREF="../option_link.cgi?fx" ><CODE>-fx</CODE></A>" operator, it will
  accept any combinations of the letters '<CODE>RGBA</CODE>' to specify the
  channels to which operators are to confine their actions. </P>

  This means that to limit the output of "<A HREF="../option_link.cgi?fx"
  ><CODE>-fx</CODE></A>" to just the blue and green channels you can now say
  "<CODE>-channel BG</CODE>" instead of the longer "<CODE>-channel
  blue,green</CODE>".

</I></FONT></TD></TR></TABLE></P>

We could have generated the above examples without using "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>", but being able to do this to an
existing image is what makes this a powerful image operator. </P>

The function can in fact read and use ANY pixel, or specific color from ANY of
the images already in the current image sequence in memory.  The first 'zero'
image, is given the special name of "<CODE>u</CODE>".  The second image
"<CODE>v</CODE>".  Other images in memory can be referenced by an index. As
such "<CODE>u[3]</CODE>" is the fourth image in the current image sequence,
while "<CODE>u[-1]</CODE>" is the last image in the sequence.  This is the
same indexing scheme used by the <A HREF="../basics/#list_ops" >Image List
Operators</A>, so you should be right at home.  </P>

If no other qualifiers are given, the color value used is same color used in
the image specified.  That is unless you specifically say you want to use the
red color, it will use the color value for the color channel the command is
processing at that time.  That is it will apply the expression for the blue
color value when it is processing the blue channel.  </P>

Unless told otherwise it will process each of the RGB color values (as set by
the default "<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>"
setting), for each and every pixel in the image.  That is 3*w*h calculations
which modifies all the values in the image by the expression given. </P>

For example here we take the IM built-in  "<CODE>rose:</CODE>" image and
multiply all pixel values by 50%.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:  -fx 'u*1.5'    fx_rose_brighten.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_rose_brighten.gif"
     ><IMG SRC="fx_rose_brighten.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In the above example, each of the individual red, green and blue values was
multiplied by 1.5.  If the resulting value is outside the 0 to 1 range it,
will be limited to the appropriate bound (1.0 in this case), unless you are
using a specially built <A HREF="https://legacy.imagemagick.org/script/high-dynamic-range.php" target="_blank">HDRI version of ImageMagick</A>. </P>

Lots of other "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" formulas
to recolor images are explored in <A HREF="../color_mods/#linear"
>Mathematical Color Adjustments</A> and <A HREF="../color_mods/#curves"
>Histogram Curves</A>.  </P>

As we can also reference any image in the current image sequence, as part of
the expression for modifing the first image, we can merge two, or even more
images, in just about any way we want. </P>

Here we generate a black-red-blue color chart image, by copying the blue
channel from a black-blue gradient (rotated), into the previous black-red
gradient we generated above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64 gradient:black-blue -rotate -90  fx_blue.gif
  convert fx_red.gif  fx_blue.gif \
          -channel B  -fx 'v'    fx_combine.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="fx_red.gif"
     ><IMG SRC="fx_red.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="fx_blue.gif"
     ><IMG SRC="fx_blue.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_combine.gif"
     ><IMG SRC="fx_combine.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Of course we could have just used a <A HREF="../compose/#copyblue"
  >Channel Coping Composition Method</A> instead which would be a lot faster.
  But that is not point. </P>

  Though the reverse is also true. Just about every IM image operation could
  be replaced by a FX equivelent function. </P>

</I></FONT></TD></TR></TABLE></P>

Now the second image in the above is only used as a source image. What really
happens is that "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" first
creates a copy of just the first image. It then modifies that image according
to the formula, using all the other images given. And finally it junks all the
input images replacing them with the modified copy of the first image. </P>

You can also calculate values based on each pixel location within the image.
values '<CODE>i,j</CODE>' is the current position of the pixel being
processed, while '<CODE>w,h</CODE>' gives the size of the image (the first
image unless a specific image qualifier is given).

For example here we generate a <A HREF="../canvas/#gradient_fx" >DIY
Gradient Image</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose: -channel G -fx 'sin(pi*i/w)' -separate   fx_sine_gradient.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_sine_gradient.gif"
     ><IMG SRC="fx_sine_gradient.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Or something more complex using both '<CODE>i,j</CODE>' position values.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 xc: -channel G -fx  'sin((i-w/2)*(j-h/2)/w)/2+.5'\
          -separate fx_2d_gradient.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_2d_gradient.gif"
     ><IMG SRC="fx_2d_gradient.gif"       WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

When generating gray-scale gradients, you can make the -fx operator work about
3 times faster, simply by asking it to only process one color channel, such as
the '<CODE>G</CODE>' or green channel in the above example.  This channel can
then be <A HREF="../color_basics/#separate" >Separated</A> to generate the
final gray-scale image.  This can represent a very large speed boost,
especially when using a very complex "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" formula. </P>

For more FX generated gradients, see examples <A HREF="../canvas/#gradient_fx"
>Roll your own Gradients</A>. </P>

<A NAME="fx_simple_distorts"></A>

You can use the position information to lookup specific pixels from the source
image using the '<CODE>p{x,y}</CODE>' syntax. </P>

For example you can easily make your own 'mirror image' type function (like
the "<CODE><A HREF="../option_link.cgi?flop" >-flop</A></CODE>" image
operator), that replaces each pixel, with the color values from the 'mirror'
position of the original source.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose: -fx  'p{w-i-1,j}'  fx_rose_mirror.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_rose_mirror.gif"
     ><IMG SRC="fx_rose_mirror.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This type of 'image distortion' was made more powerful by creating <A
HREF="../mapping/#distort" >Distortion Image Mapping</A>, or other types of
Value Lookup Tables, in the form of images. Examples of doing this has been
provided in <A HREF="../quantize/#diy_dither" >DIY Dither Patterns and
Threshold Maps</A>, where FX is used to replace specific colors with patterns
from other images. </P>

<A NAME="fx_resize"></A>

Now the size of the final image generated by an FX expression is the same as
the first image given, as such to generate a larger image, you will need to
set the first image to the size you want.  </P>

In this type of situation a second image (or even a third image) can be used
as a color source (hence the <A HREF="../basics/#swap" >Swap</A> in the next
example). </P>

For example here we resize rose image (using <A
HREF="../resize/#interpolative-resize" >Interpolated Scaling or Resize</A>) to
generate a larger image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:   -size 120x80 xc: +swap  \
           -fx 'v.p{  (i+.5)*v.w/w-.5, (j+.5)*v.h/h-.5  }' \
           fx_scaled.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_scaled.png"
     ><IMG SRC="fx_scaled.png"     WIDTH=120 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how the pixel lookup is performed, it may seem complex but it is the
proper way to scale (distort) an image.  Basically all the extra
'<CODE>0.5</CODE>' values added to the expression is needed to correctly
convert between <A HREF="../distorts/#control_coordinates" >Pixel
Coodinates</A> used for input coordinates '<CODE>i,j</CODE>' and location
lookup '<CODE>v.p{...}</CODE>, while the more mathematically correct <A
HREF="../distorts/#control_coordinates" >Image Coordinates</A> is needed for
the actual mathematical calculations (scaling). </P>

The above is actually the exact methodology used by any form of <A
HREF="../distorts/#distort" >Image Distortion</A>.  You can see this FX
equivelent for most distortions by turning on the <A
HREF="../distorts/#distort_verbose" >Verbose Distortion Summery</A>. This
reports a FX equivelent for most image distortions, as a way to double check
the distortion is doing what it is expected to do. </P>

The use of the <A HREF="#fx" >FX DIY Operator</A> to do image distortions,
shows just how powerful (though slow) this operator really is.  If it wasn't
for this operator I doubt may of the new operations, such as distortions,
sparse-color, or ordered dithers would have been added to the ImageMagick Core
Library.  </P>

Here is something a little simplier, swapping the red and blue channels of the
rose image.  See if you can figure how it works.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( +clone -channel R -fx B \) \
          +swap -channel B -fx v.R     fx_rb_swap.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_rb_swap.gif"
     ><IMG SRC="fx_rb_swap.gif"         WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  A faster and better way to do the same thing, is to use "<CODE><A
  HREF="../option_link.cgi?separate" >-separate</A></CODE>" and "<CODE><A
  HREF="../option_link.cgi?combine" >-combine</A></CODE>"). See <A
  HREF="../color_basics/#combine" >Combining RGB Channel Images</A>.
  Alternatively you can also use a "<CODE><A
  HREF="../option_link.cgi?color-matrix" >-color-matrix</A></CODE>" to do the
  same thing faster still.  </P>

  Do you see a trend here?
</I></FONT></TD></TR></TABLE></P>

As the default "<CODE><A HREF="../option_link.cgi?channel"
>-channel</A></CODE>" setting, it limits the output of the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator to just the three color
channels.  This means that if you want to effect the alpha or transparency
channel, you must explicitly specify it, by changing the channel setting. </P>

For example lets make a semi-transparent "<CODE>rose:</CODE>" image, by
setting all the alpha channel values to half.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose: -alpha set  -channel A  -fx '0.5'    fx_rose_trans.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_rose_trans.png"
     ><IMG SRC="fx_rose_trans.png"         WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the for the above to work properly I needed to ensure that the
"<CODE>rose:</CODE>" actually had an alpha channel for the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" to work with. I did this with
the <A HREF="../basics/#alpha" >Alpha Channel Control Operator</A>. </P>

This ability of the "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>"
operator to manipulate the RGBA channels of an image makes this operator
perfect for manipulating Channels and Masks. </P>

<BR>

As of IM 6.2.10 you can add variable assignments to "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" expressions, which allows you to
reduce the complexity of some expressions, that would basically be impossible
any other way. </P>

For example, here I create a gradient based on the distance from a particular
point (assigned to the variables '<CODE>xx</CODE>' and '<CODE>yy</CODE>').
Without the use of the variables this formula could have become very hard to
read.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:  -channel G \
          -fx 'xx=i-w/2; yy=j-h/2; rr=hypot(xx,yy); (.5-rr/70)*1.2+.5' \
          -separate  fx_radial_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_radial_gradient.png"
     ><IMG SRC="fx_radial_gradient.png"            WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Due the simple tokenization handling used by "<CODE><A
  HREF="../option_link.cgi?fx" >-fx</A></CODE>", variable names can only
  consist of letters, and must not contain numbers.  Also as a lot of single
  letters are used for internal variables accessing image information, it is
  recommended that variable names be at least two letters long.  As such I use
  '<CODE>xx</CODE>' and '<CODE>yy</CODE>' rather than just '<CODE>x</CODE>' or
  '<CODE>y</CODE>'.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" function
  'rr=<CODE>hypot(xx,yy)</CODE>' was added to IM v6.3.6 to speed up the very
  commonly used expression '<CODE>rr=sqrt(xx*xx+yy*yy)</CODE>'. </P>

  Of course if you need the distance squared, you should avoid the
  '<CODE>hypot()</CODE>' function, and the sqrt() function it implies.
</I></FONT></TD></TR></TABLE></P>

For more examples of some really complex expressions see <A
HREF="../canvas/#gradient_complex" >More Complex DIY Gradients</A>, which
would be impossible with out multiple statement assignments. The same is true
for <A HREF="../distorts/#perspective_internals" >FX form of Perspective
Distortion</A>.  </P>

As of IM version 6.3.0-1, the complexity of "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" expressions started to require
external files, so the standard '<CODE>@<I>filename</I></CODE>' can now be
used to read the expression from a file.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   echo "u*2" | convert rose:  -fx "@-"  fx_file.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_file.png"
     ><IMG SRC="fx_file.png"                WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This also means you can use more complex scripts to generate the specific FX
expressions for a particular job.  Internally the file is simply read into a
string and interpreted as usual.  </P>

Other settings that are important to "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" are "<CODE><A HREF="../option_link.cgi?virtual-pixel"
>-virtual-pixel</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?interpolate" >-interpolate</A></CODE>". </P>

The <A HREF="../misc/#virtual-pixel" >Virtual Pixel Setting</A> allows one to
set what colors or image results should be returned when the lookup
coordinates go outside the area covered by the input image. This allows one to
set edge effects for things like blurs, as well as tile image over a larger
area.  </P>

The <A HREF="../misc/#interpolate" >Interpolate Setting</A> allows one to
specify how IM should mix colors of neighbouring pixels when the lookup
coordinates (floating point values) fall between the integer coordinates of
the pixels in the input image.  For more information see <A
HREF="../distorts/#lookup" >Interpolated Pixel Lookup</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Some More functions were added at various times <BR>
  IM v6.3.6 :  hypot() <BR>
  IM v6.7.3-4 : while(), not(), guass(), squish() <BR>

</I></FONT></TD></TR></TABLE></P>


<H3>FX Debugging</H3>

The '<CODE>debug(<I>expr</I>)</CODE>' is essentially a way of printing a
floating point value, each time the FX expression is calculated.  This in turn
provides a method of debugging your expressions. </P>

However you can limit the output from the "<CODE>debug()</CODE>" by using a
tertiary if-else expression.  For example this will print the floating point
color values for pixel 10,10 from the built-in "<CODE>rose:</CODE>" image.
The actual image result is ignored by using the '<CODE><A HREF="../files/#null"
>NULL:</A></CODE>' image handler.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=fx_debug.txt>
  convert rose: -fx 'i==10&amp;&amp;j==10?debug(u):1; u' null:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_debug.txt"
     ><IMG SRC="fx_debug.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Remember the output is on standard error, not the normal standard output, that
way you can use this in a command pipeline, without problems. </P>

Note how the FX expression was executed three times, once for each channel
for just that one pixel. Multiply that by the number of pixels, and you can
imagine the length of the output if "<CODE>debug()</CODE>" was not limited to
just one pixel, even for this small image. </P>


<A NAME="fx_builtins"></A>
<H3>FX-like Built-in Operations</H3>

Well "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" operations is
slow, very slow when processing large images with very complex expressions.
However it represents a way to develop new image processing functions that
previously did not exist in ImageMagick.  The result of such development by
users has allows ImageMagick to expand, with new functions and methods, such
as  the <A HREF="../color_mods/#clut" >Color Lookup Table</A> ("<CODE><A
HREF="../option_link.cgi?clut" >-clut</A></CODE>"). </P>

Generally however once a new method has stabilized using "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>", the expression is converted
into a faster built-in operation, usually added as part of a group of similar
operators. </P>

These include the follow general image operator and there methods...

<TABLE BORDER=0 ALIGN=center>
<TR VALIGN=top><TD><A HREF="../option_link.cgi?evaluate" >-evaluate</A>
<TD>Direct pixel, color values, channel modification functions.
<BR>(See <A HREF="#evaluate" >Evaluate</A> below).

<TR VALIGN=top><TD><A HREF="../option_link.cgi?evaluate" >-function</A>
<TD>More Complex pixel, color value, channel modification functions.
<BR>(See <A HREF="#function" >Function</A> below).

<TR VALIGN=top><TD><A HREF="../option_link.cgi?evaluate-sequence"
    >-evaluate-sequence</A>
<TD>Merge a multi-image sequence of images mathematically
<BR>(See <A HREF="#evaluate-sequence" >Evaluate-Sequence</A> below).

<TR VALIGN=top><TD><A HREF="../option_link.cgi?sparse-color" >-sparse-color</A>
<TD>General Image Re-Coloring Operator.
<BR>(See <A HREF="../canvas/#sparse-color" >Sparse Color Gradients</A> )

<TR VALIGN=top><TD><A HREF="../option_link.cgi?compose" >-compose</A>
<TD>General Multi-Image combining and overlaying method.
<BR>(See <A HREF="../compose/#compose" >Alpha Composition</A>).

<TR VALIGN=top><TD><A HREF="../option_link.cgi?distort" >-distort</A>
<TD>General Image Distortion operator, using reversed pixel mapping.
<BR>(See the <A HREF="../distorts/#distort" >Distort Operator</A> )

<TR VALIGN=top><TD><A HREF="../option_link.cgi?distort" >-morphology</A>
<TD>General Area Effect Convolution/Morphology function.
<BR>(See the <A HREF="../morphology/#morphology" >Morphology Operator</A>
    and the <A HREF="../convolve/#convolve" >Convolve Operator</A> )
</TABLE></P>

As people developed new types of image operations, they usually prototype it
using a slow "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator
first.  When they have it worked out that 'method' is then converted into a
new fast built-in operator in the ImageMagick Core library.

Users are welcome to contribute their own "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" expressions (or other defined
functions) that they feel would be an useful addition to IM, but which are not
yet covered by other image operators, if they can be handled by one of the
above generalized operators, it should be reasonably easy to add it. </P>

For example I myself needed a 'mask if color similar' type operation for
comparing two images.  This has been added as a new "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" method "<CODE><A
HREF="../compose/#changemask" >ChangeMask</A></CODE>". This in turn allowed me
to then add a more complex <A HREF="../anim_opt/#opt_trans" >Transparency
Optimization</A> for GIF animations. </P>

What is really needed at this time is a FX expression compiler, that will
pre-interpret the expression into a tighter and faster executable form.
Someone was going to look into this but has since disappeared. </P>

However if speed and complexity is starting to become a problem then it is
probably better to move on to an API scripting language such as PerlMagick.  An
example of this using PerlMagick "<CODE><A
HREF="https://www.imagemagick.org/subversion/ImageMagick/trunk/PerlMagick/demo/"
>pixel_fx.pl</A></CODE>" is part of that API's distribution.  </P>

<BR>

<A NAME="fx_escapes"></A>
<H3>FX Expressions as Format and Annotate Escapes</H3>

As of IM version 6.2.10 you can now use  <A
HREF="https://legacy.imagemagick.org/script/fx.php" >FX Expressions</A> within <A
HREF="https://legacy.imagemagick.org/script/escape.php" >Image Property
Escaped</A> strings such as used by "<CODE><A HREF="../option_link.cgi?format"
>-format</A></CODE>" and "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>" arguments.  </P>

The escape sequence '<CODE>%[fx:...]</CODE>' is replaced by a number as
a floating point value, calculated once for each image in the current image
sequence. </P>

The <A HREF="https://legacy.imagemagick.org/script/fx.php" >FX Expression</A>
however is modified slightly during processing.  Specifically... </P>

<UL>
<LI>The current pixel coordinates '<CODE>i</CODE>', '<CODE>j</CODE>' is fixed
    to the value 0, so on its own an image variable only returns the value
    from pixel 0,0, unless a '<CODE>p{}</CODE>' index is used.
<LI>Unless a color channel is selected only the red channel value is returned.
<LI>The default image reference '<CODE>s</CODE>' is set to current image,
    being annotated or identified.
<LI>The index '<CODE>t</CODE>' returns the index of the image referred to
    by '<CODE>s</CODE>'.
</UL>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.8-6 both FX expression values of "<CODE>t</CODE>" image index
  and "<CODE>n</CODE>" total number of images, were broken, and only returned
  a value of 0 and 1 respectively for ALL images.  The same goes for the
  equivalent percent escapes '<CODE>%p</CODE>' and '<CODE>%n</CODE>'.
</I></FONT></TD></TR></TABLE></P>

For example here I "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>" each image with the color of the top left corner of
each image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 150x25 xc:DarkRed xc:Green xc:Blue \
          -fill white -gravity center \
          -annotate 0 '%[fx:t] / %[fx:n] : %[fx:r],%[fx:g],%[fx:b]' \
          annotate_fx_%d.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="annotate_fx_0.gif"
     ><IMG SRC="annotate_fx_0.gif"      WIDTH=150 HEIGHT=25
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="annotate_fx_1.gif"
     ><IMG SRC="annotate_fx_1.gif"      WIDTH=150 HEIGHT=25
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="annotate_fx_2.gif"
     ><IMG SRC="annotate_fx_2.gif"      WIDTH=150 HEIGHT=25
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice how the text that is written is different for each image, as
'<CODE>r</CODE>' is actually equivalent to '<CODE>s.p{0,0}.r</CODE>'.  The
same goes for the '<CODE>g</CODE>' and '<CODE>b</CODE>' color channel values.
Of course each one returns a normalized value in the range of 0.0 to 1.0. </P>

To make the output of specific pixel color values easier,
a '<CODE>%[pixel:...]</CODE>' escape was also added in IM v6.3.0.   This
operator calls the given FX expression once for each channel in each image,
and formats the returned value into a color that IM can handle as a color
argument.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=800% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 300x100 gradient:yellow-limegreen \
          -gravity NorthWest  -annotate 0 '%[pixel:s.p{0,0}]' \
          -gravity Center     -annotate 0 '%[pixel:s.p{0,50}]' \
          -gravity SouthEast  -annotate 0 '%[pixel:s.p{0,99}]' \
          annotate_pixel.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="annotate_pixel.gif"
     ><IMG SRC="annotate_pixel.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You can just output the result directly using a "<CODE><A
HREF="../option_link.cgi?format" >-format</A></CODE>" with the "<CODE><A
HREF="../basics/#identify" >identify</A></CODE>" command.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=fx_math.txt>
  identify -format '%[fx:atan(1)*4]' null:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_math.txt"
     ><IMG SRC="fx_math.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This will mathematically calculate and return the value of <I>PI</I>, though
this value is available as the built-in variable '<CODE>pi</CODE>'. </P>

You can generate random numbers.  For example to generate an integer
between -5 and 10 inclusive.  Here I use the "<CODE><A HREF="../files/#info:"
>info:</A></CODE>" equivalent to the "<CODE>identify</CODE>" command.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM OUT=fx_rand.txt>
  convert xc: -format '%[fx:int(rand()*16)-5]' info:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_rand.txt"
     ><IMG SRC="fx_rand.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For more methods see <A HREF="../basics/#identify_alt" >Identify Alternatives:
Text Output Options</A>. </P>

Also see <A HREF="../thumbnails/#rounded_border" >Border with Rounded
Corner</A> which used a <A HREF="https://legacy.imagemagick.org/script/fx.php" >FX
Expressions</A> to generate a draw string based on image width and height
information.  </P>

You can <A HREF="../layers/#layer_calc" >Calculate Positions Images using FX
formulas</A> or even position using the size and location of other images (See
<A HREF="../layers/#layer_calc_inc" >Incrementally Calculated Positions</A>).
</P>

You can also use <A HREF="#fx_escapes" >FX Escapes</A> in <A
HREF="../files/#save_escapes" >Filename Percent Escapes</A> to generate new
files based on calculated values.  For an example, see the final example in
<A HREF="../crop/#crop_tile" >Tile Cropping</A>. </P>

<BR>

<A NAME="fx_print"></A>

All the above will essentially run the "<CODE><A
HREF="../option_link.cgi?format" >-format</A></CODE>" and thus any containing
<A HREF="https://legacy.imagemagick.org/script/fx.php" >FX Expression</A> one for
each image in the current image sequence. </P>

The "<CODE><A HREF="../option_link.cgi?print" >-print</A></CODE>" operator will
work much like "<CODE><A HREF="../option_link.cgi?identify"
>-identify</A></CODE>" except that it is only run once, with access to ALL the
images in the current image sequence. With this operator you can use
'<CODE>u[{i}]</CODE>' to access values from any image, unlike the above. </P>

<BR>

Fx Expressions can be applied to images in other colorspaces, so I can for
example find out the 'Hue' value (in the 'red' channel) for three different
colors.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=fx_hues.txt>
  convert xc:red xc:green xc:blue -colorspace HSL \
          -format '%[fx: s.r ]\n' info:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_hues.txt"
     ><IMG SRC="fx_hues.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also use IM for some direct color maths, such as find out the average
color of '<CODE>gold</CODE>', '<CODE>yellow</CODE>', and '<CODE>khaki</CODE>'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=pixel_math.txt>
  convert xc: -format '%[pixel:(gold+yellow+khaki)/3]' info:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pixel_math.txt"
     ><IMG SRC="pixel_math.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

While this shows what the color looks like compared to the three source
colors...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc:gold xc:yellow xc:khaki +append \
          \( xc: -fx '(gold+yellow+khaki)/3' \) \
          -scale 90x30\! -append fx_hues.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_hues.png"
     ><IMG SRC="fx_hues.png"   WIDTH=90  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also use "<CODE><A HREF="../option_link.cgi?print" >-print</A></CODE>"
to print information. This is applied only once against the whole image
sequence.  That means you can use this operator to calculate much more complex
'<CODE>%[fx:...]</CODE>' expressions involving multiple images.  </P>

<A NAME="fx_other"></A>
<H4>Accessing data from other images</H4>

There is one serious problem with using FX escaped expressions however.  IM
does not have direct access to the other images in the current image sequence
when you are creating images. This is just generally not needed, in typical
image creation, as new images generally do not depend on previous in-memory
images. </P>

Basically if you want to gather the color of a specific pixel in a different
image to the one you are drawing on (as above), or are creating a new image,
then the IM core functions have no direct link to the desired info. </P>

For example if you try to create a label with the color of the built-in
"<CODE>rose:</CODE>" image pixel 12,26  (a bluish pixel), the direct approach
will fail!

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: label:'%[pixel:p{12,26}]' -delete 0 label_fx_direct.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="label_fx_direct.gif"
     ><IMG SRC="label_fx_direct.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Well the rose image does not actually contain any black pixels, so the above
result was wrong. </P>

The way to fix this is to extract the wanted information and save it into the
global IM meta-data.  This is passed to all sub-routines in the library core,
including those for image creation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -set option:mylabel '%[pixel:u.p{12,26}]' -delete 0 \
          label:'%[mylabel]'    label_fx_indirect.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="label_fx_indirect.gif"
     ><IMG SRC="label_fx_indirect.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is not intuitive but we now get the correct result. </P>

The special '<CODE>option:</CODE>' tag, tells the "<CODE><A
HREF="../option_link.cgi?set" >-set</A></CODE>" option that you want the given
setting saved as a global <A HREf="../basics/#define" >Artifact</A>, rather
than as an image 'Attribute' or 'Properties' string, just as "<CODE><A
HREF="../option_link.cgi?define" >-define</A></CODE>" can.  However the
"<CODE><A HREF="../option_link.cgi?set" >-set</A></CODE>" form allows you to
expand <A HREF="../basics/#arg_percent" >Percent Escapes</A> in setting the <A
HREF="../basics/#define" >Artifact</A>, where as "<CODE><A
HREF="../option_link.cgi?define" >-define</A></CODE>" does not. </P>

When the "<CODE>label:</CODE>" operator expands its percent escapes, the given
'key' is looked for first as a per image 'attribute' or 'proprieties', but if
it fails to find anything, it will then look for the 'key' in the global <A
HREF="../basics/#define" >Artifact</A> settings.  As such the global
'artifact' we created from the previous image is used, even though that image
is no longer present at the time the <A HREF="../basics/#define" >Artifact</A>
was created. </P>

Basically 'Artifact' settings are global during the life time of the
"<CODE>convert</CODE>" command, and thus can be used to pass information
from one image to another.  </P>

For programmed API's this situation can be avoided as you can read the
required data directly from the image and generate the label string yourself,
without needing IM to store that information in such a convoluted way. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="evaluate"></A>
<H2>Evaluate and Function,  Freeform Channel Modifiers</H2>

Because the <A HREF="#fx" >FX Operator</A> (see above) is so slow, the
"<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>" operator
was added to let you make simple image modifications more quickly. </P>

Later a more complex "<CODE><A HREF="../option_link.cgi?function"
>-function</A></CODE>" operator was added in IM v6.4.8-8, to allow greater
flexibility in complex image adjustments.

These two operators, along with other <A HREF="../color_mods/#levels" >Image
Level Adjustment Operators</A> such as "<CODE><A
HREF="../option_link.cgi?negate" >-negate</A></CODE>", "<CODE><A
HREF="../option_link.cgi?level" >-level</A></CODE>", will probably be most
useful for minor tweaks to grey-scale images, before you apply those images.
</P>

Especially in gray-scale images such as used for <A
HREF="../masking/#bg_removal" >Background Removal</A>, <A
HREF="../transform/#shade_overlay" >Highlight and Shadow Overlays</A>, and the
generation and fine-tuning of <A HREF="../mapping/" >Image Maps</A>. </P>


<H3>Evaluate, Simple Math Operations</H3>

The "<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>"
operator is basically a fast, but very simple version of "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator (actually pre-dates its
addition to IM by just a couple of months).  However it is limited to just one
simple operation, using a single user provided constant number. </P>

You can find out what functions have been built into evaluate using

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -list evaluate
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

This includes the typical mathematical functions  '<CODE>add</CODE>',
'<CODE>subtract</CODE>', '<CODE>multiply</CODE>', and '<CODE>divide</CODE>'.
against constant values.  </P>

Unlike the <CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE> operator the
values are not normalised to a 0 to 1 range, but remain the real color values
of the image. As such subtracting a value of 50 in a Q8 IM (See <A
HREF="../basics/#quality" >Quality and Depth</A> will result in a large
subtraction, but for a Q16 version of IM, it will only be a small hardly
noticeable change. </P>

However if you add a '%' to the argument, that argument will represent a
percentage of the maximum color value (known as '<CODE>QuantumRange</CODE>'
which is equal to ('<CODE>2<SUP><I>quality</I></SUP>-1</CODE>').   This means
you can make your "<CODE><A HREF="../option_link.cgi?evaluate"
>-evaluate</A></CODE>" arguments IM quality level independent, by the
appropriate use of percentages for the appropriate evaluate methods.  </P>

<A NAME="evaluate_set"></A> For example to just simply replace all color
values in an image to a 50% gray level is very simple and very fast, using
'<B><CODE>Set</CODE></B>'

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -evaluate set 50%  rose_set_gray.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_set_gray.gif"
     ><IMG SRC="rose_set_gray.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The "<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>"
operator also includes the typical mathematical functions '<CODE>add</CODE>',
'<CODE>subtract</CODE>', '<CODE>multiply</CODE>', and '<CODE>divide</CODE>'.
</P>

<A NAME="evaluate_divide"></A>
<A NAME="evaluate_add"></A>

For example, to half the contrast of the image, you can
'<B><CODE>divide</CODE></B>' it by '<CODE>2</CODE>' then
'<B><CODE>add</CODE></B>' '<CODE>25%</CODE> to re-center it around a the
perfect grey. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -evaluate divide 2 -evaluate add 25%  rose_de-constrast.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_de-constrast.gif"
     ><IMG SRC="rose_de-constrast.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is a couple of orders of magnitude faster than directly using the
"<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator with
'<CODE>u/2+.25</CODE>'.  As such you should use this operator in preference to
"<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" if at all possible.
</P>

The <I>major</I> problem with "<CODE><A HREF="../option_link.cgi?evaluate"
>-evaluate</A></CODE>" is that all results are clipped to the 0 to
'<CODE>QuantumRange</CODE>' limits (unless you are using a <A
HREF="../basics/#hdri" >HDRI version of ImageMagick</A>), as each modified
value is saved back into the image data.  That means that after any individual
"<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>" operation,
the values could be clipped by the '<CODE>QuantumRange</CODE>'. </P>

<A NAME="evaluate_multiply"></A>

As such if you try to apply a contrast enhancement function (equivalent to
"<CODE><A HREF="../option_link.cgi?fx" >-fx</A> '2*u-.25' </CODE>") directly
as it stands, you will fail to get the correct results, as the doubled value
will be clipped, before the subtraction is made.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -evaluate multiply 2  -evaluate subtract 25% \
          rose_contrast.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_contrast.gif"
     ><IMG SRC="rose_contrast.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

First the '<B><CODE>multiply</CODE></B>' will clip all the large color values
to the maximum value, then the '<CODE>subtract</CODE>' will clip the lower
bound values. the result is an incorrect clipping of the upper bounds,
producing a dark and color distorted result. </P>

<A NAME="evaluate_subtract"></A>

The direct solution is to '<B><CODE>subtract</CODE></B>' the appropriate
constant first (doing the final but correct clip of the lower bounds), before
multiplying, effectively using the equivalent formula
'<CODE>(u-.125)*2</CODE>'

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -evaluate subtract 12.5%  -evaluate multiply 2 \
          rose_contrast2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_contrast2.gif"
     ><IMG SRC="rose_contrast2.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However there are lots of alternatives to this 'clipping' problem.  The first
logical one being the newer <A HREF="#function_polynomial" >Polynomial
Function Method</A> (see below). Other alternatives also include using <A
HREF="../color_mods/#level" >Level Adjustment Operators</A> or even a <A
HREF="../color_mods/#level-colors" >Level Adjustment by Color</A>, to simply
specify the original color values that you want to stretch out, to fill whole
color range. </P>

Basically be careful with regards to color value clipping when using multiple
"<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>" methods.
</P>

<BR>

The "<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>"
operator, like "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" (and
most other low level IM operators) is "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" effected.  This allows
you to control an images alpha transparency separately to the color channels.
</P>

And yes, like "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>",
transparency is treated as 'alpha values' and not a 'matte' value. </P>

For example to make an image 50% transparent, as part of a <A
HREF="../compose/#dissolve" >Dissolve</A> type operation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -alpha set  -channel A -evaluate divide 2   rose_transparent.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_transparent.png"
     ><IMG SRC="rose_transparent.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
The result is a semi-transparent image, which means when displayed, half the
color you see is the web-pages background color. As such the image shown is
dimmed toward the background color. </P>

Often I have also found that it is often easier to use "<CODE><A
HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>" on the individual
color channels before separating the various channels into separate images for
specific purposes,  (See <A HREF="../color_basics/#separate" >Separating
Channels</A>).  </P>

For example here I use it to do a fast, but unusual form of gray-scaling.
Basically I multiply each channel by the appropriate amount, then separate and
add the channels together to produce an image that has been gray-scaled using
a specific set of color ratios.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -channel R  -evaluate multiply .2 \
                -channel G  -evaluate multiply .5 \
                -channel B  -evaluate multiply .3 \
                +channel -separate \
                -background black -compose plus -flatten grey_253.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="grey_253.png"
     ><IMG SRC="grey_253.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="evaluate_math"></A>
<H3>Evaluate Math Functions</H3>

Included in Evaluate, there are also a set of special purpose mathematical
functions. </P>

These functions are implemented to generally use a normalized color value (0
to 1 range) with the output again normalized so as to fit the full color range
of the image.   The <A HREF="../color_mods/#sigmoidal" >Sigmoidal
Contrast</A> function is also an example of this math function fitting. </P>

<A NAME="evaluate_pow"></A>
<H4>Power Of</H4>

The '<B><CODE>Pow</CODE></B>' function (added IM v6.4.1-9) for example works
with normalized color values, and allows users to do image brightness
modifications. </P>

It is exactly equivalent to the pow() C function, (using normalize color
values in a 0 - 1 range)

<PRE>    value = pow(value, constant) </PRE>

As such to create a 'parabolic' gradient you can use an argument of
'<CODE>2</CODE>'.  Or use a value of '<CODE>0.5</CODE>' to create a 'square
root' gradient.  For example... </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 20x600  gradient: -rotate 90  gradient.png
  convert gradient.png  -evaluate Pow  2   eval_pow_parabola.png
  convert gradient.png  -evaluate Pow 0.5  eval_pow_sq_root.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient.png"
     ><IMG SRC="gradient.png"      WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="eval_pow_parabola.png"
     ><IMG SRC="eval_pow_parabola.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="eval_pow_sq_root.png"
     ><IMG SRC="eval_pow_sq_root.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
<!-- <CODE EXECUTE>
  im_profile -s gradient.png  gradient_pf.gif
  im_profile -s eval_pow_parabola.png  eval_pow_parabola_pf.gif
  im_profile -s eval_pow_sq_root.png  eval_pow_sq_root_pf.gif
</CODE> -->
  <A HREF="gradient_pf.gif"
     ><IMG SRC="gradient_pf.gif"      WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="eval_pow_parabola_pf.gif"
     ><IMG SRC="eval_pow_parabola_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="eval_pow_sq_root_pf.gif"
     ><IMG SRC="eval_pow_sq_root_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The three lower images show the profile of the gradient produced both a
  graph and the original image itself.  This makes it easier to see how one
  gradient image was modified to become another.  It was generated using the
  <A HREF="http://www.gnuplot.info/" >Gnuplot</A> graph ploting program, via
  the script "<CODE><A HREF="../scripts/im_profile" >im_profile</A></CODE>" in
  the IM Examples, <A HREF="../scripts/" >Scripts</A> directory.
</I></FONT></TD></TR></TABLE></P>


This is actually equivalent to the <A HREF="../color_mods/#gamma" >Gamma
Adjustment</A> operator but with the argument inverted.  For example
a "<CODE>-gamma 2</CODE>" operation would be equivalent to an "<CODE>-evaluate
pow 0.5</CODE>" or a 'square root' operation function.  Similarly
"<CODE>-gamma 0.5</CODE>" is equivelent to squaring using "<CODE>-evaluate pow
2</CODE>"</P>

By doing some special gradient manipulations, you can use this method to
convert a linear gradient into a complex circular arc.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 20x300  gradient: -rotate 90 \
          -evaluate Pow 2 -negate -evaluate Pow 0.5 \
          -flop \( +clone -flop \) +append  eval_circle_arc.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="eval_circle_arc.png"
     ><IMG SRC="eval_circle_arc.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s eval_circle_arc.png eval_circle_arc_pf.gif
</CODE> -->
  <A HREF="eval_circle_arc_pf.gif"
     ><IMG SRC="eval_circle_arc_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For those wanting to figure this out, the second line in the above is
equivelent to the <A HREF="#fx" >FX expression</A> '<CODE>sqrt(1-u^2)</CODE>'.
This generates a single quarter circle arc, which is then <A
HREF="../warping/#flop" >Flopped</A>, and <A HREF="../layers/#append"
>Appended</A> together, to produce a half circular arc.  </P>

It is also a lot faster than using an <A HREF="#fx" >FX expression</A>, even
though it requires many more individual (smaller) steps. </P>

See also the more advanced <A HREF="#function_polynomial" >Polynomial
Function</A>. </P>


<A NAME="evaluate_log"></A>
<H4>Logrithmic</H4>

The '<B><CODE>Log</CODE></B>' function (added IM v6.4.2-1) also works with
normalized values (with a 1.0 added to avoid infinities), with the given
constant being used as the logarithmic base.  The actual formula (with
normalized values) is thus...

<PRE>    value = log(value*constant+1.0)/log(constant+1.0) </PRE>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -evaluate Log 10  eval_log.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="eval_log.png"
     ><IMG SRC="eval_log.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s eval_log.png eval_log_pf.gif
</CODE> -->
  <A HREF="eval_log_pf.gif"
     ><IMG SRC="eval_log_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This may seem very simular to the previous <A HREF="#evaluate_pow" >Pow
Evaluate Method</A>, but it isn't quite the same.  '<CODE>Log</CODE>' will
produce an appreciable slope as it approaches '<CODE>0</CODE>', where
'<CODE>Pow</CODE>' will produce a vertial slope. The value controls the slope.
</P>

A logrithmic function is also closely related to an exponential function, which
is currently only implemented as <A HREF="../color_mods/#sigmoidal-contrast"
>Sigmoidal Contrast Adjustment</A> operator.  This contains the same slope
features you can see in the above logrithmic curves.  This explains why
"<CODE><A HREF="../option_link.cgi?sigmoidal-contrast"
>-sigmoidal-contrast</A></CODE>" is a better technique for enhancing images
involving low light conditions, than a <A HREF="../color_mods/#gamma" >Gamma
Adjustment</A> or 'power of' curve. </P>


<A NAME="evaluate_sin"></A>
<A NAME="evaluate_cos"></A>
<H4>Sine and Cosine</H4>

As of IM v6.4.8-8 the '<B><CODE>sin</CODE></B>' and '<B><CODE>cos</CODE></B>'
methods were added.   These methods take the value given in the image and
normalize it into an angle so the full range will cover a full circle of
angles.  The result is given a 50% bias and scaled to again fit into the
normal range of values.  The constant is used as a multiplier for the value
(and thus the angle) so that 'N' means the function will go around the circle
'N' times over the full value range. </P>

Specifically it defines these function (using normalized values) as...

<PRE>   value = 0.5 * sin( constant*value*2*PI ) + 0.5
   value = 0.5 * cos( constant*value*2*PI ) + 0.5 </PRE>

In essence what these functions do is re-map the image values (usually
gray-scale values) into a sine/cosine curve. </P>

For example here I take a gradient image and modify it using these evaluate
methods.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png  -evaluate sin 1  eval_sin_1.png
  convert gradient.png  -evaluate cos 1  eval_cos_1.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="eval_sin_1.png"
     ><IMG SRC="eval_sin_1.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="eval_cos_1.png"
     ><IMG SRC="eval_cos_1.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
<!-- <CODE EXECUTE>
  im_profile -s eval_sin_1.png  eval_sin_1_pf.gif
  im_profile -s eval_cos_1.png  eval_cos_1_pf.gif
</CODE> -->
  <A HREF="gradient_pf.gif"
     ><IMG SRC="gradient_pf.gif"      WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="eval_sin_1_pf.gif"
     ><IMG SRC="eval_sin_1_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="eval_cos_1_pf.gif"
     ><IMG SRC="eval_cos_1_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


Now as the constant parameter is an angle multiplier, the value given to the
evaluate method will create that many peaks over the whole gradient within an
image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -evaluate cos 5  -negate  eval_cos_5.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="eval_cos_5.png"
     ><IMG SRC="eval_cos_5.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s eval_cos_5.png eval_cos_5_pf.gif
</CODE> -->
  <A HREF="eval_cos_5_pf.gif"
     ><IMG SRC="eval_cos_5_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is perfect for many tasks, from generating ripple or dispersion effects
to generate ripple looking displacement curves. </P>

By using a multiplier constant of '0.5' you can simply convert a linear
gradient into a sine curve gradient, which still has the same slope as the
original.  By negating the result you can ensure that the gradient also slopes
correctly.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -evaluate cos 0.5  -negate  eval_cos.5.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="eval_cos.5.png"
     ><IMG SRC="eval_cos.5.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s eval_cos.5.png eval_cos.5_pf.gif
</CODE> -->
  <A HREF="eval_cos.5_pf.gif"
     ><IMG SRC="eval_cos.5_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Which is great generating smooth gradients for use in overlapping photos. </P>

However these last two "<CODE><A HREF="../option_link.cgi?evaluate"
>-evaluate</A></CODE>" methods are rarely used as they have been superseded by
a more general <A HREF="#function_sinusoid" >Sinusoid Function</A> (see below)
that provide more control options, beyond that of a simple frequency option.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="function"></A>
<H2>Function, Multi-Argument Evaluate</H2>

The above wave generators proved to be extremely useful, especially with <A
HREF="../mapping/#distort" >Distortion Image Mapping</A>. But it was found
that a much finer control of the functions was needed, requiring more than one
parameter. </P>

Because of this the "<CODE><A HREF="../option_link.cgi?function"
>-function</A></CODE>" operator was added in IM v6.4.8-9. </P>

Basically "<CODE><A HREF="../option_link.cgi?function" >-function</A></CODE>"
is a multi-argument form of "<CODE><A HREF="../option_link.cgi?evaluate"
>-evaluate</A></CODE>". However unlike the <A HREF="#evaluate" >Evaluate
Operator</A>, these operators like the mathematical operators, all the
functions above work only on normalised channel values (0.0 to 1.0 range) of
the image, which in most cases makes them easier to use.  </P>


<A NAME="function_polynomial"></A>
<H4>Polynomial Function</H4>

The '<B><CODE>polynomial</CODE></B>' method will take any number of values,
and will modify the color values in an image according the exact expression
given, much faster than the <A HREF="#fx" >FX Operator</A> can. </P>

<DIV ALIGN=center>
<PRE>-function   Polynomial   a,b,c,...</PRE>
</DIV>

Each value will be used as a coefficient from the highest order to the lowest,
to produce a polynomial with the number of terms given. </P>

For example an argument of  '<CODE>4,-4,1</CODE>' will generate the polynomial
expression equivalent to the "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" expression "<CODE> 4*u^2 - 4*u + 1 </CODE>". </P>

If you know your high school maths you should know then that this polynomial
function produces a parabolic curve going from 1.0 to 0.0 then back to 1.0,
over the input ('<CODE>u</CODE>') color range 0.0 to 1.0.   That is it will
make, black and white colors 'white', and make perfect grays, 'black'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Polynomial 4,-4,1  func_parabola.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_parabola.png"
     ><IMG SRC="func_parabola.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_parabola.png func_parabola_pf.gif
</CODE> -->
  <A HREF="func_parabola_pf.gif"
     ><IMG SRC="func_parabola_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can even make a much more complex gradient, for example a quartic
polynomial, which was the result of generating a <A
HREF="../color_mods/#curves" >Curve Level Adjustment</A>, using a set of
'level control points'.  This is typically used to adjust the colors of an
image to give it various shading effects.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Polynomial '-25, 53, -36, 8.3, 0.2' \
          func_quartic.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_quartic.png"
     ><IMG SRC="func_quartic.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_quartic.png func_quartic_pf.gif
</CODE> -->
  <A HREF="func_quartic_pf.gif"
     ><IMG SRC="func_quartic_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Of course simple linear modification is also possible, exactly as you get
if you used a <A HREF="../color_mods/#level" >Level Operator</A>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Polynomial '4, -1.5' func_linear.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_linear.png"
     ><IMG SRC="func_linear.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_linear.png func_linear_pf.gif
</CODE> -->
  <A HREF="func_linear_pf.gif"
     ><IMG SRC="func_linear_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Note however that you can not use '<CODE>Polynomial</CODE>' to do a full <A
HREF="../quantize/#threshold" >Threshold</A> operation, due to the need for
infinite coefficients to do so, though you can get pretty close. </P>

A single value is naturally just a constant, and results in a direct
assignment of that value.  In other words it is just like the "<CODE><A
HREF="../option_link.cgi?evaluate" >-evaluate</A> Set </CODE>" method, in this
case to a 33% gray value.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Polynomial 0.33 func_constant.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_constant.png"
     ><IMG SRC="func_constant.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_constant.png func_constant_pf.gif
</CODE> -->
  <A HREF="func_constant_pf.gif"
     ><IMG SRC="func_constant_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By combining a '<CODE>Polynomial</CODE>' with other math functions you can
create even more complex gradient modifications. </P>

For example by taking the square root of a polynomial, I can create a true
circular arc over a linear gradient.  The equivalent of the very slow
"<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" expression
'<NOBR><CODE>sqrt( -4*u^2 + 4*u + 0 )</CODE></NOBR>'...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Polynomial -4,4,0 -evaluate Pow 0.5 \
          func_circle_arc.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_circle_arc.png"
     ><IMG SRC="func_circle_arc.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_circle_arc.png func_circle_arc_pf.gif
</CODE> -->
  <A HREF="func_circle_arc_pf.gif"
     ><IMG SRC="func_circle_arc_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See also the <A HREF="#evaluate_pow" >Pow Evaluate Method</A> for an
alternative to the above. </P>


<A NAME="function_sinusoid"></A>
<H4>Sinusoid Function</H4>

The '<B><CODE>Sinusoid</CODE></B>' function method is a much more advanced
version of the "<CODE><A HREF="../option_link.cgi?evaluate"
>-evaluate</A></CODE>" methods '<CODE>sin</CODE>' and '<CODE>cos</CODE>', and
can in fact replicate those functions, but you have much better controls over
how it modifies the color values in an image. </P>

<DIV ALIGN=center>
<PRE>-function   Sinusoid   frequency,phase,amplitude,bias</PRE>
</DIV>

And is implemented using the formula...

<PRE>  value = ampl * sin(2*PI( freq*value + phase/360 ) ) + bias</PRE>

This may seem complex but it ensures the function is easily to use. </P>

Only the first value 'frequency', which works exactly as per above, is
required with all the other parameters being optional. </P>

By default it will generate a Sine Curve.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Sinusoid 1    func_sine.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_sine.png"
     ><IMG SRC="func_sine.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_sine.png func_sine_pf.gif
</CODE> -->
  <A HREF="func_sine_pf.gif"
     ><IMG SRC="func_sine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By adding a '<I>phase</I>' argument in degrees, you can specify the starting
angle for the curve.  Allowing you convert the default sine curve into a
cosine. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Sinusoid 1,90   func_cosine.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_cosine.png"
     ><IMG SRC="func_cosine.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_cosine.png func_cosine_pf.gif
</CODE> -->
  <A HREF="func_cosine_pf.gif"
     ><IMG SRC="func_cosine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By adjusting the 'frequency', and 'phase' I can directly convert a linear
gradient into a smooth sinusoidal gradient going from black to white (minimum
to maximum along a Sine curve).  See <A HREF="#evaluate_cos" >Evaluate Cosine
Method</A> for a less direct method.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Sinusoid 0.5,-90 func_sine_grad.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_sine_grad.png"
     ><IMG SRC="func_sine_grad.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_sine_grad.png func_sine_grad_pf.gif
</CODE> -->
  <A HREF="func_sine_grad_pf.gif"
     ><IMG SRC="func_sine_grad_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The next two optional values, 'amplitude' and 'bias' controls the scale and
center-line of sinusoidal curve.   For example, here I make a wave (negated
cosine curve) that oscillates between white and gray  (values ranging from
<CODE>0.75 ±0.25</CODE>, or  <CODE>0.5 to 1.0</CODE>), starting and finishing
on white.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Sinusoid 5,90,.25,.75  func_sine_bias.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_sine_bias.png"
     ><IMG SRC="func_sine_bias.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_sine_bias.png func_sine_bias_pf.gif
</CODE> -->
  <A HREF="func_sine_bias_pf.gif"
     ><IMG SRC="func_sine_bias_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Becareful with these last parameters as they could easy cause the waveform to
exceed the bounds of the color value range, and thus be clipped (unless you
are using a  <A HREF="../basics/#hdri" >HDRI version of ImageMagick</A>). </P>

<A NAME="function_arcsin"></A>
<H4>Arcsin Function</H4>

The inverse sinusoid function '<B><CODE>Arcsin</CODE></B>' was added to IM
v6.5.3-0.   This is a special curve that was needed to generate a <A
HREF="../mapping/#displace_cylinder" >Cylindrical Displacement Map</A>. </P>

It parameters are...
<DIV ALIGN=center>
<PRE>-function   Arcsin   width,center,range,bias</PRE>
</DIV>

And is implemented using the formula...

<PRE>  value = range/PI * asin(2/width*( value - center ) ) + bias</PRE>

By default values (if not defined) '<CODE>1, 0.5, 1, 0.5</CODE>' ensures the
the function is centered so as to cover the whole color range from
<CODE>0,0</CODE> to <CODE>1,1</CODE>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arcsin 1    func_arcsin.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arcsin.png"
     ><IMG SRC="func_arcsin.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arcsin.png func_arcsin_pf.gif
</CODE> -->
  <A HREF="func_arcsin_pf.gif"
     ><IMG SRC="func_arcsin_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By halving the '<I>width</I>' of the resulting curve you get...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arcsin 0.5    func_arcsin_width.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arcsin_width.png"
     ><IMG SRC="func_arcsin_width.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arcsin_width.png func_arcsin_width_pf.gif
</CODE> -->
  <A HREF="func_arcsin_width_pf.gif"
     ><IMG SRC="func_arcsin_width_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The '<I>center</I>' will let you reposition the curve according to the
input grey values.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arcsin 0.4,0.7 func_arcsin_center.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arcsin_center.png"
     ><IMG SRC="func_arcsin_center.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arcsin_center.png func_arcsin_center_pf.gif
</CODE> -->
  <A HREF="func_arcsin_center_pf.gif"
     ><IMG SRC="func_arcsin_center_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The  '<I>range</I>' argument allows to reduce the output range of the
color values, and the '<I>bias</I>' will adjust the center of that
range.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arcsin 0.5,0.5,0.5,0.5  func_arcsin_range.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arcsin_range.png"
     ><IMG SRC="func_arcsin_range.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arcsin_range.png func_arcsin_range_pf.gif
</CODE> -->
  <A HREF="func_arcsin_range_pf.gif"
     ><IMG SRC="func_arcsin_range_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how the values that are invalid as a result of the function are handled.
This this allows better control when the function is used in displacements,
and provides ways in which to clean them up. The actual values used are is
'<CODE><I>bias</I> ±<I>range</I>/2</CODE>', as you would expect.  </P>

Note that if either the '<I>width</I>' or the '<I>range</I>' are made negative
the slope of the function will be flipped, as a result of that negative value.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arcsin -1    func_arcsin_neg.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arcsin_neg.png"
     ><IMG SRC="func_arcsin_neg.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arcsin_neg.png func_arcsin_neg_pf.gif
</CODE> -->
  <A HREF="func_arcsin_neg_pf.gif"
     ><IMG SRC="func_arcsin_neg_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="function_arctan"></A>
<H4>Arctan Function</H4>

The '<B><CODE>Arctan</CODE></B>' method was added to IM v6.5.3-1.
</P>

Its parameters are...
<DIV ALIGN=center>
<PRE>-function   Arctan   slope,center,range,bias</PRE>
</DIV>

And is implemented using the formula...

<PRE>  value = range/PI * atan(slope*PI*( value - center ) ) + bias</PRE>

As you can see it is almost exactly the same as the 'Arcsin' function, with
only a small change to make it more useful. It even has the same set of
default values (if not defined) '<CODE>1, 0.5, 1.0, 0.5</CODE>'. </P>

This means that if you specify a slope value of '<CODE>1.0</CODE>' the slope
of the histogram change will produce a 1:1 change around pure gray, (no
scaling) while making white and black a more gray value.  For example

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arctan 1 func_arctan.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arctan.png"
     ><IMG SRC="func_arctan.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arctan.png func_arctan_pf.gif
</CODE> -->
  <A HREF="func_arctan_pf.gif"
     ><IMG SRC="func_arctan_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

That is the middle part of the gradient is actually left unchanged, with only
the black and white ends becoming de-contrasted. </P>


As the '<I>slope</I>' of the curve becomes larger, the gradient in the center
will become stronger (more compressed in the middle), by that amount.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arctan 10 func_arctan_10.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arctan_10.png"
     ><IMG SRC="func_arctan_10.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arctan_10.png func_arctan_10_pf.gif
</CODE> -->
  <A HREF="func_arctan_10_pf.gif"
     ><IMG SRC="func_arctan_10_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This in many ways is very similar to a <A
HREF="../color_mods/#sigmoidal-contrast" >Sigmoidal Contrast</A> color
modification operator.  However a '<CODE>Arctan</CODE>' function will NEVER
actually reach the output range limits of pure black and white. It will
approach those limits but never cross them. </P>

Similarly to the previous functions, (and <A
HREF="../color_mods/#sigmoidal-contrast" >Sigmoidal Contrast</A>) the second
argument will adjust the position of the curve relative to the input gradient
values.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arctan 10,.7 func_arctan_center.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arctan_center.png"
     ><IMG SRC="func_arctan_center.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arctan_center.png func_arctan_center_pf.gif
</CODE> -->
  <A HREF="func_arctan_center_pf.gif"
     ><IMG SRC="func_arctan_center_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And the last two arguments '<I>range</I>' will let you adjust output range of
values that will be generated.  For example by expanding this value slightly
you can ensure that it will completely cover the whole range of possible
values.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arctan 5,0.7,1.2 func_arctan_range.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arctan_range.png"
     ><IMG SRC="func_arctan_range.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arctan_range.png func_arctan_range_pf.gif
</CODE> -->
  <A HREF="func_arctan_range_pf.gif"
     ><IMG SRC="func_arctan_range_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However if you are really wanting to generate curve to modify the whole
contrast of an image in this way, it is more typical to use the  <A
HREF="../color_mods/#sigmoidal-contrast" >Sigmoidal Contrast Operator</A>,
which is designed for this purpose.  </P>

The more typical use of an '<CODE>Arctan</CODE>' gradient function to create a
curve that will very quickly approach a specific value but not exceed that
value.   It is these limiting values that the '<I>range</I>' and '<I>bias</I>'
arguments control. </P>

For example, this curve will modify the gradient in an image to produce very
sharp threshold around the input gray level of 0.7, but with the values
changing between the range limits of 0.5 and 1.0

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png -function Arctan 15,0.7,0.5,0.75 func_arctan_typ.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="func_arctan_typ.png"
     ><IMG SRC="func_arctan_typ.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s func_arctan_typ.png func_arctan_typ_pf.gif
</CODE> -->
  <A HREF="func_arctan_typ_pf.gif"
     ><IMG SRC="func_arctan_typ_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is something that <A HREF="../color_mods/#sigmoidal-contrast" >Sigmoidal
Contrast</A> can not generate. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="gradient_math"></A>
<H2>Mathematics on Gradient Images</H2>

Now the above functions provide some very basic transformations for gradient
images.  But what if you want to do some mathematics with two or more gradient
images.  That is modify one gradient using the gradient of another image. </P>

For this you need to use the special <A HREF="../compose/#math" >Mathematical
Compose Methods</A> (such as "<CODE><A HREF="../compose/#plus"
>Plus</A></CODE>" and "<CODE><A HREF="#divide" >Divide</A></CODE>"). </P>

Before we start however, I would like to give you one <B>word of warning</B>.
If your gradient images are purely grey-scale images, with no alpha channels,
then you can use the <A HREF="../compose/#math" >Mathematical Compose
Methods</A> directly.  However if you want to limit these methods to
a specific channel, or apply them to the alpha (transparency) channel, then
you need to ensure that you set the appropriate "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting, with no
special '<CODE>Sync</CODE>' channel flag.  See <A
HREF="../compose/#image_math" >Image Mathematics using Image Composition</A>
for more details. </P>

Normally using <A HREF="../compose/#math" >Mathematical Compose Methods</A> is
not really that difficult.  The complications arise when you have gradients
that also contain a 'bias'.  That is the gradient should represent a value of
'zero' at '50% grey, and cover a range from -1 (black) to +1 (white).  Such
images are often used for <A HREF="../mapping/#distort" >Distortion Image
Mapping</A>. </P>

As such performing maths on '<I>biased gradients</I>' is the real problem,
and what will be looked at more specifically here. </P>


<A NAME="math_attenuate"></A>
<H3>Attenuate a Biased Gradient</H3>

For example,  here I want to create a sine wave, but one that starts out
small, but then gets larger in amplitude. </P>

This known as 'attenuating' a biased gradient.  Or putting it another way,
multiply a biased gradient by another absolute gradient.  It is also how
'<I>Amplitude Modulation</I>' such as in AM radio works! </P>

So first we need a sine wave, which we can simply generate from a linear
gradient...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 5x300 gradient: -rotate 90   math_linear.png
  convert math_linear.png  -evaluate sine 12  math_sine.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_linear.png math_linear_pf.gif
  im_profile -s math_sine.png   math_sine_pf.gif
</CODE> -->
  <A HREF="math_linear_pf.gif"
     ><IMG SRC="math_linear_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_sine_pf.gif"
     ><IMG SRC="math_sine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Now to attenuate this we multiply the sine wave with a linear gradient,
using a <A HREF="../compose/#multiply" >Multiply</A> alpha composition...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png  math_linear.png  \
          -compose Multiply -composite  math_sine_2.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_sine_2.png   math_sine_2_pf.gif
</CODE> -->
  <A HREF="math_sine_pf.gif"
     ><IMG SRC="math_sine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="X">
  <A HREF="math_linear_pf.gif"
     ><IMG SRC="math_linear_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_sine_2_pf.gif"
     ><IMG SRC="math_sine_2_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

But to use this in say a <A HREF="../mapping/#water_ripples" >Water Ripples,
Displacement Map</A> the wave must remain centered around a perfect gray.  To
do this we need to add a bias to the original image.  This happened to be the
same function we used to multiply the original image, negated and divided by
two....

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  math_linear.png -negate -evaluate divide 2  math_bias.png
  convert  math_sine_2.png  math_bias.png \
          -compose Plus -composite  math_attenuated.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_bias.png   math_bias_pf.gif
  im_profile -s math_attenuated.png   math_attenuated_pf.gif
</CODE> -->
  <A HREF="math_sine_2_pf.gif"
     ><IMG SRC="math_sine_2_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="X">
  <A HREF="math_bias_pf.gif"
     ><IMG SRC="math_bias_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_attenuated_pf.gif"
     ><IMG SRC="math_attenuated_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And so we have a linearly attenuated Sine Wave Gradient, suitable for use in a
displacement map. <P>

Of course you can do the whole process all in the one command, and it does not
have to be a simple linear attenuation either.  For example here I attenuate
the high frequency Sine wave, using a negated Cosine wave, instead of a linear
gradient.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_linear.png  -evaluate cos 1 -negate  math_cosine_peak.png
  convert math_sine.png  math_cosine_peak.png \
          \( -clone 0,1 -compose multiply -composite \) \
          \( -clone  1  +level 50%,0 \
             -clone  2  -compose plus -composite \) \
          -delete 0--2  math_cosine_atten.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_cosine_peak.png   math_cosine_peak_pf.gif
  im_profile -s math_cosine_atten.png  math_cosine_atten_pf.gif
</CODE> -->
  <A HREF="math_sine_pf.gif"
     ><IMG SRC="math_sine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <B>attenuate</B>
  <A HREF="math_cosine_peak_pf.gif"
     ><IMG SRC="math_cosine_peak_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_cosine_atten_pf.gif"
     ><IMG SRC="math_cosine_atten_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As of IM v6.5.4-3 it is now possible to do the all the steps above all in one
compose method, using the special <A HREF="../compose/#mathematics"
>Mathematics Compose Method</A>.  Basically by recognising that an attenuation
operation is the formula <CODE>Sc*Dc-.5*Sc+.5</CODE> or the arguments,
"<CODE>1,-.5,0,.5</CODE>".

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png  math_cosine_peak.png \
          -compose Mathematics -set option:compose:args 1,-.5,0,.5 \
          -composite  math_attenuate.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s math_attenuate.png  math_attenuate_pf.gif
</CODE> -->
  <A HREF="math_attenuate_pf.gif"
     ><IMG SRC="math_attenuate_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The same result can also be achieved by first adjusting the attenuation
gradient using a <A HREF="#function_polynomial" >Polynomial Function</A> and
then using a <A HREF="../compose/#exclusion" >Exclusion</A> compose operator,
to merge the images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png \( math_cosine_peak.png -function polynomial -.5,.5 \) \
          -compose Exclusion -composite  math_poly_excl.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s math_poly_excl.png  math_poly_excl_pf.gif
</CODE> -->
  <A HREF="math_poly_excl_pf.gif"
     ><IMG SRC="math_poly_excl_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="math_multiply"></A>
<H3>Multiply Biased Gradients</H3>

But what if BOTH functions are biased so a perfect gray means zero,
and black and white represent the range from -1 to +1? </P>

Well this is a little more complex as you can't just multiply them and expect
it to come out right, as the multiplication can consist of a negative values.
This requires some care so as to ensure you don't end up clipping the values
and getting the right negation of the curve in the resulting image.
</P>

The trick is to break up the multiplication into multiple steps.  That is
&nbsp; <NOBR><B><CODE> A &times B </CODE></B></NOBR> &nbsp; can also be written
as  &nbsp; <NOBR><B><CODE> A &times abs(B) &times sign(B)</CODE></B></NOBR>.
By doing this you avoid multiplying by a negative value, which can't be stored
in a normal gradient image.  So all we need to do is take one of the bias
gradients and separate it into two parts so they can be applied to the other
gradient appropriately.  </P>

The '<CODE>sign()</CODE>' of a biased gradient, or getting a mask of what
parts are negative, can get extracted by using a <A
HREF="../quantize/#threshold" >Threshold</A> on the gradient at the bias
level.  You can later selectively negate the other gradient using a <A
HREF="../compose/#difference" >Composite Difference</A>, with that threshold
image. </P>

The '<CODE>abs()</CODE>' of a biased gradient can be extracted easily using <A
HREF="../color_mods/#solarize" >Solarize</A>, then negating and doubling
(using <A HREF="../color_mods/#level" >Level</A>) that to get the absolute
value of the gradient ranging from 0.0 to 1.0.  As we will also need the bias
offset as part of the multiply (as per <A HREF="#math_attenuate"
>Attenuate</A> above), you can directly use the negated and half-scaled
solarize output, before it is converted into the gradients absolute value.
</P>

So lets convert one gradient into these three components.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  math_cosine_peak.png  -threshold 50% -negate  math_m_sign.png
  convert  math_cosine_peak.png     -solarize 50%        math_m_bias.png
  convert  math_m_bias.png          -level 50%,0         math_m_abs.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_m_sign.png  math_m_sign_pf.gif
  im_profile -s math_m_bias.png  math_m_bias_pf.gif
  im_profile -s math_m_abs.png   math_m_abs_pf.gif
</CODE> -->
<TABLE>
<TR><TD>
</TD><TD>
  <A HREF="math_m_sign_pf.gif"
     ><IMG SRC="math_m_sign_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD ALIGN=center>
  Sign of Gradient
  <BR>white = negative
</TD></TR><TR><TD>
  <A HREF="math_cosine_peak_pf.gif"
     ><IMG SRC="math_cosine_peak_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
<TD>
  <A HREF="math_m_bias_pf.gif"
     ><IMG SRC="math_m_bias_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD ALIGN=center>
  Bias Offset
</TD></TR><TR><TD>
</TD><TD>
  <A HREF="math_m_abs_pf.gif"
     ><IMG SRC="math_m_abs_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD ALIGN=center>
  Absolute Value
</TD></TR><TD></TABLE>
</DIV></P>

Now that we have these three parts of one of the gradient images, we can merge
them with the other gradient.  To do this we multiply by the absolute value,
re-add the bias, and then negate the parts that should be made negative.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png   math_m_abs.png \
          -compose Multiply -composite    math_m_1.png
  convert math_m_1.png   math_m_bias.png \
          -compose Plus -composite        math_m_2.png
  convert math_m_2.png   math_m_sign.png \
          -compose Difference -composite  math_multiply.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_m_1.png  math_m_1_pf.gif
  im_profile -s math_m_2.png  math_m_2_pf.gif
  im_profile -s math_multiply.png   math_multiply_pf.gif
</CODE> -->
<TABLE>
<TR><TD>
  <A HREF="math_sine_pf.gif"
     ><IMG SRC="math_sine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="X">
</TD><TD>
  <A HREF="math_m_abs_pf.gif"
     ><IMG SRC="math_m_abs_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_m_1_pf.gif"
     ><IMG SRC="math_m_1_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
</TD><TD>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="+">
</TD><TD>
  <A HREF="math_m_bias_pf.gif"
     ><IMG SRC="math_m_bias_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_m_2_pf.gif"
     ><IMG SRC="math_m_2_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
</TD><TD>
  sign
</TD><TD>
  <A HREF="math_m_sign_pf.gif"
     ><IMG SRC="math_m_sign_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_multiply_pf.gif"
     ><IMG SRC="math_multiply_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TD></TABLE>
</DIV></P>

And that is a perfect multiplication of two bias gradient images! </P>


Here it is again but all in the one command...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png  math_cosine_peak.png \
          \( -clone  1  -threshold 50% -negate \) \
          \( -clone  1      -solarize 50%      \) \
          \( -clone  3      -level 50%,0       \) \
          \( -clone 0,4 -compose multiply   -composite \
             -clone  3  -compose plus       -composite \
             -clone  2  -compose difference -composite \) \
          -delete 0--2    math_multiply_2.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s math_multiply_2.png  math_multiply_2_pf.gif
</CODE> -->
  <A HREF="math_sine_pf.gif"
     ><IMG SRC="math_sine_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="X">
  <A HREF="math_cosine_peak_pf.gif"
     ><IMG SRC="math_cosine_peak_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="math_multiply_2_pf.gif"
     ><IMG SRC="math_multiply_2_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


One final note, unlike <A HREF="#attenuation" >Attenuation</A>, this Multiply
of biased gradients is commutative.  That is swapping the input images does
not effect the final result. </P>

As the above is equivelent to the formula <CODE>2*Sc*Dc-Sc-Dc+1</CODE>, as of
IM v6.5.4-3, you can implement the above complex steps as a single '<CODE><A
HREF="../compose/#mathematics" >Mathematics</A></CODE>' compose method using
the argument "<CODE>2,-1,-1,1</CODE>".

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png  math_cosine_peak.png \
          -compose Mathematics -set option:compose:args 2,-1,-1,1 \
          -composite  math_bias_multiply.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s math_bias_multiply.png  math_bias_multiply_pf.gif
</CODE> -->
  <A HREF="math_bias_multiply_pf.gif"
     ><IMG SRC="math_bias_multiply_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

That is vastly easier and faster method than the dozen or more steps needed
without this argumented compose method. </P>

It so happens that once I saw that formula, I realised that this happens to be
simply the negation of the '<CODE><A HREF="../compose/#exclusion"
>Exclusion</A></CODE>' compose method.  Weird but true.  As such the following
will also generate the same zero baised multiply.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_sine.png  math_cosine_peak.png \
          -compose exclusion -composite -negate  math_excl_neg.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s math_excl_neg.png  math_excl_neg_pf.gif
</CODE> -->
  <A HREF="math_excl_neg_pf.gif"
     ><IMG SRC="math_excl_neg_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="math_addition"></A>
<H3>Adding Biased Gradients</H3>

With the advent of the '<CODE><A
HREF="../compose/#mathematics" >Mathematics</A></CODE>' compose method,
adding biased gradients is also relativally easy. The equivelent FX formula is
"<CODE>u+v-0.5</CODE>" or a compose argument of "<CODE>0,1,1,-.5</CODE>". </P>

For example the following was a <A HREF="../fourier/#waves" >Fourier
Transform Example</A> that I had hand generated, requiring the addition
of 3 biased sinusoids, and a constant DC value.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert math_linear.png -function sinusoid 3.5,0,.25     wave_1.png
  convert math_linear.png -function sinusoid 1.5,-90,.13   wave_2.png
  convert math_linear.png -function sinusoid 0.6,-90,.07   wave_3.png

  convert wave_1.png wave_2.png wave_3.png -background gray40 \
          -compose Mathematics -set option:compose:args 0,1,1,-.5 \
          -flatten  added_waves.png
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE>
  im_profile -s wave_1.png wave_1_pf.gif
  im_profile -s wave_2.png wave_2_pf.gif
  im_profile -s wave_3.png wave_3_pf.gif
  im_profile -s added_waves.png added_waves_pf.gif
</CODE>-->
  <A HREF="wave_1_pf.gif"
     ><IMG SRC="wave_1_pf.gif"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="wave_2_pf.gif"
     ><IMG SRC="wave_2_pf.gif"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="wave_3_pf.gif"
     ><IMG SRC="wave_3_pf.gif"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="added_waves_pf.gif"
     ><IMG SRC="added_waves_pf.gif"  WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note in the above how I used the "<CODE><A HREF="../option_link.cgi?flatten"
>-flatten</A></CODE>" operator with a "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" setting to
implement a mutliple image composition.  Or in this case a 'Biased Sum' of all
the given images plus the background constant. </P>


<A NAME="math_freq_mod"></A>
<H3>Frequency Modulation</H3>

By applying a function directly to the output of another function, you do NOT
produce a simple result.  The reason is that all these math functions are
applied to the gradient 'value' of individual pixels, and not against the
x value of the pixel in the gradient.  </P>

For example....

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png  -evaluate sin 0.5 -normalize \
                        -evaluate cos  8  math_cos_var.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="math_cos_var.png"
     ><IMG SRC="math_cos_var.png"    WIDTH=600   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<!-- <CODE EXECUTE>
  im_profile -s math_cos_var.png math_cos_var_pf.gif
</CODE> -->
  <A HREF="math_cos_var_pf.gif"
     ><IMG SRC="math_cos_var_pf.gif"    WIDTH=150  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


This generates a very complex function that is essentually equivelent to

<DIV ALIGN=center><CODE>
    cos( 8 * sin( <I>{value}</I>/2 ) )
</CODE></DIV>

In other words a variable frequency, where the frequency varies with the
gradient of the first sine curve. </P>

Basically the faster the gradient changes in the original image, the smaller
the distance between the peaks.  However the height (amplitude) of the peak do
not vary. </P>

This is actually how '<I>Frequency Modulation</I>' works, where a seemingly
simple function produces a very complex result. </P>

<HR><!-- ---------------------------------------------------------------- -->

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<PRE>
Miscellaneous Image Transformation Techniques.

These have not been exampled yet, but are some basic IM developed transforms
that may provide useful.  If you have an interesting effect please contribute.

   pixelize an image
      resize an image down 10 then scale the image 10 to produce blocks
      of roughly averaged color.
      For example...
         convert input.jpg -resize 10% -sample 1000% output.jpg

  De-skew slightly rotated images

    -deskew {threshold}
       straighten an image. A threshold of 40% works for most images.

    Use -set option:deskew:auto-crop {width} to auto crop the image. The set
    argument is the pixel width of the image background (e.g 40).

    Programmically we auto crop by running a median filter across the image
    to eliminate salt-n-pepper noise.  Next we get the image bounds of the
    median filter image with a fuzz factor (e.g. -fuzz 5%).  Finally we
    crop the original image by the bounds.  The code looks like this:

      median_image=MedianFilterImage(image,0.0,exception);
      geometry=GetImageBoundingBox(median_image,exception);
      median_image-DestoryImage(median_image);

      print("  Auto-crop geometry: %lux%lu%+ld%+ld",
                geometry.width,geometry.height, geometry.x,geometry.y);
      crop_image=CropImage(rotate_image,&geometry,exception);

    See <A HREF="../crop/#trim_blur" >Trimming 'Noisy' Images</A>

  Segmentation
    look at scripts
       <A HREF="../scripts/divide_vert" >divide_vert</A>
       <A HREF="../scripts/segment_image" >segment_image</A>
    for some simple scripts I wrote to segment well defined images into
    smaller parts.   I hope to get simple segmentation functions like this
    into the core library, to allow for things like automatic sub-division of
    GIF animations, and seperating images and diagrams from scanned documents.


</PRE>

<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 15 March 2004 <BR>
Updated: 18 June 2009 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/transform/</CODE>
</ADDRESS></BODY></HTML>
