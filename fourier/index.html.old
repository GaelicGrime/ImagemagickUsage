<HTML><HEAD>
<TITLE>Fourier Transforms -- IM v6 Examples</TITLE>
<meta name="author" content="Fred Weinhaus">
<meta name="description" content="Fourier Transforms Tutorial For ImageMagick">
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="http://www.imagemagick.org/Usage/fourier/">
<!--[if gte IE 5.5000]><![if lt IE 7.0000]>
<script type="text/javascript" src="../img_www/pngfix.js"></script>
<![endif]><![endif]-->
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Fourier Transforms</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#introduction"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Introduction</A>
<DD><A HREF="#fourier_transform"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > The Fourier Transform</A>
    <UL>
    <LI><A HREF="#waves"
        >Images are Waves </A>
    <LI><A HREF="#waves_2d"
        >2 Dimensional Waves in Images</A>
    <LI><A HREF="#sine_waves"
        >Sinusoidal Waves</A>
    <LI><A HREF="#complex_waves"
        >Complex Number Sinusoidal Waves</A>
    <LI><A HREF="#dft_equation"
        >Discrete Fourier Transform Equation</A>
    </UL>
<DD><A HREF="#im_fft"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > FFT/IFT In ImageMagick</A>
    <UL>
    <LI><A HREF="#fft"
        >Using FFT</A>
    <LI><A HREF="#fft_partial"
        >Magnitude or Phase Only Images</A>
    <LI><A HREF="#fft_spectrum"
        >FFT Spectrum Image</A>
    <LI><A HREF="#fft_hdri"
        >HDRI FFT Images</A>
    <LI><A HREF="#fft_ri"
        >FFT as Real-Imaginary Components</A>
   </UL>
<DD><A HREF="#ft_properties"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Properties Of The Fourier Transform</A>
    <UL>
    <LI><A HREF="#fft_constant"
        >FFT of a Constant Image</A>
    <LI><A HREF="#fft_dc_color"
        >Effects of the DC Color</A>
    <LI><A HREF="#sine_spectrum"
        >Spectrum Of A Sine Wave Image</A>
    <LI><A HREF="#generation"
        >Generating FFT Images Directly</A>
    <LI><A HREF="#rectangle_spectrum"
        >Spectrum Of A Rectangle Pattern Image</A>
    <LI><A HREF="#circle_spectrum"
        >Spectrum Of A Flat Circular Pattern Image</A>
    <LI><A HREF="#gaussian_spectrum"
        >Spectrum Of A Gaussian Circular Pattern Image</A>
    <LI><A HREF="#grid_spectrum"
        >Spectrum Of A Grid Pattern Image</A>
   </UL>
<DD><A HREF="#ft_applications"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Practical Applications</A>
    <UL>
    <LI><A HREF="#contrast"
        >Changing The Contrast Of An Image - Coefficient Rooting</A>
    <LI><A HREF="#blurring"
        >Blurring An Image - Low Pass Filtering</A>
    <LI><A HREF="#edge_detection"
        >Detecting Edges In An Image - High Pass Filtering</A>
    <LI><A HREF="#sharpening"
        >Sharpening An Image - High Boost Filtering</A>
    <LI><A HREF="#noise_removal"
        >Noise Removal - Notch Filtering</A>
   </UL>
<DD><A HREF="#advanced"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Advanced Applications</A>

</UL>
</DL></P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="introduction"></A>
<H2>Introduction</H2>

One of the hardest concepts to comprehend in image processing is Fourier
Transforms. There are two reasons for this. First, it is mathematically
advanced and second, the resulting images, which do not resemble the original
image, are hard to interpret. </P>

Nevertheless, utilizing Fourier Transforms can provide new ways to do familiar
processing such as enhancing brightness and contrast, blurring, sharpening and
noise removal. But it can also provide new capabilities that one cannot do in
the normal image domain. These include deconvolution (also known as
deblurring) of typical camera distortions such as motion blur and lens defocus
and image matching using normalized cross correlation. </P>

It is the goal of this page to try to explain the background and simplified
mathematics of the Fourier Transform and to give examples of the processing
that one can do by using the Fourier Transform. </P>

If you find this too much, you can skip it and simply focus on the properties
and examples, starting with <A HREF="#im_fft" > FFT/IFT In ImageMagick</A>
</P>

For those interested, another nice simple discussion, including analogies to
optics, can be found at <A
HREF="http://cns-alumni.bu.edu/~slehar/fourier/fourier.html" >An Intuitive
Explanation of Fourier Theory</A>. </P>

The lecture notes from Vanderbilt University School Of Engineering are also
very informative for the more mathematically inclined: <A
HREF="http://ia350624.us.archive.org/2/items/Lectures_on_Image_Processing/EECE253_06_FourierTransform.pdf"
>1 &amp; 2 Dimensional Fourier Transforms</A> and <A
HREF="http://ia350625.us.archive.org/2/items/Lectures_on_Image_Processing/EECE253_08_FrequencyFiltering.pdf"
>Frequency Filtering</A>. </P>

Other mathematical references include Wikipedia pages on <A
HREF="http://en.wikipedia.org/wiki/Fourier_transform" >Fourier Transform</A>,
<A HREF="http://en.wikipedia.org/wiki/Discrete_Fourier_transform" >Discrete
Fourier Transform</A> and <A
HREF="http://en.wikipedia.org/wiki/Fast_Fourier_transform" >Fast Fourier
Transform</A> as well as <A
HREF="http://en.wikipedia.org/wiki/Complex_numbers" >Complex Numbers</A>.
</P>

<I>My thanks to Sean Burke for his coding of the original demo and to
ImageMagick's creator for integrating it into ImageMagick. Both were heroic
efforts.  </I></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="fourier_transform"></A>
<H2>The Fourier Transform</H2>

An image normally consists of an array of 'pixels' each of which are defined
by a set of values: red, green, blue and sometimes transparency as well. But
for our purposes here we will ignore transparency. Thus each of the red, green
and blue 'channels' contain a set of 'intensity' or 'grayscale' values.</P>

This is known as a raster image '<I>in the spatial domain</I>'. This is just
a fancy way of saying, the image is defined by the 'intensity values' it has
at each 'location' or 'position in space'.</P>

But an image can also be represented in another way, known as the image's
'<I>frequency domain</I>'.  In this domain, each image channel is represented
in terms of sinusoidal waves.</P>

In such a '<I>frequency domain</I>', each channel has 'amplitude' values that
are stored in locations based not on X,Y 'spatial' coordinates, but on X,Y
'frequencies'.  Since this is a digital representation, the frequencies are
multiples of a 'smallest' or unit frequency and the pixel coordinates
represent the indices or integer multiples of this unit frequency.</P>

This follows from the principal that "any well-behaved function can be
represented by a superposition (combination or sum) of sinusoidal waves". In
other words, the 'frequency domain' representation is just another way to
store and reproduce the 'spatial domain' image. </P>

But how can an image be represented as a 'wave'?

<A NAME="waves"></A>
<H3>Images are Waves</H3>

Well if we take a single row or column of pixel from <I>any</I> image, and
graph it (generated using "gnuplot" using the script "<CODE><A
HREF="../scripts/im_profile" >im_profile</A></CODE>"), you will find that it
looks rather like a wave.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert holocaust_tn.gif -colorspace gray miff:- |\
    im_profile -s - image_profile.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="holocaust_tn.gif"
     ><IMG SRC="holocaust_tn.gif"   WIDTH=120 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="image_profile.gif"
     ><IMG SRC="image_profile.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

If the fluctuations were more regular in spacing and amplitude, you would get
something more like a wave pattern, such as...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 20x150 gradient: -rotate 90 \
          -function sinusoid 3.5,0,.4   wave.gif
  im_profile -s wave.gif wave_profile.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="wave.gif"
     ><IMG SRC="wave.gif"   WIDTH=150 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="wave_profile.gif"
     ><IMG SRC="wave_profile.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

However while this regular wave pattern is vaguely similar to the image profile
shown above, it is too regular. </P>

However if you were to add more waves together you can make a pattern that is
even closer to the one from the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x150 gradient: -rotate 90 \
          -function sinusoid 3.5,0,.25,.25     wave_1.png
  convert -size 1x150 gradient: -rotate 90 \
          -function sinusoid 1.5,-90,.13,.15   wave_2.png
  convert -size 1x150 gradient: -rotate 90 \
          -function sinusoid 0.6,-90,.07,.1    wave_3.png

  convert wave_1.png wave_2.png wave_3.png \
          -evaluate-sequence add added_waves.png
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE>
  im_profile -s wave_1.png wave_1_pf.gif
  im_profile -s wave_2.png wave_2_pf.gif
  im_profile -s wave_3.png wave_3_pf.gif
  im_profile -s added_waves.png added_waves_pf.gif
</CODE>-->
  <A HREF="wave_1_pf.gif"
     ><IMG SRC="wave_1_pf.gif"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="wave_2_pf.gif"
     ><IMG SRC="wave_2_pf.gif"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="wave_3_pf.gif"
     ><IMG SRC="wave_3_pf.gif"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="added_waves_pf.gif"
     ><IMG SRC="added_waves_pf.gif"  WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

See also <A HREF="../transform/#math_addition" >Adding Biased Gradients</A>
for a alternative example to the above. </P>

This '<I>wave superposition</I>' (addition of waves) is much closer, but still
does not exactly match the image pattern. However, you can continue in this
manner, adding more waves and adjusting them, so the resulting composite wave
gets closer and closer to the actual profile of the original image.  Eventually
by adding enough waves you can exactly reproduce the original profile of the
image.  </P>

This was the discovery made by the mathematician <A
HREF="http://en.wikipedia.org/wiki/Joseph_Fourier" >Joseph Fourier</A>.  A
modern interpretation of which states that "any well-behaved function can be
represented by a superposition of sinusoidal waves". </P>

In other words by adding together a sufficient number of sine waves of just
the right frequency and amplitude, you can reproduce any fluctuating pattern.
Therefore, the 'frequency domain' representation is just another way to
store and reproduce the 'spatial domain' image. </P>

The '<I>Fourier Transform</I>' is then the process of working out what 'waves'
comprise an image, just as was done in the above example. </P>


<A NAME="waves_2d"></A>
<H3>2 Dimensional Waves in Images</H3>

The above shows one example of how you can approximate the profile of a single
row of an image with multiple sine waves.  However images are 2 dimensional,
and as such the waves used to represent an image in the 'frequency domain'
also needs to be two dimensional. </P>

Here is an example of one such 2 dimensional wave. </P>

The wave has a number of components to it.

</P><I>Image example</I></P>

<!--
# <TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
# <TR><TD BGCOLOR="#800000" COLSPAN=5
#         ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
# </TR>
# <TR><TD BGCOLOR="#800000" ROWSPAN=2
#         ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
#     <TD ROWSPAN=2
#         ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
#     <TD>&nbsp;</TD>
#     <TD ROWSPAN=2
#         ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
#     <TD BGCOLOR="#800000" ROWSPAN=2
#         ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
# </TR>
# <TR><TD ALIGN=justify>
#
# <I>This is overly mathematical, when there is no need to be</I>
#
# <A NAME="sine_waves"></A>
# <H3>Sinusoidal Waves</H3>
#
# The following is an image of 1D sinusoidal curve. It is a stationary wave in
# space, since it is not moving.  that is to say it not a function of time.
# </P>
#
# <DIV ALIGN=center>
# <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
# <TR><TD><PRE><CODE EXECUTE>
#   convert -size 20x150 gradient: -rotate 90 -evaluate sin 5 sin5.png
#   im_profile -s sin5.png  sin5_pf.gif
# </CODE></PRE></TD></TR></TABLE>
#   <A HREF="sin5.png"
#      ><IMG SRC="sin5.png"   WIDTH=150 HEIGHT=20
#            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
#   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
#   <A HREF="sin5_pf.gif"
#      ><IMG SRC="sin5_pf.gif"   WIDTH=150 HEIGHT=100
#            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
# </DIV></P>
#
#
# The equation describing a stationary, spatial sinusoidal wave may be expressed
# as follows.  </P>
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/sinusoid.jpg"   WIDTH=399 HEIGHT=53
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
# Here '<CODE>u</CODE> is the intensity of the wave as a function of its
# position '<CODE>x</CODE>'. The amplitude, '<CODE>A</CODE>', is half the height
# from peak to trough. The number of full up and down cycles is given by
# '<CODE>n</CODE>', which is also called the harmonic index and '<CODE>N</CODE>'
# is the interval of the wave, namely, the width of the image. Thus, the
# frequency, '<CODE>f=n/N</CODE>', is how rapidly it moves up and down. </P>
#
# The distance from peak to peak, '<CODE>&lambda;</CODE>', is the wavelength.
# Also '<CODE>&phi;</CODE>' is the phase of the wave. If '<CODE>&phi;</CODE>' is
# set to zero, then we have a sine wave and if '<CODE>&phi;</CODE>' is set to
# '<CODE>&pi;/2</CODE>', then we have a cosine wave.  The image and profile
# above correspond to a sine wave with 5 full up and down cycles. The following
# is the equivalent cosine wave with 5 cycles. </P>
#
#
# <DIV ALIGN=center>
# <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
# <TR><TD><PRE><CODE EXECUTE>
#   convert -size 20x150 gradient: -rotate 90 -evaluate cos 5 cos5.png
#   im_profile -s cos5.png cos5_pf.gif
# </CODE></PRE></TD></TR></TABLE>
#   <A HREF="cos5.png"
#      ><IMG SRC="cos5.png"   WIDTH=150 HEIGHT=20
#            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
#   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
#   <A HREF="cos5_pf.gif"
#      ><IMG SRC="cos5_pf.gif"   WIDTH=150 HEIGHT=100
#            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
# </DIV></P>
#
# Notice the shift of the wave profile to the left by one quarter of the
# wavelength due to the phase difference of &pi;/2. (A phase shift of
# 2*&pi; or 360 degrees brings us right back to the original sine wave.) </P>
#
# So what are the limits on the frequency that one can produce in an image?
# Well, obviously an image channel that is a constant graylevel has zero
# frequency.
#
# <DIV ALIGN=center>
# <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
# <TR><TD><PRE><CODE EXECUTE>
#   convert -size 20x150 gradient: -rotate 90 -evaluate sin 0 sin0.png
#   im_profile -s sin0.png sin0_pf.gif
# </CODE></PRE></TD></TR></TABLE>
#   <A HREF="sin0.png"
#      ><IMG SRC="sin0.png"   WIDTH=150 HEIGHT=20
#            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
#   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
#   <A HREF="sin0_pf.gif"
#      ><IMG SRC="sin0_pf.gif"   WIDTH=150 HEIGHT=100
#            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
# </DIV></P>
#
# This is called the '<I>DC frequency</I>', a term that arises from the early
# days of electronics and basically means "Direct Current" since it doesn't
# actually oscilate back and forth. </P>
#
# In terms of images it represents the overall average value or color that is
# present in an image.  This is naturally an important component in the
# frequency domain of an image, and one that is in many ways very different from
# all the other frequency components of the image. </P>
#
# If one only considers full cycles, then the next frequency corresponds to one
# full cycle or '<CODE>n=1</CODE>' and the frequency is '<CODE>f=1/N<CODE>'.
# This is called the fundamental frequency, or the first harmonic wave. </P>
#
# <DIV ALIGN=center>
# <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
# <TR><TD><PRE><CODE EXECUTE>
#   convert -size 20x150 gradient: -rotate 90 -evaluate sin 1 sin1.png
#   im_profile -s sin1.png sin1_pf.gif
# </CODE></PRE></TD></TR></TABLE>
#   <A HREF="sin1.png"
#      ><IMG SRC="sin1.png"   WIDTH=150 HEIGHT=20
#            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
#   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
#   <A HREF="sin1_pf.gif"
#      ><IMG SRC="sin1_pf.gif"   WIDTH=150 HEIGHT=100
#            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
# </DIV></P>
#
# Note that while this frequency is the first harmonic, it often has very little
# impact on a specific image.  Basically if present it specifies that one side
# of the image is fundimentally brighter or darker than the other side.
# Something that does not really happen in the typical case. </P>
#
#
# The next higher frequency will have '<CODE>n=2</CODE>' and
# '<CODE>f=2/N</CODE>' and is called the second harmonic wave. </P>
#
#
# <DIV ALIGN=center>
# <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
# <TR><TD><PRE><CODE EXECUTE>
#   convert -size 20x150 gradient: -rotate 90 -evaluate sin 2 sin2.png
#     im_profile -s sin2.png sin2_pf.gif
# </CODE></PRE></TD></TR></TABLE>
#   <A HREF="sin2.png"
#      ><IMG SRC="sin2.png"   WIDTH=150 HEIGHT=20
#            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
#   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
#   <A HREF="sin2_pf.gif"
#      ><IMG SRC="sin2_pf.gif"   WIDTH=150 HEIGHT=100
#            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
# </DIV></P>
#
# This continues until we reach the maximum number of full cycles that is
# allowed, which is '<CODE>n=N/2</CODE>'; that is there is a full cycle every
# 2 pixels.  Therefore, the frequency is '<CODE>f=1/2</CODE>'. This frequency is
# called the Nyquist frequency. </P>
#
# <DIV ALIGN=center>
# <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
# <TR><TD><PRE><CODE EXECUTE>
#   convert -size 20x1500 gradient: -rotate 90 -evaluate sin 75 \
#           -scale 10% -auto-level   sin75.png
#     im_profile -s sin75.png sin75_pf.gif
# </CODE></PRE></TD></TR></TABLE>
#   <A HREF="sin75.png"
#      ><IMG SRC="sin75.png"   WIDTH=150 HEIGHT=20
#            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
#   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
#   <A HREF="sin75_pf.gif"
#      ><IMG SRC="sin75_pf.gif"   WIDTH=150 HEIGHT=100
#            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
# </DIV></P>
#
# <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
# <TR VALIGN=top>
# <TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
#     ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
# <TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
#   The unusual creation of the sine wave in the above is nessary to ensure that
#   the resulting image is correct.  With waves this close to the
#   Nyquist frequency, it is extremly easy to generate sever <A
#   HREF="../resize/#aliasing" >Aliasing and Moiré Effects</A>.
# </I></FONT></TD></TR></TABLE></P>
#
# The Nyquist frequency basically represents the highest frequency (producing
# a wave length of 2), that can be fully represented in an image.  Any wave with
# a highter frequency (and thus a wave-length smaller than 2) will become
# distorted by the limitations (the number of pixels involved) inherent in
# a raster image. </P>
#
# It is stated without proof that any image pattern can be recreated by an
# appropriate combination of each sinusoidal wave between zero and the Nyquist
# (limiting) frequency. An interesting demonstration is shown below and creates
# a step function pattern by combining (superposing) multiple sinusoidal
# harmonics.  See <A HREF="http://en.wikipedia.org/wiki/Square_wave" >Square
# Wave</A>. </P>
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/synthesis_square.gif"   WIDTH=472 HEIGHT=200
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
# The ripples or ringing effect, known as the Gibbs phenomenon, is due to the
# finite bandwidth of the sinusoidal waves. That is, only a finite number
# of harmonics were used. </P>
#
#
# <A NAME="complex_waves"></A>
# <H3>Complex Number Sinusoidal Waves</H3>
#
# The Fourier Transform is founded upon the concept of complex number
# sinusoidal waves. What this means is that the wave is made up of two
# sinusoidal components, one considered 'real' and the other considered
# 'imaginary', mathematically speaking.  </P>
#
# So what is a complex number? A complex number is expressed as c = a + ib,
# where a is the real part, b is the imaginary part and i is a symbol that
# represents sqrt(-1). A complex number may be represented as vector diagrams as
# shown below. See <A HREF="http://en.wikipedia.org/wiki/Complex_number"
# >Complex Numbers</A>.
#
# <TABLE ALIGN=center>
# <TR VALIGN=top><TD ALIGN=center>
#   <IMG SRC="../img_diagrams/polar_number.jpg"   WIDTH=132 HEIGHT=142
#        ALIGN=middle VSPACE=5 HSPACE=50 BORDER=1 ALT="[Diagram]"></A>
#   <BR>Magnitude/Phase
# </TD><TD ALIGN=center>
#   <IMG SRC="../img_diagrams/complex_number.jpg"   WIDTH=132 HEIGHT=142
#        ALIGN=middle VSPACE=5 HSPACE=50 BORDER=1 ALT="[Diagram]"></A>
#   <BR>Complex Number
#   <BR>Real/Imaginary
# </TD></TR></TABLE></P>
#
# In polar form, we have r, which is called the magnitude and is equal to
# '<CODE>sqrt(a^2 + b^2) or sqrt(<I>RealPart</I>^2
# + <I>ImaginaryPart</I>^2)</CODE>' and '<CODE>&phi;</CODE>, which is called the
# phase and is equal to '<CODE>arctan2(b,a)</CODE>' or
# '<CODE>arctan2(<I>ImaginaryPart</I>,<I>RealPart</I>)</CODE>'.  </P>
#
# So getting back, a complex sinusoidal wave is expressed using
# <A HREF="http://en.wikipedia.org/wiki/Euler%27s_formula" >
# Euler's Formula</A> as:
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/complex_sinusoid.jpg"   WIDTH=271 HEIGHT=60
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
# So it is just a combination of a cosine wave for the real component and a sine
# wave for the imaginary component, which is equivalent to a complex exponential,
# where e=2.71828 is the basis of the natural logarithm. </P>
#
# <A NAME="dft_equation"></A>
# <H3>Discrete Fourier Transform Equation</H3>
#
# So now we put all the above together and present the equations for the
# 1D Discrete Fourier Transform. Let the 1D image channel grayscale intensities
# be called g(x) and the Fourier Transform be called G(n). Then the forward
# discrete Fourier transform (DFT) is given by </P>
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/fft_1d_equation.jpg"   WIDTH=202 HEIGHT=66
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
# where n=0,1,2...N-1. This says that the 1D Discrete Fourier Transform is a
# 1D array of N values, G(n), each of which is composed of an addition
# (superposition) of N complex sinusoidal waves whose amplitudes are the 1D
# image intensity values, g(x). </P>
#
# The inverse 1D Discrete Fourier Transform is given by a similar equation,
# namely, </P>
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/ift_1d_equation.jpg"   WIDTH=197 HEIGHT=74
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
# where x=0,1,2...N-1. This says that each of the N image values at g(x) are
# just an addition (superposition) of all N possible frequencies (or harmonics),
# given by f=n/N, of complex sinusoidal waves whose amplitudes are the G(n)
# values.  </P>
#
# We note that these two equations are very similar structurally to each other.
# There are two main differences. First, in the forward transform, the
# exponential term has a negative sign and in the inverse transform, it has
# a positive sign.  Second, the forward transform is divided by N. This is just
# one convention of several. In some approaches, neither expression is divided
# by N. This is the un-normalized representation. In other representations, one
# or the other of the forward or inverse equations are divided by N. And in
# other representation, the normalization is symmetric with both equations
# divided by the square root of N. The reason for the factor of N is to preserve
# the mean squared magnitude (average signal) so that it is the same in both the
# spatial and frequency domains. Mathematical details can be found at <A
# HREF="http://www.engineeringproductivitytools.com/stuff/T0001/PT05.HTM#Head377"
# >Scaling</A>. </P>
#
# For those interested, the following set of 5 links goes through the process
# of calculating a DFT for a 4-point image of a simple step function. </P>
#
# <TABLE CELLSPACING="0" CELLPADDING="5" ALIGN="center">
# <TR><TD ALIGN="left" VALIGN="top">
# <UL>
# <LI><A HREF="../img_diagrams/step_image1.jpg" >1D Step Function Image</A></LI>
# <LI><A HREF="../img_diagrams/step_image2.jpg" >FFT</A></LI>
# <LI><A HREF="../img_diagrams/step_image3.jpg" >IFT</A></LI>
# <LI><A HREF="../img_diagrams/step_image4.jpg"
#     >Real &amp; Imaginary Components</A></LI>
# <LI><A HREF="../img_diagrams/step_image5.jpg"
#     >Magnitude &amp; Phase Components</A></LI>
# </UL>
# </TD></TR></TABLE></P>
#
#
# For a 2D image, these equations become </P>
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/fft_2d_equation.jpg"   WIDTH=339 HEIGHT=88
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
# <DIV ALIGN=center>
#   <IMG SRC="../img_diagrams/ift_2d_equation.jpg"   WIDTH=301 HEIGHT=85
#        ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
# </DIV></P>
#
#
# <TABLE WIDTH="90%" CELLSPACING="0" CELLPADDING="5" ALIGN="center">
# <TR><TD ALIGN="left" VALIGN="top">
#
# <B>Thus the result of applying the 2D Discrete Fourier Transform on an image
# channel of size NxM will be a complex image of size NxM, i.e. coordinates
# ranging horizontally from n=0,1,2...N and vertically from m=0,1,2...M.  The
# intensity values at these coordinates are called the Fourier Coefficients,
# G(n,m). They represent the strengths of each corresponding image frequency,
# fx=n/N and fy=m/M. However, as the transform is assumed to be periodic, the
# zero frequency location, called the DC point, is usually repositioned at
# coordinates (N/2,M/2) and thus we get negative frequencies on the left and top
# side of this point in the transform image. One reason for doing the shift is
# so that the most important (strongest) Fourier Coefficients will be in the
# middle and therefore easily visible.</B>
#
# </TD></TR></TABLE></P>
#
# &nbsp;</TD></TR>
# <TR><TD WIDTH=100% BGCOLOR="#800000" COLSPAN=5
#         ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
# </TR></TABLE>
-->

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="im_fft"></A>
<H2>FFT/IFT In ImageMagick</H2>

<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD BGCOLOR="#800000" COLSPAN=5
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR>
<TR><TD BGCOLOR="#800000" ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
    <TD ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
    <TD>&nbsp;</TD>
    <TD ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
    <TD BGCOLOR="#800000" ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR>
<TR><TD ALIGN=justify>

<I>To be re-written, based on the section above. </I></P>

In ImageMagick's initial implementation, as of version 6.5.4-3, any non-square
image or one with an odd dimension will be padded automatically to be square at
the maximum of the image width (N) or height (M) and to have even dimensions
prior to applying the Forward Fourier Transform. The consequence of this is that
after applying the Inverse Fourier Transform, such an image will need to be
cropped back to its original dimensions. </P>

As the Fourier Transform is composed of complex numbers, the result of the
transform cannot be visualized directly. Therefore, the complex transform is
separated into two component images in one of two forms. </P>

More commonly, the two components that are created are the magnitude and phase
representations of the complex numbers. The advantage of this is that both
contain only non-negative values. The magnitude, by definition, is always
non-negative.  However, the phase normally ranges from -&pi; to +&pi;. </P>

However, as images can not store such floating point values, it is usual to
shift it while doing the forward transform to the range 0 to 2&pi; and then
shift it back when doing the inverse transform. This is also multiplied so as
to span the span the fully dynamic range for images, from 0 to
<I>QuantumRange</I> (as determined by the <A HREF="../basics/#quality"
>In-memory bit Quality</A> used by this version of ImageMagick). </P>

The magnitude has no fixed range of values. However, one important feature is
that the value at the DC or zero frequency position will be the average color
value for the whole image. Typically this also becomes the largest value for
all the magnitude components. Usually all the other values in the magnitude
image will be smaller than this.  As a consequence of this the magnitude image
generally will appear to be dark or even totally black to the naked eye. </P>

By scaling the magnitude and applying a log transform of its intensity values
usually will be needed to bring out any visual detail. The resulting
'log-transformed' magnitude image is known as the image's 'spectrum'.
However remember that it is the 'magnitude' image, and not the 'spectrum'
image, that should be used for the inverse transform. </P>

The 'magnitude' and 'phase' component images are generated in ImageMagick
using the "<CODE><A HREF="../option_link.cgi#fft" >-fft</A></CODE>" operator.
While the "<CODE><A HREF="../option_link.cgi#ift" >-ift</A></CODE>" operator
will take those two images and transform them back into the original image.
</P>

&nbsp;</TD></TR>
<TR><TD WIDTH=100% BGCOLOR="#800000" COLSPAN=5
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR></TABLE>

<A NAME="fft"></A>
<H3>Using FFT</H3>

Now, lets simply try a Fourier Transform round trip on the Lena image.  That
is, we simply do the forward transform and immediately apply the inverse
transform to get back the original image. Then we will compare the results to
see the level of quality produced. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR2OUT OUT=lena_roundtrip_cmp.txt>
  time convert lena.png -fft -ift lena_roundtrip.png

<n>  echo -n "RMSE = "
<n>  compare -metric RMSE lena.png lena_roundtrip.png null:
<n>  echo -n "PAE = "
<n>  compare -metric PAE  lena.png lena_roundtrip.png null:
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_roundtrip.png"
     ><IMG SRC="lena_roundtrip.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="lena_roundtrip_cmp.txt"
    ><IMG SRC="lena_roundtrip_cmp.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The "<CODE><A HREF="../basics/#compare" >compare</A></CODE>" program above
returns a measure of how different the two images are.  In this case you can
see that the general difference is very small, of about <CODE>0.22%</CODE>.
With a peak value difference in at least one pixel of about
("<CODE>PAE</CODE>", Peak Absolute Error) of just about <CODE>1%</CODE>. </P>

You can improve this by using a <A HREF="../basics/#hdri" >HDRI</A> version of
ImageMagick. (See <A HREF="#fft_hdri" >FFT with HDRI</A> below). </P>

Lets take a closer look at the FFT images that were generated in the above
round trip.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena.png -fft +adjoin lena_fft_%d.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR><TD ALIGN=center>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Original
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="lena_fft_0.png"
     ><IMG SRC="lena_fft_0.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Magnitude
</TD><TD ALIGN=center>
  <A HREF="lena_fft_1.png"
     ><IMG SRC="lena_fft_1.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Phase
</TD></TR></TABLE>
</DIV></P>

As John M. Brayer has said on <A
HREF="http://www.cs.unm.edu/~brayer/vision/fourier.html" >his page</A> about
Fourier Transforms... <I>We generally do not display PHASE images because most
people who see them shortly thereafter succumb to hallucinogenics or end up in
a Tibetan monastery.</I> </P>

Note that the "<CODE><A HREF="../option_link.cgi#fft" >-fft</A></CODE>"
operator generated two images, the first image is the 'magnitude' component
(yes it is mostly black with a single colored dot in the middle), while the
second, almost random looking image, contains the 'phase' component. </P>

PNG images can only store one image per file as such neither the "<CODE><A
HREF="../option_link.cgi#adjoin" >+adjoin</A></CODE>" or the '<CODE>%d</CODE>'
in the output filename was actually needed, as IM would handle this.
However I include the options in the above for completeness, so as to make it
clear I am generating two separate image files, not one.  See <A
HREF="../files/#adjoin" >Writing a Multi-Image Sequence</A> for more details.
</P>

As two images are generated the magnitude image (first of zeroth image) is
saved into "<CODE>lena_fft_0.png</CODE>" and phase image (second image) into
"<CODE>lena_fft_1.png</CODE>".  </P>

You can also save these images into into a single file format allows multiple
images, and removing the <A HREF="../option_link.cgi#adjoin"
>+adjoin</A></CODE>" and '<CODE>%d</CODE>' components of the above.  For
example by saving it into the "<CODE><A HREF=../files/#miff"
>MIFF</A></CODE>", file format...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert lena.png -fft lena_fft.miff
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Or you can save them into complete separate filenames using "<CODE><A
HREF="../option_link.cgi#write" >-write</A></CODE>"  (See <A
HREF="../files/#write" >Writing Images</A>)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert lena.png -fft \
          \( -clone 0 -write lena_magnitude.png +delete \) \
          \( -clone 1 -write lena_phase.png +delete \) \
          null:
</CODE></PRE></TD></TR></TABLE>
</DIV></P>
<!-- Fudge the images save a little space.
<CODE EXECUTE>
  ln -s lena_fft_0.png lena_magnitude.png
  ln -s lena_fft_1.png lena_phase.png
</CODE>-->

Note that in the above I used the special "<CODE><A HREF="../files/#null"
>NULL:</A></CODE>" image format to junk the two images which are still
preserved in memory for further processing. </P>

And finally we again read in the two images again, so as to convert it back
into a normal 'spatial' image...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena_magnitude.png lena_phase.png -ift lena_restored.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lena_magnitude.png"
     ><IMG SRC="lena_magnitude.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="lena_phase.png"
     ><IMG SRC="lena_phase.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_restored.png"
     ><IMG SRC="lena_restored.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<!-- <CODE EXECUTE ASSERT>
  # check the colors come put correctly
  [ `compare -metric PAE lena_roundtrip.png lena_restored.png null: 2>&1 |\
        sed 's/ .*//'` != '0' ] &&  echo >&2 \
    "ASSERTION FAILURE: Saved vs In-Memory FFT roundtrip are different\!"
</CODE> -->

Both images generated by the FFT process are very sensitive to modification,
where even small changes can result greatly distorted results.  As such it is
important to never save them in any image format that could distort those
values. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  To prevent sever distortions when saving FFT images. It is best not to save
  them to disk at all, but hold them in memory while you process the image.
  </P>

  If you must save then it is best to use the Magick File Format "<CODE><A
  HREF=../files/#miff" >MIFF</A></CODE>" so as to preserve the image at its
  highest quality (bit depth).  This format can also save multiple images in
  the one file.  For script work you can also use the  verbose "<CODE><A
  HREF="../files/#txt" >TXT</A></CODE>" Enumerated Pixel Format.  </P>

  <B>DO NOT</B> save them using "<CODE><A HREF="../formats/#jpg"
  >JPEG</A></CODE>" or "<CODE><A HREF="../formats/#gif" >GIF</A></CODE>" image
  formats. </P>

  If you must save these images into files for actual viewing, such as for
  a web browser, use the image format "<CODE><A HREF="../formats/#png"
  >PNG</A></CODE>" (as we do in these examples). However it can only store one
  image per file. </P>

  The "<CODE><A HREF="../formats/#tiff" >TIFF</A></CODE>" file format can also
  be used though is not as acceptable for web browsers. But it does allow
  multiple images per file. </P>

</I></FONT></TD></TR></TABLE></P>

It is also important to remember that both images are needed when recovering
the image from the frequency domain. So it is no good saving one image an not
the other if you plan on using them for image reconstruction. </P>



<A NAME="fft_partial"></A>
<H3>Magnitude or Phase Only Images</H3>

Finally, lets try reconstructing an image from just its magnitude component or
just its phase component. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena_fft_0.png  -size 128x128 xc:gray50  -ift lena_magitude_only.png

  convert -size 128x128 xc:gray1  lena_fft_1.png  -ift lena_phase_only.png
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=60%>
<TR><TD ALIGN=center>
  <A HREF="lena_magitude_only.png"
     ><IMG SRC="lena_magitude_only.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Magnitude Only
</TD><TD ALIGN=center>
  <A HREF="lena_phase_only.png"
     ><IMG SRC="lena_phase_only.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Phase Only
</TD></TR></TABLE></DIV></P>

You will note from this that it is the phase image that actually contains most
of the position information of the image, while the magnitude actually holds
much of the color information.  This is not exact, as there is some overlap in
the information, but that is generally the case. </P>

Note that the magnitude image generated for the 'Phase Only' image in the
above is actually only 1% gray (almost pure black).  Even so it still produces
patches of very intense pixels, especially along edges.  That is while
position information is present, it has no real sense of what color things
should actually be. </P>

Just remember both images are needed to reconstruct the original image. </P>


<A NAME="fft_spectrum"></A>
<H3>Frequency Spectrum Image</H3>

You will have noted that the magnitude image (the first or zeroth image), as
appears almost totally black.  It isn't really, but to our eyes all the values
are very very small.  Such an image isn't really very interesting to look at
to study, so lets enhance the result with a log transform to produce the
a '<I>frequency spectrum</I>' image. </P>

This is done by applying a strong <A HREF="../transform/#evaluate_log"
>Evaluate Log Transform</A> to a <A HREF="../color_mods/#normalize"
>Normalized</A> 'magnitude' image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena_fft_0.png -auto-level -evaluate log 10000 \
          lena_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lena_fft_0.png"
     ><IMG SRC="lena_fft_0.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_spectrum.png"
     ><IMG SRC="lena_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Now we can see the detail in the spectrum version of the magnitude image. </P>

You may even see some specific colors in the spectrum image, but generally
such colors are unimportant in a spectrum image. It is the overall intensity
of each frequency, and the patterns they produce that is far more important.
As such you may also like to gray-scale the spectrum image after enhancement.
</P>

How much of a log enhancement you need to use depends on the image, so you
should adjust it until you get the amount of detail you need to clearly see
the pattern of the images frequency spectrum. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Alturnativally you can use the following small shell script, to calculate
a <I>log scaling factor</I> to use for the specific magnitude image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=lena_spectrum_auto.png>
  scale=`convert lena_fft_0.png -auto-level \
          -format "%[fx:exp(log(mean)/log(0.5))]" info:`
  convert lena_fft_0.png -auto-level \
          -evaluate log $scale    lena_spectrum_auto.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="lena_spectrum_auto.png"
     ><IMG SRC="lena_spectrum_auto.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>

However remember that you can not use a spectrum image, for the inverse
"<CODE><A HREF="../option_link.php#ift" >-ift</A></CODE>" transform as it will
produce overly bright image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena_spectrum.png lena_fft_1.png -ift lena_roundtrip_fail.png
</CODE></PRE></TD></TR></TABLE></P>

Basically as you have enhanced the 'magnitude' image, you have also enhanced
the resulting image in the same way, producing the badly 'clipped' result
shown.  </P>

</TD><TD>
  <A HREF="lena_roundtrip_fail.png"
     ><IMG SRC="lena_roundtrip_fail.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>



<A NAME="fft_hdri"></A>
<H3>HDRI FFT Images</H3>

<I>Talk about Accuracy here</I></P>

However such images, while more exactly representing the frequency components
of the FFT of the image, can contain negative and fractional values must be
kept in memory, or saved to a limited number of file formats that is capable
of handling floating-point values. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Floating point compatible file formats include "<CODE><A
  HREF=../files/#miff" >MIFF</A></CODE>", "<CODE><A HREF="../formats/#tiff"
  >TIFF</A></CODE>",  "<CODE><A HREF="../formats/#netpbm" >PFM</A></CODE>" and
  the HDRI specific "<CODE>EXR</CODE>" file format.
</I></FONT></TD></TR></TABLE></P>

For example here I use a <A HREF="../basics/#hdri" >HDRI version
ImageMagick</A> to generate another 'round trip' conversion of an image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE HDRI ERR2OUT OUT=lena_roundtrip_hdri_cmp.txt>
  # HDRI version of IM used
  time convert lena.png -fft -ift lena_roundtrip_hdri.png

<n>  echo -n "RMSE = "
<n>  compare -metric RMSE lena.png lena_roundtrip_hdri.png null:
<n>  echo -n "PAE = "
<n>  compare -metric PAE  lena.png lena_roundtrip_hdri.png null:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="lena_roundtrip_hdri.png"
     ><IMG SRC="lena_roundtrip_hdri.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="lena_roundtrip_hdri_cmp.txt"
    ><IMG SRC="lena_roundtrip_hdri_cmp.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

If you compare the results above with the previous non-HDRI comparison...

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="lena_roundtrip_cmp.txt"
    ><IMG SRC="lena_roundtrip_cmp.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV>

You will see that the HDRI version of IM produced a more accurate result.
Though with very slight speed penalty. It also required twice a much memory as
a normal Q16 IM (See <A HREF="../basics/#quality" >Compile-Time Quality</A>).
</P>

In later examples processing an FFT of an image, will need such accuracy to
produce good results. As such as we proceed with using Fast Fourier
Transforms, a <A HREF="../basics/#hdri" >HDRI version ImageMagick</A> will
become a requirement. </P>


<A NAME="fft_ri"></A>
<H3>FFT as Real-Imaginary Components</H3>

So far we have only represented 'components' that define the sine waves of an
image (its "Fourier Transform") using a 'Magnitude' and a 'Phase' form.  </P>

However there is another way you can represent the waves that make up
a Fourier Transform, using a mathematical idea known as "<A
HREF="http://en.wikipedia.org/wiki/Complex_number" >Complex Numbers</A>". </P>

For example if we take the 'Magnitude' and 'Phase' of a sine wave and plot
them using 'Polar Coordinates'  You can convert the two values into different
mathematical concept of 'Real' and 'Imaginary' complex number components.

<TABLE ALIGN=center>
<TR VALIGN=top><TD ALIGN=center>
  <IMG SRC="../img_diagrams/polar_number.jpg"   WIDTH=132 HEIGHT=142
       ALIGN=middle VSPACE=5 HSPACE=50 BORDER=1 ALT="[Diagram]"></A>
  <BR>Magnitude/Phase
</TD><TD ALIGN=center>
  <IMG SRC="../img_diagrams/complex_number.jpg"   WIDTH=132 HEIGHT=142
       ALIGN=middle VSPACE=5 HSPACE=50 BORDER=1 ALT="[Diagram]"></A>
  <BR>Complex Number
  <BR>Real/Imaginary
</TD></TR></TABLE></P>

This means you can also represent a FFT using a complex number, which also
requires two components, and thus two images to represent one image. </P>

However while the 'Magnitude' (r) and 'Phase' (&theta;) values are easily
saved as positive values, 'Real' and 'Imaginary' values can be either positive
or negative.  As negative values may be involved, you have to use a specially
compiled HDRI form of ImageMagick. </P>

To generate a FFT of an image using Complex Numbers you would use the 'plus'
form of the operators,  "<CODE><A HREF="../option_link.cgi#fft"
>+fft</A></CODE>" and "<CODE><A HREF="../option_link.cgi#ift"
>+ift</A></CODE>".  And can only save such images using special HDRI image
file formats. </P>

For example here I used a <B>HDRI version of IM</B> to also perform a 'round
trip' FFT of an image, but this time generating Real/Imaginary images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE HDRI ERR2OUT OUT=lena_roundtrip_ri_cmp.txt>
  # HDRI version of IM used
  time convert lena.png   +fft +ift   lena_roundtrip_ri.png

<n>  echo -n "RMSE = "
<n>  compare -metric RMSE lena.png lena_roundtrip_ri.png null:
<n>  echo -n "PAE = "
<n>  compare -metric PAE  lena.png lena_roundtrip_ri.png null:
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="lena_roundtrip_ri.png"
     ><IMG SRC="lena_roundtrip_ri.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="lena_roundtrip_ri_cmp.txt"
    ><IMG SRC="lena_roundtrip_ri_cmp.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As mentioned you must use a HDRI version when you use the plus forms to
generate Real/Imaginary FFT images.  If you don't the resulting image with
have a 'dirty' look about them due to the 'clipping' of negative values.
For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # non-HDRI Q16 version of IM used
  convert lena.png   +fft +ift   lena_roundtrip_ri_bad.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="lena_roundtrip_ri_bad.png"
     ><IMG SRC="lena_roundtrip_ri_bad.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The other thing to remember is that which form of FFT images you generate will
also effect all image processing operations you want to apply to the FFT
images.  They are very different images, and as such they must be processed in
different ways, with different mathematical operations. </P>

Also as before you must have both Real and Imaginary component images
to restore the final image.  For example, here is what happens if we
substitute a 'black' image for one of the components.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE HDRI>
  # HDRI version of IM used
  convert lena.png +fft -delete 1 \
          -size 128x128 xc:black +ift lena_real_only.png
  convert lena.png +fft -delete 0 \
          -size 128x128 xc:black +ift lena_imaginary_only.png
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=60%>
<TR><TD ALIGN=center>
  <A HREF="lena_real_only.png"
     ><IMG SRC="lena_real_only.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Real Only
</TD><TD ALIGN=center>
  <A HREF="lena_imaginary_only.png"
     ><IMG SRC="lena_imaginary_only.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Imaginary Only
</TD></TR></TABLE></DIV></P>

You can see from this that both Real/Imaginary FFT images contain vital
information about the original image fairly equally.  The biggest difference
between the two is the special DC or 'average color' value, which we will look
at next. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="ft_properties"></A>
<H2>Properties Of The Fourier Transform</H2>


<A NAME="fft_constant"></A>
<H3>FFT of a Constant Image</H3>

Lets demonstrate some of these properties. </P>

First lets simply take a constant color image and get its magnitude.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x128 xc:gold constant.png
  convert constant.png -fft +delete constant_magnitude.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="constant.png"
     ><IMG SRC="constant.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="constant_magnitude.png"
     ><IMG SRC="constant_magnitude.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the magnitude image in this case is really pure black, except for
a single colored pixel in the very center of the image, at the pixel location
width/2, height/2.  This pixel is the  zero frequency or DC ('<I>Direct
Current</I>') value of the image, and is the one pixel that does not represent
a sine wave.  In other words it is just the FFT constant component!  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

To see this single pixel more clearly lets also magnify that area of the
image...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert constant_magnitude.png -gravity center -extent 5x5 \
           -scale 2000% constant_dc_zoom.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="constant_dc_zoom.gif"
     ><IMG SRC="constant_dc_zoom.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the color of the DC point is the same as the original image. </P>

Actually it is a good idea to remember that what you are seeing is three
values.  That is the FFT images generated is actually three separate Fast
Fourier transforms. A FFT for each of the three red, green and blue image
channels.  The FFT itself has no real knowledge about colors, only the color
values or '<I>gray-levels</I>'. </P>


<A NAME="fft_dc_color"></A>
<H3>Effects of the DC Color</H3>

In a more typical non-constant image, the DC value is the average color of the
image.  The color you should generally get if you had completely blurred,
averaged, or resized the image down to a single pixel or color. </P>

For example lets extract the DC pixel from the FFT of the "Lena" image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert lena.png -fft +delete lena_magnitude.png
  convert lena_magnitude.png -gravity center -extent 1x1 \
          -scale 60x60   lena_dc_zoom.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_magnitude.png"
     ><IMG SRC="lena_magnitude.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_dc_zoom.gif"
     ><IMG SRC="lena_dc_zoom.gif"   WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the average color for the image is a sort of 'dark pink' color.
</P>

Another way of thinking about this special pixel is that it represents the
center 'bias' level which all the other sine waves modify the image colors.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example lets replace that 'dark pink' DC pixel with some other color
such as the more orange color 'tomato'...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena.png -fft \
          \( -clone 0  -draw "fill tomato  color 64,64 point" \) \
          -swap 0 +delete -ift lena_dc_replace.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="lena_dc_replace.png"
     ><IMG SRC="lena_dc_replace.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

What is really happening is that by changing the DC value in the FFT images
you are changing the whole image in that same way.  Actually any change in the
DC value (the difference) will be added (or subtracted) from each and every
pixel in the resulting image. This is how changing the average color of the
image gets replicated from the 'frequency domain' back into the 'spatial
domain' as we did above. </P>

Unfortunately, just as if we really were really adding some constant to each
pixel, the final pixel colors in the reconstructed image could also be clipped
by the maximum (white) or minimum (black) limits. As such this is not
a recommended method of color tinting an image. But it is simpler than
modifying every pixel in the whole image, though the FFT round trip will make
it a slower technique).  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  While the 'phase' of the DC value is not important, it should always be
  a 'zero' angle (a colour value of 50% gray). If it is not set to 50% gray,
  the DC value will have a 'unreal' component, and its value modulated by the
  angle given.
</I></FONT></TD></TR></TABLE></P>


<A NAME="sine_spectrum"></A>
<H3>Spectrum Of A Sine Wave Image</H3>

Next, lets take a look at the spectrum from a single sine wave image with
4 cycles. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x129 gradient: -chop 0x1 -rotate 90 -evaluate sine 4 \
          sine4.png
  convert sine4.png -fft +delete \
          -auto-level -evaluate log 100  sine4_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sine4.png"
     ><IMG SRC="sine4.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="sine4_spectrum.png"
     ><IMG SRC="sine4_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The unusual creation of the sine wave in the above is necessary to ensure
  that the resulting wave image tiles correctly. See <A
  HREF="../canvas/#perfect_gradients" >Generating the Perfect Gradient</A>.
  </P>

  If this is not done the resulting image does not tile perfectly as the
  left-most and right-most values of the sine wave are duplicate values.  This
  This results in undesired harmonics in the FFT image. </P>

</I></FONT></TD></TR></TABLE></P>

In the spectrum image (enhanced magnitude image) above, we can see that it has
3 dots.  The center dot is as before the average DC value.  The other two dots
represent the perfect sine wave that the FFT operator found in the image. As
the frequency across the width of the image is exactly 4 cycles, and as
a result two frequency pixels are exactly 4 pixels away from the center DC
value. </P>

But why two pixels? </P>

Well that is because a sine single wave can be described in two completely
different ways, (one with a negative direction and phase).  Both descriptions
are mathematically correct, and a fourier transform does not distinguish
between them. </P>

This is one of the most important distinguishing features of the FFT
transformation.  Small features on the origina image become large,  and large
features become small, and located close in toward the center. This is
something that is good to remember. </P>

If we repeat this with a sine wave with 16 cycles, then again we see that it
has 3 dots, but the dots are further apart.  In this case the side dots are
spaced 16 pixels to the left and right sides of the center dot.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x129 gradient: -chop 0x1 -rotate 90 -evaluate sine 16 \
          -write sine16.png -fft -delete 1 \
          -auto-level -evaluate log 100 sine16_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sine16.png"
     ><IMG SRC="sine16.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="sine16_spectrum.png"
     ><IMG SRC="sine16_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

From this you can see that perfect sine waves will be represented simply by
two dots in the appropriate position.  The distance this position is from the
center DC value determine the frequency of the sine wave.  the Smaller the
wave length the highter the frequency, so the further the dots will be from
the DC value. </P>

In fact by dividing size of the image by the frequency (distance of the dots
from the center), will give you the wavelength (distance between peaks) of the
wave.  In the above case:  128 pixels divided by 16 cycles, gives you
a wavelength of 8 pixels between each 'band'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Lets take a closer look at these three 'frequencies' by plotting their original
magnitudes (not the logarithmic spectrum).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sine16.png -fft -delete 1  miff:- |\
     im_profile - sine16_magnitude_pf.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sine16_magnitude_pf.png"
     ><IMG SRC="sine16_magnitude_pf.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice that the DC value has a value of 1/2  which is to be expected.  But
that the actual magnitude of the two 16 cycle sine-waves the fourier transform
found is only 1/4. </P>

The magnitude of the original sine-save is really 1/2 but the fourier
transform divided tha magnitude into two, sharing the results across both
plotted frequency waves, so each of the two components only has a magnitude
of 1/4. </P>

<A HREF="lena_spectrum.png"
    ><IMG SRC="lena_spectrum.png"   WIDTH=128 HEIGHT=128
          ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

This duality of positive and negative frequencies in FFT images explains why
all FFT image  spectrums (such as the Lena spectrum repeated left) is always
symetrical about the center.  For every dot on one side of the image, you will
always get a simular 'dot' mirrored across the center of the image. </P>

The same thing happens with the 'phase' component of FFT image pair, but with
a 180 degree shift (a negative phase) in value as well. </P>

This explains why the two images actually still only contains exactly the same
amount of data as the original image.  Each image contains a duplication of
the information needed. So each image only contains half the information, but
together they hold all the images information. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  During generation the FFT algorithm only generates the left half the images.
  The other half is generated by rotations and merging of the generated image.
  </P>

  When converting Frequency Domain images back to a Spatial Domain Image, the
  algorithm again only looks at the left half of the image.  The right half is
  completely ignored. </P>

  As such when (in later examples) you 'notch filter' a FFT magnitude image,
  you only really need to filter the left hand side of the magnitude image.
  You can save yourself some work by also ignoring the right half.  However
  for clarity I will 'notch' both halves. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="generation"></A>
<H3>Generating FFT Images Directly</H3>

Now we can use the above information to actually generate a image of a sine
wave.  All you need to do is create a black and 50% gray image pair, and
add 'dots' with the appropriate magnitude, and phase. </P>

For example...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x128  xc:black \
          -draw 'fill gray50  color 64,64 point' \
          -draw 'fill gray25  color 50,68 point' \
          -draw 'fill gray25  color 78,60 point' \
          generated_magnitude.png
  convert generated_magnitude.png \
          -auto-level -evaluate log 3  generated_spectrum.png
  convert -size 128x128  xc:gray50  generated_phase.png
  convert generated_magnitude.png generated_phase.png \
          -ift  generated_wave.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="generated_spectrum.png"
     ><IMG SRC="generated_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="generated_phase.png"
     ><IMG SRC="generated_phase.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="generated_wave.png"
     ><IMG SRC="generated_wave.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And presto a perfect angled sine wave. </P>

Of course you can only generate perfect sine waves at particular frequences,
but that limitation can also work to our advantage.  Basically any sine wave
generated by a FFT image will be perfectly tilable. That is the left-right and
top-bottom edges will exactly matchup.  As all the frequencies a FFT image has
this property, making it a useful one. </P>

Unfortunately all the frequencies will also be a power of two in any
horizontal or vertical direction, and that is the limitation of this
technqiue. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Actually only the first (left most) 'gray25' dot was needed to generate the
  sine wave as the IFT transform completely ignores the right half of the image
  as this should simply be a mirror of the left half.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The phase of the DC value must have a 'zero angle' (50% gray color).  If you
  don't ensure that is the case the DC color value will be modulated by its
  non-zero phase, producing a darker, posibily 'clipped' image.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The other pixels in the phase can be any grey level you like, and will
  effectivally 'roll' the sine wave across the image.  Again only the phase of
  the left most dot actually matters.  The right hand side is completely
  ignored. Just ensure the center DC phase pixel remains 50% grey.  </P>
</I></FONT></TD></TR></TABLE></P>

<CODE>FUTURE: Perlin Noise Generator using FFT </CODE> </P>

<A NAME="line_spectrum"></A>
<H3>Spectrum of a Vertical Line</H3>

<I>Show the FFT spectrum of a thin and thick line</I> </P>

<I>Demonstrate how small features become 'big' and big features become 'small'
in the FFT of the image.  Link that back to the sine wave which could be
regarded as a 'line' with a single harmonic. </I>

<I>Rotate the line</I>


<A NAME="rectangle_spectrum"></A>
<H3>Spectrum of a Rectangle Pattern Image</H3>

Next, lets look at the spectrum of white rectangle of width 8 and height 16
inside a black background.  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH="80%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 8x16 xc:white -gravity center \
          -gravity center -background black -extent 128x128 rectangle.png
  convert rectangle.png -fft +delete \
          -auto-level -evaluate log 100 rect_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rectangle.png"
     ><IMG SRC="rectangle.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rect_spectrum.png"
     ><IMG SRC="rect_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the resulting image has a very particular pattern, with a lot
of harmonic frequencies.  If we graph the center horizontal row and vertical
column, we get...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  im_profile -s rect_spectrum.png rect_spectrum_pf.gif

  im_profile -s -v rect_spectrum.png rect_spectrum_pfv.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rect_spectrum_pf.gif"
     ><IMG SRC="rect_spectrum_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rect_spectrum_pfv.gif"
     ><IMG SRC="rect_spectrum_pfv.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<!--
This clearly demonstrates that the transform of the rectangular shape is
indeed a sinc function and that the narrower dimension of the object in the
image produces a transform with features that are more spread out and wider.
According to the properties listed above, the spacing in each dimension
between the troughs is determined by N/a and N/b. Thus, when the width and
height of the rectangle are a=8 and b=16, then the spacings should be 128/8=16
horizontally and 128/16=8 vertically. This is indeed what one measures for the
spacing between the dark troughs in this image. </P>
-->

Now, lets rotate the rectangle by 45 degrees. We find that the spectrum is
also rotated in the same direction by 45 degrees. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rectangle.png -rotate 45 -gravity center -extent 128x128 \
          -write rect_rot45.png -fft -delete 1 \
          -auto-level -evaluate log 100 rect_rot45_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rect_rot45.png"
     ><IMG SRC="rect_rot45.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rect_rot45_spectrum.png"
     ><IMG SRC="rect_rot45_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="circle_spectrum"></A>
<H3>Spectrum Of A Flat Circular Pattern Image</H3>

Next, lets look at the spectrum from an image with a white, flat circular
pattern, in one case with diameters of 12 (radius 6) and in another case
with diameter of 24 (radius 12). </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x128 xc:black -fill white  \
          -draw "circle 64,64 64,70" -write circle6.png -fft -delete 1 \
          -auto-level -evaluate log 100 circle6_spectrum.png

  convert -size 128x128 xc:black -fill white  \
          -draw "circle 64,64 64,76" -write circle12.png -fft -delete 1 \
          -auto-level -evaluate log 100 circle12_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle6.png"
     ><IMG SRC="circle6.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="circle6_spectrum.png"
     ><IMG SRC="circle6_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="circle12.png"
     ><IMG SRC="circle12.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="circle12_spectrum.png"
     ><IMG SRC="circle12_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the first image is very close to what we generated for the jinc
example further above. It is however a little broken up. This artifacting occurs
due to the small size of the circle. Since it is represented digitally, its
perimeter is not perfectly circular. </P>

The transform of the larger circle is better as its perimeter is a closer
approximation of a true circle. We therefore conclude that indeed the
transform of the flat circular shape is a jinc function and that the image
containing the smaller diameter circle produces transform features that are
more spread out and wider. </P>

According to the properties of FFT, the distance from the center to the middle
of the first dark ring in the spectrum will be 1.22*N/d. When the diameter of
the circle is d=12, we get a distance of 1.22*128/12=13. Likewise when the
diameter of the circle is d=24, we get a distance of 1.22*128/24=6.5.  These
are the values that one measures in those images. </P>

<A NAME="gaussian_spectrum"></A>
<H3>Spectrum Of A Gaussian Pattern Image</H3>

Next, lets look at the spectrum from two images, each with a white Gaussian
circular pattern having sigmas of 8 and 16, respectively </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x128 xc:black -fill white \
          -draw "point 64,64" -gaussian-blur 0x8 -auto-level \
          -write gaus8.png -fft -delete 1 \
          -auto-level -evaluate log 1000 gaus8_spectrum.png

  im_profile -s gaus8.png gaus8_pf.gif
  im_profile -s gaus8_spectrum.png gaus8_spectrum_pf.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=center>
  <A HREF="gaus8.png"
     ><IMG SRC="gaus8.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="gaus8_spectrum.png"
     ><IMG SRC="gaus8_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="gaus8_pf.gif"
     ><IMG SRC="gaus8_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="gaus8_spectrum_pf.gif"
     ><IMG SRC="gaus8_spectrum_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x128 xc:black -fill white \
          -draw "point 64,64" -gaussian-blur 0x16 -auto-level \
          -write gaus16.png -fft -delete 1 \
          -auto-level -evaluate log 1000 gaus16_spectrum.png

  im_profile -s gaus16.png gaus16_pf.gif
  im_profile -s gaus16_spectrum.png gaus16_spectrum_pf.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=center>
  <A HREF="gaus16.png"
     ><IMG SRC="gaus16.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="gaus16_spectrum.png"
     ><IMG SRC="gaus16_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="gaus16_pf.gif"
     ><IMG SRC="gaus16_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="gaus16_spectrum_pf.gif"
     ><IMG SRC="gaus16_spectrum_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

This shows that the transform of the Gaussian circular shape is another
Gaussian and that the larger the sigma in the original image, the smaller the
sigma will be in the spectrum. </P>

From the properties stated above, we know that the sigma in the spectrum will
be just N/(2*sigma), where sigma is from the original image. So for an image
of size N and sigma=8, the sigma in the spectrum will be 128/16=8. Similarly
if the image's sigma is 16, then the sigma in the spectrum will be 128/32=4.
</P>

<A NAME="grid_spectrum"></A>
<H3>Spectrum Of A Grid Pattern Image</H3>

Next, lets transform an image containing just a set of grid lines spaced 16x8
pixels apart. The resulting spectrum is just an array of dots where the grid
lines that are more closely spaced produce dots further apart and vice versa.
According to the properties above, since the grid lines are spaced 16x8 pixels
apart, then the dots should be spaced N/a=128/16=8 and M/b=128/8=16, which is
just what is measured in this image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 16x8 xc:white -fill black \
          -draw "line 0,0 15,0" -draw "line 0,0 0,7" \
          -write mpr:tile +delete \
          -size 128x128 tile:mpr:tile \
          -write grid16x8.png -fft -delete 1 \
          -auto-level -evaluate log 100000 grid16x8_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="grid16x8.png"
     ><IMG SRC="grid16x8.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="grid16x8_spectrum.png"
     ><IMG SRC="grid16x8_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD BGCOLOR="#800000" COLSPAN=5
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR>
<TR><TD BGCOLOR="#800000" ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
    <TD ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
    <TD>&nbsp;</TD>
    <TD ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
    <TD BGCOLOR="#800000" ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR>
<TR><TD ALIGN=justify>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<I>A list like this is BAD..
<BR>Better to demonstrate each property instead (as done above), which also
allows it to be explained better rather than just presenting a raw list.
</I></P>

The following is a list of some of the important properties of the Fourier
Transform. </P>

<TABLE CELLSPACING="0" CELLPADDING="5" ALIGN="left">
<TR><TD ALIGN="left" VALIGN="top">

<UL>
<LI>High frequencies in the FFT (corresponding to rapidly varying intensities
    in the original image) lie near the outer parts of the spectrum.</LI>

<LI>Low frequencies in the FFT (corresponding to slowly varying intensities in
    the original image) lie near the center of the spectrum.</LI>

<LI>The zero frequency (DC) point in the FFT for an NxM original image lies at
    coordinates N/2,M/2.</LI>

<LI>The intensity value in the magnitude image at the DC point is equal the
    average graylevel in the original image. (This is a consequence of the
    scaling of the forward transform by 1/N).</LI>

<LI>Edges in an image give rise to transform components lying along lines
    perpendicular to the edges.</LI>

<LI>Smaller objects have more spread-out transforms; Larger objects have more
    compressed transform.</LI>

<LI>If one rotates the image, the transform rotates the same amount.</LI>

<LI>The transform of a uniform object lies along a line perpendicular to the
    dimension of the object.</LI>

<LI>The transform of a set of grid lines of spacing x=a,y=b in image size NxM
    is an array of dots: The spacing of the dots in the spectrum will be
    Dx=N/a and Dy=M/b.</LI>

<LI>The transform of a constant rectangle of dimension x=a,y=b in an image of
    size NxM is a <A HREF="http://mathworld.wolfram.com/SincFunction.html"
    >sinc function</A>: sinc(x*a/N)*sinc(y*b/M), where the
    sinc(x)=sin(&pi;*x)/(&pi;*x). Here is an example of what a sinc function
    looks like with a=8 and b=16 and profiles of its center row and column.
    The scaling factors of plus 0.21 and divide by 1.21 are because the sinc
    function ranges from -0.21 to 1 and thus has negative values that would
    otherwise be clipped in the image. Profiles of the log enhanced sinc are
    also displayed to show how it amplifies the smaller signals relative to
    the larger ones. (The 3D graphs shown below were not created with
    ImageMagick, but from an ImageJ plugin.) An important feature of the sinc
    function is that the spacing between its zeroes is a constant given by
    Dx=N/(a/2) and Dy=M/(b/2).  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  N=128
  a=8
  b=16
  convert \( -size ${N}x1 xc: \
          -fx "ax=$a*pi*(i-w/2)/w; ax==0?1:(sin(ax)/ax+0.21)/1.21" -scale 128x128! \) \
          \( -size 1x${N} xc: \
          -fx "by=$b*pi*(j-h/2)/h; by==0?1:(sin(by)/by+0.21)/1.21" -scale 128x128! \) \
          -compose multiply -composite -auto-level -write sinc8x16.png \
          -evaluate log 10 sinc8x16_log10.png

  im_profile -s    sinc8x16.png sinc8x16_pf.gif
  im_profile -s -v sinc8x16.png sinc8x16_pfv.gif
  im_profile -s    sinc8x16_log10.png sinc8x16_log10_pf.gif
  im_profile -s -v sinc8x16_log10.png sinc8x16_log10_pfv.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sinc8x16.png"
     ><IMG SRC="sinc8x16.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sinc8x16_pf.gif"
     ><IMG SRC="sinc8x16_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sinc8x16_pfv.gif"
     ><IMG SRC="sinc8x16_pfv.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_diagrams/splot_sinc8x16_small.png"
       WIDTH=128 HEIGHT=128
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
<BR>
  <A HREF="sinc8x16_log10.png"
     ><IMG SRC="sinc8x16_log10.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sinc8x16_log10_pf.gif"
     ><IMG SRC="sinc8x16_log10_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sinc8x16_log10_pfv.gif"
     ><IMG SRC="sinc8x16_log10_pfv.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_diagrams/splot_sinc8x16_log10_small.png"
       WIDTH=128 HEIGHT=128
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
</DIV></P>

The absolute value of the sinc function is what corresponds to the magnitude of
the transform. Since the sinc function has positive and negative lobes, when you
take the absolute value, you double the number of oscillations. Therefore, in
the spectrum, the spacing of importance is between the middle of successive dark
troughs (which were the locations of the zeros before taking the absolute
value). This spacing then becomes Dx=N/a and Dy=M/b, due to the doubling of the
oscillations. Here is the same example, but with the log of the absolute value.
Profiles of the center row and column are shown as well. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  N=128
  a=8
  b=16
  convert \( -size ${N}x1 xc: \
          -fx "ax=$a*pi*(i-w/2)/w; ax==0?1:abs(sin(ax)/ax)" -scale 128x128! \) \
          \( -size 1x${N} xc: \
          -fx "by=$b*pi*(j-h/2)/h; by==0?1:abs(sin(by)/by)" -scale 128x128! \) \
          -compose multiply -composite -auto-level \
          -evaluate log 100 sinc8x16abs_log100.png

  im_profile -s    sinc8x16abs_log100.png sinc8x16abs_log100_pf.gif
  im_profile -s -v sinc8x16abs_log100.png sinc8x16abs_log100_pfv.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sinc8x16abs_log100.png"
     ><IMG SRC="sinc8x16abs_log100.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sinc8x16abs_log100_pf.gif"
     ><IMG SRC="sinc8x16abs_log100_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sinc8x16abs_log100_pfv.gif"
     ><IMG SRC="sinc8x16abs_log100_pfv.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_diagrams/splot_sinc8x16abs_log100_small.png"
       WIDTH=128 HEIGHT=128
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
</DIV></P></LI>

<LI>The transform of a constant circle of diameter d in an image of size NxN
    is a <A HREF="http://mathworld.wolfram.com/JincFunction.html" >jinc
    function</A>: jinc(r*d/N), where jinc(r)=J1(&pi;r)/(&pi;r) and J1(r) is
    the <A
    HREF="http://mathworld.wolfram.com/BesselFunctionoftheFirstKind.html"
    >Bessel function of the first kind of order one</A>. A jinc function would
    be similar to a circularly symmetric sinc function, but its side lobes are
    much more suppressed than in the sinc function. Also in the jinc function,
    the spacing between successive zeroes is not constant as it was in the
    sinc function. Therefore we use the spacing from the <I>center to the
    first zero</I>, which is Dr=1.22*N/d. The factor of 1.22 is identified in
    <A
    HREF="http://books.google.com/books?id=d8FMlHewYp0C&amp;pg=PA82&amp;lpg=PA82&amp;dq=jinc+function&amp;source=bl&amp;ots=Xtu7S9-s8z&amp;sig=l2UIH8RTbozoiBJv7sTQVI1szqc&amp;hl=en&amp;ei=LZJnSuDRDoXWsgOmmLT9Bg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=8"
    >Theory Of Remote Image Formation</A> and is the first zero in the Bessel
    function. Here is an example of what a jinc function looks like with d=12
    and also a profile of its center row. The scaling factors of plus 0.06613
    and divide by 0.56613 are because the jinc function ranges from -0.06613
    to 0.5 and thus has negative values that would otherwise be clipped in the
    image. Note that the jinc function is very difficult to compute and a
    series approximation to the Bessel function is used to evaluate it, which
    was obtained from <A
    HREF="http://www.amazon.com/Handbook-Mathematical-Functions-Formulas-Graphs/dp/0486612724/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1248309482&amp;sr=1-1"
    >The Handbook Of Mathematical Functions</A> by Abramowitz and Stegun,
    formula 9.4.1 and 9.4.3, p369-370. We speed it up by computing it in 1D as
    a look up table (lut) image and then apply the lut image to a
    radial-gradient using the <A
    HREF="http://www.imagemagick.org/script/command-line-options.php#clut"
    >-clut</A> option. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  N=128
  N2=`convert xc: -format "%[fx:sqrt(2)*$N]" info:`
  d=12
  rad=`convert xc: -format "%[fx:$N/2]" info:`
  rad2=`convert xc: -format "%[fx:sqrt(2)*$rad]" info:`
  fact=`convert xc: -format "%[fx:pi*$d/$N]" info:`
  a0=0.5; a1=-.56249985; a2=.21093573; a3=-.03954289;
  a4=.00443319; a5=-.00031781; a6=.00001109
  b0=.79788456; b1=.00000156; b2=.01659667; b3=.00017105
  b4=-.00249511; b5=.00113653; b6=-.00020033
  c0=-2.35619; c1=.12499612; c2=-.00005650; c3=-.00637879
  c4=.00074348; c5=.00079824; c6=-.00029166
  uu="(xx/3)"
  xxa="($a0+$a1*pow($uu,2)+$a2*pow($uu,4)+$a3*pow($uu,6)"
  xxa="$xxa+$a4*pow($uu,8)+$a5*pow($uu,10)+$a6*pow($uu,12))"
  iuu="(3/xx)"
  vv="($b0+$b1*$iuu+$b2*pow($iuu,2)+$b3*pow($iuu,3)"
  vv="$vv+$b4*pow($iuu,4)+$b5*pow($iuu,5)+$b6*pow($iuu,6))"
  ww="(xx+$c0+$c1*$iuu+$c2*pow($iuu,2)+$c3*pow($iuu,3)"
  ww="$ww+$c4*pow($iuu,4)+$c5*pow($iuu,5)+$c6*pow($iuu,6))"
  xxb="$vv*cos($ww)/(xx*sqrt(xx))"

  convert -size 1x${rad2} gradient: -rotate 90 \
          -fx "xx=$fact*i; (xx&lt;=3)?($xxa+0.06613)/0.56613:($xxb+0.06613)/0.56613" \
          jinc12_lut.png

  convert \( -size ${N2}x${N2} radial-gradient: -negate \
             -gravity center -crop ${N}x${N}+0+0 +repage \) \
          jinc12_lut.png -clut -write jinc12.png \
          -auto-level -evaluate log 10 jinc12_log10.png

  im_profile -s jinc12.png jinc12_pf.gif
  im_profile -s jinc12_log10.png jinc12_log10_pf.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="jinc12.png"
     ><IMG SRC="jinc12.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="jinc12_pf.gif"
     ><IMG SRC="jinc12_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_diagrams/splot_jinc12_small.png"
       WIDTH=128 HEIGHT=128
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
<BR>
  <A HREF="jinc12_log10.png"
     ><IMG SRC="jinc12_log10.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="jinc12_log10_pf.gif"
     ><IMG SRC="jinc12_log10_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_diagrams/splot_jinc12_log10_small.png"
       WIDTH=128 HEIGHT=128
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
</DIV></P>

The absolute value of the jinc function is what corresponds to the magnitude
of the transform. Since the jinc function has positive and negative lobes, when
you take the absolute value, you double the number of oscillations. Therefore,
in the spectrum, the spacing, Dr=1.22*N/d, corresponds to that from the
<I>center to the middle of the first dark trough</I> (which used to be the
location of the first zero). Here is the same example, but with the log of
the absolute value. And we also graph the center row.  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  N=128
  N2=`convert xc: -format "%[fx:sqrt(2)*$N]" info:`
  d=12
  rad=`convert xc: -format "%[fx:$N/2]" info:`
  rad2=`convert xc: -format "%[fx:sqrt(2)*$rad]" info:`
  fact=`convert xc: -format "%[fx:pi*$d/$N]" info:`
  a0=0.5;    a1=-.56249985;    a2=.21093573; a3=-.03954289;
  a4=.00443319;    a5=-.00031781;    a6=.00001109
  uu="(xx/3)"
  xxa="($a0+$a1*pow($uu,2)+$a2*pow($uu,4)+$a3*pow($uu,6)"
  xxa="$xxa+$a4*pow($uu,8)+$a5*pow($uu,10)+$a6*pow($uu,12))"
  b0=.79788456; b1=.00000156; b2=.01659667;
  b3=.00017105; b4=-.00249511; b5=.00113653; b6=-.00020033
  c0=-2.35619; c1=.12499612; c2=-.00005650;
  c3=-.00637879; c4=.00074348; c5=.00079824; c6=-.00029166
  iuu="(3/xx)"
  vv="($b0+$b1*$iuu+$b2*pow($iuu,2)+$b3*pow($iuu,3)"
  vv="$vv+$b4*pow($iuu,4)+$b5*pow($iuu,5)+$b6*pow($iuu,6))"
  ww="(xx+$c0+$c1*$iuu+$c2*pow($iuu,2)+$c3*pow($iuu,3)"
  ww="$ww+$c4*pow($iuu,4)+$c5*pow($iuu,5)+$c6*pow($iuu,6))"
  xxb="$vv*cos($ww)/(xx*sqrt(xx))"

  convert -size 1x${rad2} gradient: -rotate 90 \
          -fx "xx=$fact*i; (xx&lt;=3)?abs($xxa):abs($xxb)" jinc12abs_lut.png

  convert \( -size ${N2}x${N2} radial-gradient: -negate \
             -gravity center -crop ${N}x${N}+0+0 +repage \) \
          jinc12abs_lut.png -clut \
          -auto-level -evaluate log 100 \
          jinc12abs_log100.png

  im_profile -s jinc12abs_log100.png jinc12abs_log100_pf.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="jinc12abs_log100.png"
     ><IMG SRC="jinc12abs_log100.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="jinc12abs_log100_pf.gif"
     ><IMG SRC="jinc12abs_log100_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_diagrams/splot_jinc12abs_log100_small.png"
       WIDTH=128 HEIGHT=128
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>
</DIV></P></LI>

<LI>The transform of a Gaussian function of sigma=d in an image size NxN is a
    Gaussian function. The sigma of the Gaussian function in the spectrum will
    be sigma=N/(2d). See <A
    HREF="http://mathworld.wolfram.com/FourierTransformGaussian.html"
    >Fourier Transform Gaussian</A>.</LI>

<LI>The phase looks uninteresting, but contains more information than the
    magnitude with regard to reconstructing the original image as something
    visually recognizable.</LI>

<LI>Convolution in the spatial domain is equivalent to multiplication
in the frequency domain.</LI>

<LI>Other properties and characteristics are defined mathematically at either
    <A
    HREF="http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Properti-2.html"
    >http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Properti-2.html</A>
    or <A HREF="http://en.wikipedia.org/wiki/Fourier_transform"
    >http://en.wikipedia.org/wiki/Fourier_transform</A></LI>

</UL>
</TD></TR></TABLE></P>

&nbsp;</TD></TR>
<TR><TD WIDTH=100% BGCOLOR="#800000" COLSPAN=5
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR></TABLE>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="ft_applications"></A>
<H2>Practical Applications</H2>

OK, now that we have covered the basics, what are the practical applications
of using the Fourier Transform? </P>

Some of the things that can be done include: 1) increasing or decreasing the
contrast of an image, 2) blurring, 3) sharpening, 4) edge detection and
5) noise removal.

<A NAME="contrast"></A>
<H3>Changing The Contrast Of An Image - Coefficient Rooting</H3>

One can adjust the contrast in an image by performing the forward Fourier
transform, raising the magnitude image to a power and then using that with the
phase in the inverse Fourier transform. To increase, the contrast, one uses an
exponent slightly less than one and to decrease the contrast, one uses an
exponent slightly greater than one. So lets first increase the contrast on the
Lena image using an exponent of 0.9 and then decrease the contrast using an
exponent of 1.1. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena.png -fft \
          \( -clone 0 -evaluate pow 0.9 \) -delete 0 \
          +swap -ift lena_plus_contrast.png

  convert lena.png -fft \
          \( -clone 0 -evaluate pow 1.1 \) -delete 0 \
          +swap -ift lena_minus_contrast.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_plus_contrast.png"
     ><IMG SRC="lena_plus_contrast.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_minus_contrast.png"
     ><IMG SRC="lena_minus_contrast.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

However doing this to the original image would also have the same effect as
doing this to the original image.  That is a global modification of the
magnitudes has the same effect as if you did a global modification of the
original image. </P>


<A NAME="blurring"></A>
<H3>Blurring An Image - Low Pass Filtering</H3>

One of the most important properties of Fourier Transforms is that convolution
in the spatial domain is equivalent to simple multiplication in the frequency
domain. In the spatial domain, one uses small, square-sized, simple
convolution filters (kernels) to blur an image with the <A
HREF="../option_link.cgi?convole" >-convole</A> option. This is called a low
pass filter. The simplest filter is just a an equally-weighted, square array.
That is all the values are ones, which are normalized by dividing by their sum
before applying the convolution.  This is equivalent to a local or
neighborhood average.  Another low pass filter is the Gaussian-weighted,
circularly shaped filter provided by either <A
HREF="../option_link.cgi?gaussian-blur" >-gaussian-blur</A> or <A
HREF="../option_link.cgi?blur" >-blur</A>. </P>

In the frequency domain, one type of low pass blurring filter is just
a constant intensity white circle surrounded by black. This would be similar
to a circularly shaped averaging convolution filter in the spatial domain.
However, since convolution in the spatial domain is equivalent to
multiplication in the frequency domain, all we need do is perform a forward
Fourier transform, then multiply the filter with the magnitude image and
finally perform the inverse Fourier transform. We note that a small sized
convolution filter will correspond to a large circle in the frequency domain.
Multiplication is carried out via <A HREF="../option_link.cgi?composite"
>-composite</A> with a <A HREF="../option_link.cgi?compose" >-compose</A>
multiply setting. </P>

So lets try doing this with two sizes of circular filters, one of diameter 40
(radius 20) and the other of diameter 28 (radius 14). </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 128x128 xc:black -fill white \
          -draw "circle 64,64 44,64" circle_r20.png
  convert lena.png -fft \
       \( -clone 0 circle_r20.png -compose multiply -composite \) \
       \( +clone -evaluate log 10000 -write lena_blur_r20_spec.png +delete \) \
       -swap 0 +delete -ift lena_blur_r20.png

  convert -size 128x128 xc:black -fill white \
          -draw "circle 64,64 50,64" circle_r14.png
  convert lena.png -fft \
       \( -clone 0 circle_r14.png -compose multiply -composite \) \
       \( +clone -evaluate log 10000 -write lena_blur_r14_spec.png +delete \) \
       -swap 0 +delete -ift lena_blur_r14.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ROWSPAN=2>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_spectrum.png"
     ><IMG SRC="lena_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="x">
</TD><TD>
  <A HREF="circle_r20.png"
     ><IMG SRC="circle_r20.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_blur_r20_spec.png"
     ><IMG SRC="lena_blur_r20_spec.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_blur_r20.png"
     ><IMG SRC="lena_blur_r20.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="circle_r14.png"
     ><IMG SRC="circle_r14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_blur_r14_spec.png"
     ><IMG SRC="lena_blur_r14_spec.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_blur_r14.png"
     ><IMG SRC="lena_blur_r14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

So we see that the image that used the smaller diameter filter produced more
blurring. We also note the 'ringing' or 'ripple' effect near edges in the
resulting images. This occurs because the Fourier Transform of a circle, as we
saw earlier, is a jinc function, which has decreasing oscillations as it
progresses outward from the center. Here however, the jinc function and the
oscillations are in the spatial domain rather than in the frequency domain, as
we had demonstrated earlier above. </P>

So what can we do about this? The simplest thing is to taper the edges of the
circles using various <A HREF="http://en.wikipedia.org/wiki/Window_function"
>Windowing Functions</A>. Alternately, one can use a filter
such as a Gaussian shape that is already by definition tapered. </P>

So lets do the latter and use two Gaussian blurred circles to remove
most of the sever 'ringing' effects.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_r20.png -blur 0x4 -auto-level gaussian_r20.png
  convert lena.png -fft \
       \( -clone 0 gaussian_r20.png -compose multiply -composite \) \
       \( +clone -evaluate log 10000 -write lena_gblur_r20_spec.png +delete \) \
       -swap 0 +delete -ift lena_gblur_r20.png

  convert circle_r14.png -blur 0x4 -auto-level gaussian_r14.png
  convert lena.png -fft \
       \( -clone 0 gaussian_r14.png -compose multiply -composite \) \
       \( +clone -evaluate log 10000 -write lena_gblur_r14_spec.png +delete \) \
       -swap 0 +delete -ift lena_gblur_r14.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ROWSPAN=2>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_spectrum.png"
     ><IMG SRC="lena_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="x">
</TD><TD>
  <A HREF="gaussian_r20.png"
     ><IMG SRC="gaussian_r20.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_gblur_r20_spec.png"
     ><IMG SRC="lena_gblur_r20_spec.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_gblur_r20.png"
     ><IMG SRC="lena_gblur_r20.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="gaussian_r14.png"
     ><IMG SRC="gaussian_r14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_gblur_r14_spec.png"
     ><IMG SRC="lena_gblur_r14_spec.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_gblur_r14.png"
     ><IMG SRC="lena_gblur_r14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

This of course is much better. </P>

The ideal low-pass filter is not to blur circles at all, but actually use a
proper gaussian curve of <I>sigma</I> rather than a <I>radius</I>. </P>

Of course in this example we ended up doing a blur, to do a blur!  However the
blur pattern that is multiplied against the FFT magnitude image used is fixed,
and could in fact be retrieved from a pre-generated cache. Also the
multiplying image does not need to be the full size of the original image, you
can use a smaller image.  As such the above can be a lot faster for large
images, and in the case of handling lots of images. </P>

The more important point is for large strong blurs, the frequency domain image
is small, and only does a single multiply, rather then having to average lots
of pixels, for each and every pixel in the original image. </P>

For small sized blurs you may be better with the more direct convolution blur.
</P>

<A NAME="edge_detection"></A>
<H3>Detecting Edges In An Image - High Pass Filtering</H3>

In the spatial domain, high pass filters that extract edges from an image are
often implemented as convolutions with positive and negative weights such that
they sum to zero. </P>

Things are much simpler in the frequency domain. Here a high pass filter is
just the negated version of the low pass filter. That is where the low pass
filter is bright, the high pass filter is dark and vice versa. So in
ImageMagick, all we need do is to <A HREF="../option_link.cgi?negate"
>-negate</A> the low pass filter image. </P>

So lets apply high pass filters to the Lena image  using a circle image.
And then again using a purely gaussian curve. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_r14.png -negate circle_r14i.png
  convert lena.png -fft \
       \( -clone 0 circle_r14i.png -compose multiply -composite \) \
       \( +clone -evaluate log 10000 -write lena_edge_r14_spec.png +delete \) \
       -delete 0 +swap -ift -normalize lena_edge_r14.png

  convert -size 128x128 xc: -draw "point 64,64" -blur 0x14 \
          -auto-level   gaussian_s14i.png
  convert lena.png -fft \
       \( -clone 0 gaussian_s14i.png -compose multiply -composite \) \
       \( +clone -evaluate log 10000 -write lena_edge_s14_spec.png +delete \) \
       -delete 0 +swap -ift -normalize lena_edge_s14.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ROWSPAN=2>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_spectrum.png"
     ><IMG SRC="lena_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="x">
</TD><TD>
  <A HREF="circle_r14i.png"
     ><IMG SRC="circle_r14i.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_edge_r14_spec.png"
     ><IMG SRC="lena_edge_r14_spec.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_edge_r14.png"
     ><IMG SRC="lena_edge_r14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="gaussian_s14i.png"
     ><IMG SRC="gaussian_s14i.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_edge_s14_spec.png"
     ><IMG SRC="lena_edge_s14_spec.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_edge_s14.png"
     ><IMG SRC="lena_edge_s14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>


Carefully examining these two results, we see that the simple circle is not
quite as good as the gaussian, as it has 'ringing' artifacts and is not quite
as sharp. </P>

<A NAME="sharpening"></A>
<H3>Sharpening An Image - High Boost Filtering</H3>

The simplest way to sharpen an image is to high pass filter it (without
the normalization stretch) and then blend it with the original image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lena.png -fft \
       \( -size 128x128 xc: -draw "point 64,64" -blur 0x14 -auto-level \
          -clone 0 -compose multiply -composite \) \
       -delete 0 +swap -ift \
       lena.png -compose blend -set option:compose:args 100x100 -composite \
       lena_sharp14.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lena.png"
     ><IMG SRC="lena.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="lena_sharp14.png"
     ><IMG SRC="lena_sharp14.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Here a high pass filter, is done in the frequency domain and the result
transformed back to the spatial domain where it is blended with the original
image, to enhance the edges of the image. </P>


<A NAME="noise_removal"></A>
<H3>Noise Removal - Notch Filtering</H3>

Many noisy images contain some kind of patterned noise. This kind of noise is
easy to remove in the frequency domain as the patterns show up as either a
pattern of a few dots or lines. Recall a simple sine wave is a repeated
pattern and shows up as only 3 dots in the spectrum. </P>

In order to remove this noise, one simply, but unfortunately, has to manually
mask (or notch) out the dots or lines in the magnitude image. We do this by
transforming to the frequency domain, create a grayscale version of the
spectrum, mask the dots or lines, threshold it, multiply the binary mask image
with the magnitude image and then transform back to the spatial domain. </P>

Lets try this on the <A
HREF="http://www.mediacy.com/index.aspx?page=AH_FFTExample"
>clown image</A>, which contains a diagonally striped
dither-like pattern. First we transform the clown image to create its
magnitude and phase images. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert clown.jpg -fft \
          \( +clone  -write clown_phase.png +delete \) +delete \
          -write clown_magnitude.png  -colorspace gray \
          -auto-level -evaluate log 100000  clown_spectrum.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=center>
  <A HREF="clown.jpg"
     ><IMG SRC="clown.jpg"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Original
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="clown_spectrum.png"
     ><IMG SRC="clown_spectrum.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Spectrum
</TD><TD ALIGN=center>
  <A HREF="clown_phase.png"
     ><IMG SRC="clown_phase.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Phase
</TD></TR></TABLE>
</DIV></P>

We see that the spectrum contains four bright star-like dots, one in each
quadrant.  These unusal points represent the pattern in the image we want to
get rid of. </P>

The bright dot and lines in the middle of the image are of no concern as they
represent the DC (average image color), and effects of the edges from the
image, and should not be modified. </P>

Note that when generating the spectrum image I forced the resulting image to
be a pure gray-scale image. This is so I can now loaded the image into an
editor, and using any non-gray color (such as red), I masked out the area of
those 4 star like patterns. </P>

When finished editing I can extract the areas I colored, like this...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert clown_spectrum_edited.png clown_spectrum.png \
          -compose difference -composite \
          -threshold 0 -negate clown_spectrum_mask.png
</CODE></PRE></TD></TR></TABLE>
<!-- This is the inverse of the above -- That is I am cheating :-)
<CODE EXECUTE>
  convert clown_spectrum_mask.png -negate -background red -alpha shape \
          clown_spectrum.png +swap -composite  clown_spectrum_edited.png
</CODE> -->
  <A HREF="clown_spectrum_edited.png"
     ><IMG SRC="clown_spectrum_edited.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="clown_spectrum_mask.png"
     ><IMG SRC="clown_spectrum_mask.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Now we simply multiply the mask with the magnitude and use the result with the
original phase image to transform back to the spatial domain. We display the
original image next to it for comparison </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert clown_magnitude.png clown_spectrum_mask.png \
          -compose multiply -composite \
          clown_phase.png -ift clown_filtered.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="clown.jpg"
     ><IMG SRC="clown.jpg"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="clown_filtered.png"
     ><IMG SRC="clown_filtered.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

A very good result.  But we can do even better. </P>

As you saw in the previous examples, simple 'circles' are not particularly
friendly to a FFT image, so lets blur the mask slightly...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert clown_spectrum_mask.png \
          -blur 0x5 -level 50x100%  clown_mask_blurred.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="clown_mask_blurred.png"
     ><IMG SRC="clown_mask_blurred.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

And filter the clown, this time re-generating the FFT images in memory.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert clown.jpg -fft \
          \( -clone 0 clown_mask_blurred.png -compose multiply -composite \) \
          -swap 0 +delete -ift clown_filtered_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="clown_filtered_2.png"
     ><IMG SRC="clown_filtered_2.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A simply amazing result! And one that could posibly be improved further by
adjusting that mask to fit the 'star' shapes better. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

We can even take the difference between the original and the result to create
an image of the areas where noise was removed.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert clown.jpg clown_filtered_2.png -compose difference \
          -composite -normalize clown_noise.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="clown_noise.png"
     ><IMG SRC="clown_noise.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Lets try this on an another example. This time on a "Twigs" image found on the
<A HREF="http://www.roborealm.com/help/FFT.php" >RoboRealm</A> website, which
contains an irregular pattern of horizontal and vertical stripes. </P>

Again we extract a grey-scale spectrum image, just as we did before.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert twigs.jpg -fft +delete -colorspace gray \
          -auto-level -evaluate log 100000 twigs_spectrum.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="twigs.jpg"
     ><IMG SRC="twigs.jpg"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="twigs_spectrum.png"
     ><IMG SRC="twigs_spectrum.png"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In this case, as the noise in the image is horizontally and vertically
oriented, this shows up as thick horizontal and vertical bands along the
center lines but not in the actual center of the image. </P>

Again we mask out the parts using a image editor, this time using a 'blue'
color (it really doesn't matter which color is used)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert twigs_spectrum_edited.png twigs_spectrum.png \
          -compose difference -composite \
          -threshold 0 -negate twigs_spectrum_mask.png
</CODE></PRE></TD></TR></TABLE>
<!-- This is the inverse of the above -- That is I am cheating :-)
<CODE EXECUTE>
  convert twigs_spectrum_mask.png -negate -background blue -alpha shape \
          twigs_spectrum.png +swap -composite  twigs_spectrum_edited.png
</CODE> -->
  <A HREF="twigs_spectrum_edited.png"
     ><IMG SRC="twigs_spectrum_edited.png"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="twigs_spectrum_mask.png"
     ><IMG SRC="twigs_spectrum_mask.png"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Now we again multiply the mask with the FFT magnitude image, and reconstruct
the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert twigs.jpg -fft \
          \( -clone 0 twigs_spectrum_mask.png -compose multiply -composite \) \
          -swap 0 +delete  -ift twigs_filtered.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="twigs.jpg"
     ><IMG SRC="twigs.jpg"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="twigs_filtered.png"
     ><IMG SRC="twigs_filtered.png"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And we can take the difference between the original and the result to create
an image of the areas where noise was removed. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert twigs.jpg twigs_filtered.png -compose difference -composite \
          -normalize twigs_noise.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="twigs_noise.png"
     ><IMG SRC="twigs_noise.png"   WIDTH=256 HEIGHT=256
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<!-- <CODE EXECUTE SKIP=0>
</CODE> -->

<A NAME="advanced"></A>
<H2>Advanced Applications</H2>

Some of the other more advanced applications of using the Fourier Transform
include: 1) deconvolution (deblurring) of motion blurred and defocused images
and 2) normalized cross correlation to find where a small image best matches
within a larger image. </P>

<H3><I>Coming Soon!</I></H3>


Examples of FFT Multiplication moved to a
<A HREF="fft_math/">sub-directory</A>

</DIV>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 22 July 2000 <BR>
Updated: 13 August 2009 <BR>
Author: <A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A>,
        &lt;fmw at alink dot net&gt;
with editing and formating by
        <A HREF="http://www.ict.griffith.edu.au/anthony/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>http://www.imagemagick.org/Usage/fourier/</CODE>
</ADDRESS></BODY></HTML>

