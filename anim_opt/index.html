<HTML><HEAD>
<TITLE>Animation Optimization -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/anim_opts/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Animation Optimization</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#intro"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Introduction to Optimization</A>
<DD><A HREF="#optimize"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >General Purpose GIF Optimizer of ImageMagick</A>
<DD><A HREF="#frame_opt"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Frame Optimization</A>
    <UL>
    <LI><A HREF="#optframe"
        >Basic Frame Optimization</A>
    <LI><A HREF="#repeated_frame"
        >No Pixel Overlay</A> - repeated image every second frame
    <LI><A HREF="#hole"
        >Moving Hole Animation</A>  - a difficult to frame optimize animation
    <LI><A HREF="#doubling"
        >Frame Doubling</A>
    <LI><A HREF="#optimizeplus"
        >Layer Optimize Plus</A>
    <LI><A HREF="#removedups"
        >Remove Duplicate Frames</A>
    <LI><A HREF="#splitting"
        >Splitting Frame Updates</A>
    <LI><A HREF="#removezero"
        >Remove Zero Delay Frames</A>
    <LI><A HREF="#frame_results"
        >Frame Optimization Results and Summary</A>
    </UL>
<DD><A HREF="#semitrans_opt"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Semi-Transparency Handling</A>
<DD><A HREF="#color_opt"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Color Optimization</A>
    <UL>
    <LI><A HREF="#color_problem"
        >GIF Color Problem</A>
    <LI><A HREF="#speed"
        >Speed Animation</A>       - an animation with too many colors
    <LI><A HREF="#color_frame_first"
        >Frame Opt Before Color Opt?</A>
    <LI><A HREF="#color_fuzz"
        >Fuzzy Color Optimization</A>
    <LI><A HREF="#colortables"
        >Single Global Color Table</A>
    <LI><A HREF="#dithering"
        >Dithering Colors</A>
    </UL>
<DD><A HREF="#compress_opt"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Compression Optimization</A>
    <UL>
    <LI><A HREF="#opt_trans"
        >Transparency Optimization</A>
    <LI><A HREF="#opt_lzw"
        >LZW Optimization</A>
    <LI><A HREF="#opt_lzw_lossy"
         >Lossy LZW Optimization <FONT SIZE=-1>- (non-IM)</FONT></A>
    <LI><A HREF="#opt_lzw_dithered"
        >Ordered Dithered LZW Optimization</A>
    </UL>
<DD><A HREF="#minor_opt"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Minor Optimizations</A>
<DD><A HREF="#gif_links"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Other Sources of Information on GIF Optimization</A>
</DL>

These examples start to make use of the <A HREF="../anim_basics/" >Basic
Animation Handling</A>, to try to optimize the final display and file size
of an animation.  This is especially important for complex GIF animations
where smaller sub-frame overlays can be used, as well as three types of
disposal methods controlling how an animation is handled. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="intro"></A>
<H2>Introduction to Animation Optimization</H2>

Optimizing an animation is not easy, especially a GIF animation that has color
restrictions, as well as a choice of different frame disposal techniques, and
the ability to use smaller 'sub-frame' overlays from one frame to the next.
</P>

When optimizing animation you should try to optimize them in the following
order.
<UL>
<LI><A HREF="#minor_opt"        >Minor Optimizations</A>
<LI><A HREF="#semitrans_opt"    >Semi-Transparency Handling</A>
<LI><A HREF="#color_opt"        >Color Optimizations</A>
<LI><A HREF="#frame_opt"        >Frame Optimizations</A>
<LI><A HREF="#compress_opt"     >Compression Optimizations</A>
<LI><A HREF="#colortables"      >Single Global Color Table</A>
</UL></P>

That however is not the order we will look at these optimization techniques.
For GIF animations <A HREF="#frame_opt" >Frame Optimization</A> is the most
basic optimization technique, and where the most gains can be made. As such it
will be looked at first. </P>

Probably the hardest aspect of optimization that users have trouble with is
<A HREF="#color_opt" >Color Optimizations</A> caused by the color limitations
of the GIF animations.  One aspect of this <A HREF="#colortables" >Single
Global Color Table</A> has to be done as a the last step before saving to GIF
or you may loose the operators effect on the final GIF file save. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="optimize"></A>
<H2>General Purpose GIF Optimizer of ImageMagick</H2>

The "<CODE><A HREF="../option_link.cgi?layers" >-layers</A></CODE>" method
'<CODE><B>Optimize</B></CODE>' will use a number of the techniques, that we
will discuss in detail below, to attempt to optimize a GIF animation in a
single reasonable step.  </P>

Currently this option is equivalent to (in order)...
<UL>
<LI>A <A HREF="../anim_basics/#coalesce" >Coalesce</A> the Animation.
<LI>Basic <A HREF="#optframe" >Frame Optimization</A>
<LI>and <A HREF="#opt_trans" >Transparency Optimization</A>
</UL>At which point you can immediately save the GIF animation. </P>

These are reasonably safe optimization steps that can be applied to most
animation sequences, however there is no guarantee, that it will result in
a smaller GIF animation.  This is particularly true of an raw video sequence
where a <A HREF="#opt_trans" >Transparency Optimization</A> will generally
result in a worsening of the LZW compression ratio. </P>

However for most GIF animations, involving cartoon like images, the
'<CODE>Optimize</CODE>' operator should produce a good well optimized
animation. </P>

The operator however is still in development, and in future is likely to also
include extra standard optimization steps, such as...
<UL>
<LI>A 50% Threshold of the alpha channel, just as the IM does normally does
    when saving to the GIF file format, to remove semi-transparent pixels. You
    can still do the semi-transparency handling yourself before hand to
    override this, if you like. See <A HREF="../formats/#boolean_trans" >GIF
    Boolean Transparency</A> for more detail.
<LI>Some type of <A HREF="#color_opt" >Color Optimization</A> technique.
    Exactly what, is still to be decided, and may be selected depending on the
    animation and the number of colors involved. <I>Suggestions Welcome</I>.
<LI>A <A HREF="#colortables" >Single Global Color Table</A>,
    "<CODE><A HREF="../option_link.cgi?map" >+map</A></CODE>" operation.
</UL></P>

In other words, it is hoped that '<CODE>Optimize</CODE>' will eventually
become the IM generic GIF animation optimizer, for quick and easy use by IM
users.  Until then be careful of its use, especially in scripts as it will
change.  </P>

Of course as many optimization steps may not be worth the effort for a
specific animation. This option will also likely become quite slow. </P>

This is the plan, and the goal that this IM Examples section, was looking
toward.  </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="frame_opt"></A>
<H2>Frame Optimizations</H2>

Frame optimization is based on overlaying a smaller sub-image
rather than a complete overlay of the whole image. This obviously produces
a smaller number of pixels and thus a smaller file on disk, to being sent
across the network.  Also overlaying a smaller frame means the client computer
does not have to do as much work in changing pixels on screen. </P>

However there are different disposal methods available in the GIF format to
handle the last frame displayed, and that can result in different size
overlays.  Not only that but it is possible to split up the overlays into
multiple parts, or update actions, bring about a more complex but more
optimized animation. </P>

Because of the complexity of doing frame optimizations, any existing frame
optimizations are typically always removed first by using "<CODE><A
HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" operation. See  <A
HREF="../anim_basics/#coalesce" >Coalesce Examples</A>. </P>

Naturally that means any hand optimizations that may have existed are also
removed, so some caution is advised. </P>


<A NAME="optframe"></A>
<H3>Basic Frame Optimization</H3>

The "<CODE><A HREF="../option_link.cgi?deconstruct" >-deconstruct</A></CODE>"
method will produce a basic frame optimization for a GIF animation.  However
as was shown in the <A HREF="../anim_basics/#deconstruct" >Deconstruct
Examples</A> of the previous section, this operator does not work with all GIF
animations when transparent pixels are involved.  Specifically when
an animation clears any colored pixel to transparency. </P>

That is it will only work with <A HREF="#overlay" >Overlay Animations</A>.
</P>

The "<CODE><A HREF="../option_link.cgi?layers" >-layers</A></CODE>" method
'<CODE><B>OptimizeFrame</B></CODE>' is designed to be a GIF Frame Optimizer,
which will try to find the smallest sub-frames overlay images, using any GIF
disposal method. </P>

The result is generally a <A HREF="#mixed" >Mixed Disposal Animation</A>
though often it will also generate a <A HREF="#clear" >Cleared Frame
Animations</A> or <A HREF="#overlay" >Pure Overlay Animations</A>, if that
was determined to be the best solution for the specific animation. </P>

Remember the input animation must be a '<I>coalesced animation</I>', so it
consists of a sequence of complete image frames, all the same size, without
any canvas offsets.  Of course any existing dispose methods in coalesced
animation is completely irrelevant, and will be ignored by the
'<CODE>OptimizeFrame</CODE>' method. </P>

For example, lets try this with a <A HREF="../anim_basics/#previous" >Dispose
Previous Animation</A>, created in the previous section.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  canvas_prev.gif -coalesce  -layers OptimizeFrame  optframe.gif
  gif_anim_montage optframe.gif optframe_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="optframe.gif"
     ><IMG SRC="optframe.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center><NOBR>
  <A HREF="coalesce_frames.gif"
     ><IMG SRC="coalesce_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
    <IMG SRC="../img_www/space.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
<BR><IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="optframe_frames.gif"
     ><IMG SRC="optframe_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

As you can see "<CODE><A HREF="../option_link.cgi?layers" >-layers</A>
OptimizeFrame</CODE>' correctly returned our animation back into its original
frame optimized form, using <A HREF="../anim_basics/#previous" >Previous
Disposal</A>. </P>

This optimization even works properly for the trickier to handle <A
HREF="../anim_basics/#background" >Background Dispose Animations</A>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  canvas_bgnd.gif -coalesce  -layers OptimizeFrame  optframe_bgnd.gif
  gif_anim_montage optframe_bgnd.gif optframe_bgnd_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="optframe_bgnd.gif"
     ><IMG SRC="optframe_bgnd.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="optframe_bgnd_frames.gif"
     ><IMG SRC="optframe_bgnd_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The animation is perfectly frame optimized using <A
HREF="../anim_basics/#background" >Background Disposal</A>. </P>


This operator will work correctly for all GIF animations, and will generally
return the best possible simple 'dispose and frame optimization' possible.
</P>

<BR>

Now for some bad news about any type of simple frame optimization, such as
what IM provides... </P>

While '<CODE><A HREF="#optframe" >OptimizeFrame</A></CODE>' returns the
best possible frame optimization for a given animation that IM can figure out,
there are is a number of special cases where it does not do well. </P>

These include... <UL>
<LI>Animations where pixel clearing (returning to transparency) is needed, but
    the frame overlays are too large to efficiently clear the small areas of
    pixels that needs to be cleared (see the <A HREF="#hole" >move hole
    animation</A> below). </P>

<LI>Animations involving two or more small areas of change that are distantly
    separated. These are actually quite common, and horrible to frame
    optimize. (See <A HREF="#splitting" >Splitting Frame Updates</A> below)
    </P>

<LI>Animations with very complex backgrounds that remain static for long
    periods (more than 3 frames), but then change slightly before remain
    static for another long period, etc., etc., etc...  Or a static background
    that becomes greatly obscured for a very short period. </P>

    It can be near impossible for any computer algorithm to figure out the
    'best' frame optimization in this complex situation (IE: What should be
    regarded as a static background?).  Only humans with their intuitive grasp
    on what they see, can generate a good optimally frame overlay sequence in
    these cases. </P>

</UL></P>

<I>Examples of difficult to optimize animations wanted, please contribute.</I>
</P>

If you find an example of an animation which IM fails to produce a good
optimization, please mail it to me for further study.  This is how new
techniques and possible automatic solutions can be developed. I will naturally
publish your name as a contributor. </P>



<A NAME="repeated_frame"></A>
<H3>No Pixel Overlay
<FONT SIZE=-1>-  repeated image every second frame</FONT></H3>

<A HREF="paddleball.gif"
   ><IMG SRC="paddleball.gif"     WIDTH=80 HEIGHT=89
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[animation]"></A>


Sometimes the best optimization for an image involves not overlaying any
pixels at all! </P>

For example to the right is a simple animation, contributed by
nixscripter.  If we look at its frames you can see it is not very optimized.
But notice that every second frame of the animation is simply repeated.

<BR CLEAR=all>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  gif_anim_montage paddleball.gif paddleball_frames.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="paddleball_frames.gif"
     ><IMG SRC="paddleball_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

After frame optimizing it we get a very special GIF disposal sequence.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  paddleball.gif -coalesce -layers OptimizeFrame  paddleball_opt.gif
  gif_anim_montage paddleball_opt.gif paddleball_opt_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="paddleball_opt.gif"
     ><IMG SRC="paddleball_opt.gif"          WIDTH=80 HEIGHT=89
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="paddleball_opt_frames.gif"
     ><IMG SRC="paddleball_opt_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

What is happening is that rather than overlaying the original frame IM chose
to recover the first image using a '<A HREF="../anim_basics/#previous"
>Previous</A> GIF disposal. As that recovered frame is left as is, there are
no changed pixels. So the sub-frame overlay gets reduced nothing. </P>

Unfortunately, neither IM or the GIF format allow you have a zero sized image,
so a special one transparent pixel minimal image is used instead. This image
is known as a <A HREF="../crop/#crop_missed" >Missed Image</A> as it is also
extensively used when "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" 'misses' the actual image data, producing the same result.
</P>

This image, in effect, only preserves the frames meta-data, such as: <A
HREF="../anim_basics/#dispose" >Dispose Method</A>, <A
HREF="../anim_basics/#delay" >Time Delay</A>, and <A
HREF="../anim_basics/#loop" >Loop Iterations</A>.  As such it is an essential
part of the animation, even though it is 'empty'. </P>

So by overylaying a bare minimal single transparent pixel, IM saved a huge
amount of space (and time) in this animation.

<BR>

<A NAME="hole"></A>
<H3>Moving Hole Animation
<FONT SIZE=-1>-  difficult to frame optimize </FONT></H3>

Here is one extreme case of GIF animation that does not frame optimize very
well by any normal optimization method. </P>

This animation basically consists of a simple unchanging background image
but with a transparent 'hole' through that background that changed position
from frame to frame. </P>

To create it I need to make a coalesced image sequence, where I cut up a hole
in a fixed background image, using <A HREF="../anim_mods/#compose" >Layer
Alpha Composition</A>.  I also used a "<CODE><A
HREF="../option_link.cgi?antialias" >+antialias</A></CODE>" switch to ensure only
four colors are used three blues and the transparency. So we don't need to
deal with <A HREF="#colors" >Color Optimization Problems</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=middle><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
                  <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert +antialias -size 100x100 -delay 100 xc:SkyBlue -loop 0 \
          -fill DodgerBlue -draw 'circle 50,50 15,25' \
          -fill RoyalBlue  -draw 'circle 50,50 30,25' \
          null: \( -size 100x100 xc:none -draw 'circle 40,25 27,22' \) \
                \( +clone -rotate 90 \) \( +clone -rotate 90 \) \
                \( +clone -rotate 90 \) -compose DstOut -layers Composite \
          -set dispose background  moving_hole.gif
  gif_anim_montage moving_hole.gif moving_hole_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moving_hole.gif"
     ><IMG SRC="moving_hole.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_frames.gif"
     ><IMG SRC="moving_hole_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_size.txt>
    ls -l moving_hole.gif | awk '{printf "%d", $5}'
</CODE> -->

As you can see the animation works, with a round 'hole' showing the background
color of this page, producing an animation file of
  <A HREF="moving_hole_size.txt"
     ><IMG SRC="moving_hole_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes in size. </P>

So lets try a straight-forward frame optimization for this animation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole.gif  -layers OptimizeFrame  moving_hole_opt.gif
  gif_anim_montage moving_hole_opt.gif moving_hole_opt_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="moving_hole_opt.gif"
     ><IMG SRC="moving_hole_opt.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_opt_frames.gif"
     ><IMG SRC="moving_hole_opt_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Hang on, nothing happened!  The best optimization IM could achieve was no
change at all!  Is the above coalesced version of this animation its most
optimal? </P>

Well for the animation as it stands... Yes, this really is the best simple
optimization that can be achieved by pure frame disposal optimization!  Not
good. </P>

The problem is that for a GIF animation to 'clear' or 'erase' the pixels drawn
by previous frames, it needs to use a '<A HREF="../anim_basics/#background"
>Background</A>' dispose method. Though in some special situations a '<A
HREF="../anim_basics/#previous" >Previous</A>' dispose method can also be
used. </P>

However '<A HREF="../anim_basics/#background" >Background</A>' dispose only
can clear areas that were just overlaid.  As the first frame was a complete
overlay of the whole image, the whole image will be cleared. Even though only
a small section of the animation needs to have its pixels cleared. </P>

As a consequence the whole of the second frame needs to be overlaid, even
though most of that frame was just previously displayed!  This horrible
catch-22 situation continues all the way across the rest of the animation,
producing no basic frame optimizations.  </P>

I did say this animation would be difficult to frame optimize. </P>

<A NAME="doubling"></A>
<H3>Frame Doubling
<FONT SIZE=-1>- a method to frame optimize 'holes'</FONT></H3>

All is not lost however.  By adding some extra frames to the animation, you
can give the '<CODE><A HREF="#optframe" >OptimizeFrame</A></CODE>'
method some room in which to make better use of the GIF disposal methods
available.  </P>

Here for example we add an extra frame by doubling up the first image, but
giving it a zero time delay so as not to change the overall timings of the
animation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole.gif[0] -set delay 0   moving_hole.gif \
          -layers OptimizeFrame    moving_hole_dup.gif
  gif_anim_montage moving_hole_dup.gif moving_hole_dup_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="moving_hole_dup.gif"
     ><IMG SRC="moving_hole_dup.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_dup_frames.gif"
     ><IMG SRC="moving_hole_dup_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_dup_size.txt>
    ls -l moving_hole_dup.gif | awk '{printf "%d", $5}'
</CODE> -->
By doubling the first frame the animation was now reduced from
  <A HREF="moving_hole_size.txt"
     ><IMG SRC="moving_hole_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes down to
  <A HREF="moving_hole_dup_size.txt"
     ><IMG SRC="moving_hole_dup_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes in size.  So even though the animation now has five frames, it is now
much smaller in overall size, because of the massive reduction in the size of
the sub-frame image overlays. </P>

Doubling essentially separates the pixel clearing function of the dispose
method, from the pixel overlaying function performed by the next frame.  Both
the dispose and the overlay are done as part of the same frame update by GIF
animation programs, so no loss of speed or quality should be noticeable.  </P>

This is a complex and tricky technique, and one that is rarely seen or
understood by GIF animation designers or GIF optimization programs, but its
benefits are well worth it then it is needed.  </P>

However the reduction in sub-frame image sizes only lasts for a short time, as
later frames having to also clear out pixel for the next frame, so the frames
become large again to continue to clear out later pixels.  That is because
pixel clearing always result in larger frames, never smaller. </P>

So lets try and double <I>all</I> the frames (except the last which never needs
doubling) to see how that affects the final image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole.gif  \( -clone 0--1 -set delay 0 \) \
          +delete -insert 2 -insert 1 -insert 0 \
          -layers OptimizeFrame  moving_hole_double.gif
  gif_anim_montage x2 moving_hole_double.gif moving_hole_double_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="moving_hole_double.gif"
     ><IMG SRC="moving_hole_double.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_double_frames.gif"
     ><IMG SRC="moving_hole_double_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_double_size.txt>
  ls -l moving_hole_double.gif | awk '{printf "%d", $5}'
</CODE> -->
As you can see while we have almost twice as many frames, all the image
sizes are much smaller, producing an animation that is
  <A HREF="moving_hole_double_size.txt"
     ><IMG SRC="moving_hole_double_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes in size, a smaller result, though not nearly as big a saving as the
first single frame doubling we performed. </P>

So that you can follow what is happening, the '<CODE><A
HREF="../anim_basics/#background" >Background</A></CODE>' frame is an exact
duplicate of the previous frame, making no change to what is being displayed.
However, it defines the area of the animation that needs to cleared before the
next frame image is overlaid.  </P>

The following '<CODE><A HREF="../anim_basics/#none" >None</A></CODE>' frame
then fills in the pixels that need to be changed, as well as the pixels that
the previous frames disposal also cleared.  In the above animation that
means the pixels that was needed to shape the new hole, and well as the pixels
that was used to fill-in the previous 'hole'. </P>

The result is smaller but not nearly as much, as adding extra frames does have
its own cost. At least each of the added frames also does not have its own
color table, or this animation would have in fact become larger, due to the
size of the extra color tables! </P>


<A NAME="optimizeplus"></A>
<H3>Layer Optimize Plus
<FONT SIZE=-1> - Automatic frame doubling Optimization</FONT></H3>

I am please to say that as of version 6.2.7, IM can now do frame doubling
optimization automatically, as part of its normal frame optimization handling.
However as adding frames to make an animation smaller is so radical a move, it
was given its own separate "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE>" method '<CODE><B>OptimizePlus</B></CODE>'.  </P>

For example, lets get IM to do the frame doubling optimization...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole.gif  -layers OptimizePlus   moving_hole_oplus.gif
  gif_anim_montage x2 moving_hole_oplus.gif moving_hole_oplus_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="moving_hole_oplus.gif"
     ><IMG SRC="moving_hole_oplus.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_oplus_frames.gif"
     ><IMG SRC="moving_hole_oplus_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_oplus_size.txt>
  ls -l moving_hole_oplus.gif | awk '{printf "%d", $5}'
</CODE> -->
That is IM gave you the same result as our previous frame doubling example.
Thus the GIF file is still
    <A HREF="moving_hole_oplus_size.txt"
       ><IMG SRC="moving_hole_oplus_size.txt.gif"
             ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes in size.  However '<CODE>OptimizePlus</CODE>' will only frame double if
the number of pixels in the current and next frame of the resulting animation
(3 frames) is reduced, so we can let IM decide whether to frame double or not.
</P>

As "<CODE><A HREF="../option_link.cgi?layers" >-layers</A></CODE>" method
'<CODE><A HREF="#optimizeplus" >OptimizePlus</A></CODE>' adds extra frames as
it creates an frame optimized GIF animation, it also will remove any unneeded
or extra frames that make no change to the final animation (merging delay
times as appropriate).  That is it will also do an automatic '<CODE><A
HREF="#removedups" >RemoveDups</A></CODE>' (see next).  The '<CODE><A
HREF="#optframe" >OptimizeFrame</A></CODE>' method will not do this. </P>


<A NAME="removedups"></A>
<H3>Remove Duplicate Frames
<FONT SIZE=-1>- merging consecutive duplicate images</FONT></H3>

Unfortunately if you <A HREF="../anim_basics/#coalesce" >coalesce</A></CODE>"
this animation, you will also get all the extra frames that the above added.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole_oplus.gif -coalesce gif:- |\
     gif_anim_montage x2 - moving_hole_oplus_cframes.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="moving_hole_oplus_cframes.gif"
     ><IMG SRC="moving_hole_oplus_cframes.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

To let you remove such useless duplicate frames from a coalesced animation, a
'<CODE><B>RemoveDups</B></CODE>' method has been provided. This compares each
frame with the next frame in the animation, and removes the first frame if
they are identical (with color similarity set by the current <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A>). </P>

Also to ensure that any timings in the animation are not lost, the <A
HREF="../anim_basics/#delay" >Timing Delays</A> of the two frames are also
merged. </P>

For example..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole_oplus.gif -coalesce -layers RemoveDups  gif:- |\
     gif_anim_montage - moving_hole_oplus_rmdups_frames.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="moving_hole_oplus_rmdups_frames.gif"
     ><IMG SRC="moving_hole_oplus_rmdups_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

And we now have our original coalesced form of the animation. </P>

For another method of removing the extra frames see the '<CODE><A
HREF="#removezero" >RemoveZero</A></CODE>' method below. </P>


<A NAME="splitting"></A>
<H3>Splitting Frame Updates
<FONT SIZE=-1>- separately updating two distant changes</FONT></H3>

As you have seen with frame doubling, by separating the 'clearing of pixels'
from the overlaying of new pixels, we can reduce the overall size of a single
frame overlay. </P>

However this animation still produces some very large overlays, which mostly
consist of pixels that don't actually change from one frame to the next.  That
is, the main overlay frame is only updating two rather small areas that are
quite distant from each other thereby producing a single large overlay image. </P>

Rather than trying to update both changes simultaneously while will also
includiing all those the unchanged pixels in-between the two area, we instead
update each area separatally. That is we <I>split the frame update into two
phases</I>, one for each of the separated areas that changed.  In this case we
can fill in the hole first, then create the new hole as a separate update.</P>

It does not actually matter (except with possible regard to disposals) which
of the two separate changes happen in which order, but you should try to be
logical about it.  It may also be that one change is easier to create than
another. </P>

For example, here I insert extra frames to fill in the old hole as a separate
update to the 'digging' of the new hole. This is the easier intermediate
frame to generate as well as the most logical ordering of actions.  Of course
you do not need to do this for the last frame, as that frame is just junked
before the animation loops.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=middle><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
                  <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole.gif \
          \( +antialias -size 100x100 -delay 0 xc:SkyBlue \
             -fill DodgerBlue -draw 'circle 50,50 15,25' \
             -fill RoyalBlue  -draw 'circle 50,50 30,25' \) \
          \( +clone \) -insert 1 \( +clone \) -insert 3  +swap \
          -set dispose background  moving_hole_split.gif
  gif_anim_montage x2 moving_hole_split.gif moving_hole_split_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moving_hole_split.gif"
     ><IMG SRC="moving_hole_split.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_split_frames.gif"
     ><IMG SRC="moving_hole_split_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Remember the added intermediate frame is different from the surrounding user
displayed frames (the ones with a non-zero time delay).  This is not simple
'frame doubling', but the separating two distant small changes. </P>

This addition of intermediate frames is not a simple step that can be
automated. Although it is possible that a smart heuristic could be developed to
generate these intermediate frames, it is not always obvious what should be
done, let alone if it should be done. <I>If you like to try to generate such
an heuristic, please mail me.</I> </P>

So lets try a standard frame optimization after adding these extra frames...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole_split.gif \
               -layers OptimizeFrame     moving_hole_split_opt.gif
  gif_anim_montage x2 moving_hole_split_opt.gif \
                      moving_hole_split_opt_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="moving_hole_split_opt.gif"
     ><IMG SRC="moving_hole_split_opt.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_split_opt_frames.gif"
     ><IMG SRC="moving_hole_split_opt_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_split_opt_size.txt>
    ls -l moving_hole_split_opt.gif | awk '{printf "%d", $5}'
</CODE> -->

The addition of these 'zero delay intermediate frames', allows this animation
frame optimize better than the original unoptimized animation, producing a <A
HREF="moving_hole_split_opt_size.txt" ><IMG
SRC="moving_hole_split_opt_size.txt.gif" ALIGN=absmiddle VSPACE=0 HSPACE=0
BORDER=0 ALT="[IM Text]"></A> byte animation. However for this specific case
it isn't as good as using an automated <A HREF="#double" >Frame Doubling</A>
technique (See the '<A HREF="#optimizeplus" >OptimizePlus</A>' layers method
above). </P>

However adding 'zero delay intermediate frames' does not stop you from also
doing that 'frame doubling' technique as well...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole_split.gif \
               -layers OptimizePlus moving_hole_split_oplus.gif
  gif_anim_montage x2 moving_hole_split_oplus.gif \
                      moving_hole_split_oplus_frames.gif
</CODE></PRE></TD></TR></TABLE></TD>
<TD ALIGN=center ROWSPAN=2>
  <A HREF="moving_hole_split_oplus.gif"
     ><IMG SRC="moving_hole_split_oplus.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="moving_hole_split_oplus_frames.gif"
     ><IMG SRC="moving_hole_split_oplus_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_split_oplus_size.txt>
  ls -l moving_hole_split_oplus.gif | awk '{printf "%d", $5}'
</CODE> -->

This animation now has two extra 'zero delay intermediate frames' per frame
update.  The first fills in the old hole, the second clearing an area that
will contain transparent pixels, before finally the pixels that should not
have been cleared is restored. </P>

The result is the most optimal frame optimization possible for this
specific problem animation, resulting in
  <A HREF="moving_hole_split_oplus_size.txt"
     ><IMG SRC="moving_hole_split_oplus_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes in the final file size. </P>

That is, our 4 frame animation was made smaller, by adding 6 extra zero time
delay frames! More than double the original number of frames.  Weird but true!
</P>

Of course it would also be nice if GIF animation programs actually recognise
<A HREF="../anim_basics/#zero" >Zero Delay Intermediate Frames</A> for what
they are, namely, intermediate updates between the real frames of the
animation. But even so when the updates are highly separated, and very small,
the slight pause caused by the extra frames is rarely visible.  </P>

<BR>

Of course, if the two separated parts of the animation are not actually
related, then they do not need to be time synchronized. Another alternative is
that instead of adding extra frames, to split the animation to two completely
separate animations that you can displaying together on a web page.  See <A
HREF="../anim_mods/#split" >Splitting up an Animation</A>. </P>

This particular animation however cannot be split up into separate time
disjoint animations. First the distant changes need to be time synchronised.
and second the four areas that do change, overlap in both the
horizontal and vertical directions. This means a simple HTML 'table' cannot
rejoin the sub-animations into a complete whole, without some type of CSS
trickery. <I>Can you prove me wrong?</I> </P>

<I>FUTURE: reference to a better example of animating 'two distant objects'.
in 'Animation Handling', say involving two separately moving objects.
</I></P>


<A NAME="removezero"></A>
<H3>Remove Zero Delay Frames
<FONT SIZE=-1>- removing intermediate updates</FONT></H3>

Of course sometimes you are not interested or want to remove these added
intermediate frames from an animation, leaving just the frames that will
actually be shown to an user for some period of time. </P>

You can't just <A HREF=../anim_basics/#coalesce" >coalesce</A> the animation
and use the '<CODE><A HREF="#removedups" >RemoveDups</A></CODE>' method as not
all 'Intermediate Frames' are similar to the surounding frames, and are thus
not duplicates. </P>

However as these types of frame have a <A HREF="../anim_basics/#zero" >Zero
Time Delay</A> you can use another special "<CODE><A
HREF="../option_link.cgi?layers" >-layers</A></CODE>" method,
'<CODE><B>RemoveZero</B></CODE>' which will remove any frame that has a zero
time delay. </P>

This same method will also remove the frames added using <A HREF="#double"
>Frame Doubling</A> and '<CODE><A HREF="#optimizeplus"
>OptimizePlus</A></CODE>' techniques as well. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moving_hole_split_oplus.gif -coalesce -layers RemoveZero gif:- |\
     gif_anim_montage - moving_hole_split_rmzero_frames.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="moving_hole_split_rmzero_frames.gif"
     ><IMG SRC="moving_hole_split_rmzero_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Which again returns the animation back to just the user viewable frames,
simplifying the animation.  </P>

Of course after removing <A HREF="../anim_basics/#zero" >Zero Delay
Intermediate Frames</A>, it is very difficult to re-add them as the change
information is contained is lost. Consequentially the animation may not frame
optimize very well afterward.  Optimization is one of the main purposes of
such frames after all. </P>

<A NAME="frame_results"></A>
<H3>Frame Optimization Results and Summary</H3>

Lets summarize our optimizations of the moving hole animation...

<!-- <CODE EXECUTE NOIMAGE OUT=moving_hole_sizes.txt>
  ( ls -l moving_hole.gif; \
    ls -l moving_hole_opt.gif; \
    ls -l moving_hole_dup.gif; \
    ls -l moving_hole_double.gif; \
    ls -l moving_hole_oplus.gif; \
    ls -l moving_hole_split_opt.gif; \
    ls -l moving_hole_split_oplus.gif; \
  ) | awk '{printf "%6s %s\n", $5, $NF}' -
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="moving_hole_sizes.txt"
     ><IMG SRC="moving_hole_sizes.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see by using some complex frame handling, with the help of IM and
some human intervention, we were able to frame optimize the 'moving hole'
animation to almost half its original size, though with just under three times
the number of frames of the original. </P>

Of course results can vary greatly from animation to animation, but the
techniques we used for frame optimization are the same.  It just needs a
little care and fore-thought, which humans are good at, and computers are not.
</P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  There is the point, that IM should not only account for the number of
  pixels in current set of frames being looked at, but also the overall size
  of the extra frame added, and perhaps the overall compression results
  obtained, when making the decision about how to frame optimize the image.
  </P>

  On the other hand IM also does not look at the resulting savings in the
  number of pixels that may result, beyond the frames that are directly
  involved. That is, later frames sizes may also be smaller as a result of
  frame doubling, or the disposal method used. This is especially true when
  the choice is whether to use 'previous image dispose' method, which can
  have substantial pixel count reductions later in an animation sequence,
  rather than immediately in the very next frame.  A good choice here often
  requires human input. </P>

  As such I can make no guarantee that IM will produce the best optimization
  choices, for a specific animation.  However it certainly gives it a good
  try, without the use of recursion, to make that choice. That is only using
  immediate pixel counts for its decision. </P>

  A recursive algorithm, one that makes a choice, then see what the best
  final size of the animation that results from that choice, (including
  recursive choices further along) can produce a guaranteed best
  optimization.  However it could also be an extremely slow operator, and for
  a large animation could take years to make the final decision. It would
  also need to include <A HREF=#compress_opt" >compression optimization</A>
  choices, as these could effect the final outcome.  In other words, while
  such an algorithm could guarantee the best optimization, it does so at a
  heavy computational cost.  </P>

  Of course a human being with an intimate knowledge of what the animation is
  trying to achieve, will generally do better in complex animations, as you
  saw above with <A HREF="#splitting" >splitting frame updates</A>. </P>

  If you would like to try an create a recursive GIF optimization operator
  please do. I will help in any way I can.  It would beat just about every
  other GIF optimization program on the market.  Also most GIF animation
  developers will probably be very grateful of your efforts (money-wise).

</I></FONT></TD></TR></TABLE></P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="semitrans_opt"></A>
<H2>Semi-Transparency Handling</H2>

The GIF file format does not allow the use of semi-transparent pixels (See <A
HREF="../formats/#boolean_trans" >GIF Boolean Transparency</A>). This is a
fact, and before you can properly optimize an animation, or even save it to
GIF format, you need to handle any semi-transparent pixels that may be
present, in a way that is suitable for the animation. </P>

By default if you don't handle these pixels, IM will use a 50% threshold to
convert these pixels into either fully-transparent or fully-opaque.  However
that may not be the best way to handle the problem, particularly in images
that contain large areas of semi-transparent pixels, such as shadow effects.
</P>

For example, I wanted to create a Stargate Asgard Teleport animation that
could take just about any sub-image as the object being teleported.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -channel RGBA -fill white \
          \( medical.gif -repage 100x100+34+65 -coalesce -set delay 200 \) \
          \( +clone -motion-blur 0x20+90 -blur 0x3 -colorize 100% \
                +clone -colorize 30%  +swap  -composite  -set delay 10  \) \
          \( +clone -roll +0-20 -blur 0x3 -colorize 30% \
             -motion-blur 0x15+90 -motion-blur 0x15-90 -set delay 10 \) \
          \( +clone -colorize 30% \
             -motion-blur 0x30+90 -blur 0x5 -crop +0+10\! \) \
          \( +clone -motion-blur 0x50+90 -blur 0x2 -crop +0+20\! \) \
          \( +page -size 100x100 xc:none -set delay 200 \) \
          -set dispose background -coalesce   -loop 0     teleport.miff
  gif_anim_montage teleport.miff teleport_frames.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="teleport_frames.png"
     ><IMG SRC="teleport_frames.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

I purposely left the animation in the IM internal MIFF: file format as this
ensures that the original image is preserved without modification, and used a
PNG: file format to display the frames so that you can see all the
semi-transparent pixels contained in it! </P>

This is not only important for animations with semi-transparent pixels, but
also ones with lots of colors.  Once the image sequence has been saves into
GIF, your chances of generating a good color optimization goes from good, to
difficult. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Okay I have an animation sequence.  If I attempt to save this directly as GIF,
IM will just threshold all those semi-transparent pixels.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert teleport.miff teleport_thres.gif
  gif_anim_montage teleport_thres.gif teleport_thres_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="teleport_thres.gif"
     ><IMG SRC="teleport_thres.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="teleport_thres_frames.gif"
     ><IMG SRC="teleport_thres_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The result doesn't really look anything like what we wanted.  The default 50%
transparency handling makes the animation look like a look like a shrinking
'egg'.  Definitely not what I want to achieve with this animation.. </P>

If this type of transparency handling is acceptable this is the way to apply
it, before continuing with your other optimizations...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert teleport.miff -channel A -threshold 50% +channel \
                 ...do further processing now...       teleport.gif
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

<!--
In fact it is this semi-transparency handling method that is incorperated into
the <A HREF="#optimize" >General Optimization Method</A>, "<CODE>-layers '<A
HREF="#optimize" >Optimize</A>' </CODE>".
-->

An extra advantage of using the above DIY, is that you can control the
threshold level.  Say '<CODE>10%</CODE>' to remove almost every
semi-transparent pixel present, to '<CODE>90%</CODE>' to make them all opaque.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert teleport.miff -channel A -threshold 90% +channel teleport_thres90.gif
  gif_anim_montage teleport_thres90.gif teleport_thres90_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="teleport_thres90.gif"
     ><IMG SRC="teleport_thres90.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="teleport_thres90_frames.gif"
     ><IMG SRC="teleport_thres90_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

But applying a threshold for animations, like this one, is not a good
solution, as it really spoils the transparency effect I am trying to achieve.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The best overall solution to preserving all the special effects in the above
animation is to just <A HREF="../anim_mods/#flatten" >Add a Solid Color
Background</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert teleport.miff -bordercolor skyblue \
                  -coalesce -border 0 teleport_bgnd.gif
  gif_anim_montage teleport_bgnd.gif teleport_bgnd_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="teleport_bgnd.gif"
     ><IMG SRC="teleport_bgnd.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="teleport_bgnd_frames.gif"
     ><IMG SRC="teleport_bgnd_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This removes ALL the transparency from the animation, but at the cost of only
allowing the animation to work on specific background color. But if you are
creating the animation for a specific web page, that may be quite acceptable.
</P>

Note however for images with sharp outlines, using a dither pattern like this
can produce a 'dotty' outline to the sharp edges. As such, it is not
recommended for the general case. </P>

The other solution is to try and generate some pattern of transparent and opaque
pixels so as to try and preserve the images semi-transparency.  And for this
IM offers a large range of dithering options that can solve this problem. </P>

<I>FUTURE: some link to a to be created section
on transparency dithering, such as <A HREF="../quantize/#color_trans"
>Quantization and Dithering</A>. </I></P>

Note that the obvious first solution of using a <A
HREF="../quantize/#monochrome" >Monochrome Dithering</A> of the alpha channel
is not simple, probably requiring some advance <A
HREF="../anim_mods/#composite" >Multi-Image Composition</A> to do correctly.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

A simple solution is to use a <A HREF="../quantize/#ordered-dither" >Diffused
Pixel Ordered Dither</A> technique, which can be restricted to just the alpha
channel, to remove the semi-transparent pixels.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert teleport.miff -channel A -ordered-dither o8x8  teleport_od.gif
  gif_anim_montage teleport_od.gif teleport_od_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="teleport_od.gif"
     ><IMG SRC="teleport_od.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="teleport_od_frames.gif"
     ><IMG SRC="teleport_od_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The result is reasonable, but looks like a dissolving object than teleporting.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Using a <A HREF="../quantize/#halftone" >Halftone</A> will produce a much
nicer effect by making the transparency pattern bolder.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert teleport.miff -channel A -ordered-dither h8x8a teleport_htone.gif
  gif_anim_montage teleport_htone.gif teleport_htone_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="teleport_htone.gif"
     ><IMG SRC="teleport_htone.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="teleport_htone_frames.gif"
     ><IMG SRC="teleport_htone_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

But for this specific animation, I found that using a <A
HREF="../quantize/#thresholds_xml" >User Designed Dither Map</A> to produce
vertical lines (from a horizontal line dither pattern) produces an effect
that enhances the teleporting animation while removing semi-transparent
pixels.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert teleport.miff -rotate 90 \
          -channel A -ordered-dither hlines -rotate -90 teleport_lines.gif
  gif_anim_montage teleport_lines.gif teleport_lines_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="teleport_lines.gif"
     ><IMG SRC="teleport_lines.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<DIV ALIGN=center>
  <A HREF="teleport_lines_frames.gif"
     ><IMG SRC="teleport_lines_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

So as you can see there are quite a number of possibilities to handling the
semi-transparency in a GIF animation. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="color_opt"></A>
<H2>Color Optimization</H2>

Handling semi-transparent pixels is only the first limitation of the GIF file
format.  The next one is a 256 color limit for each color table in the
animation.  You are allowed to have a separate color table for each frame.
This means a single animation can have more than 256 colors.  However, even
that may not always be a good idea. </P>

If you just like a quick summary of the color optimization options available, I
suggest you jump to the examples on <A HREF="../video/#gif" >Video to GIF</A>
conversion where the color problems of an animation is at its worst. </P>

<A NAME="color_problem"></A>
<H3>GIF Color Problem</H3>

GIF animations in particular have problems in handling colors, as you it first
does not allow semi-transparent colors, then has a 256 color limit per frame,
or a 256 global color limit. </P>

Finally your best frame optimization will not work very well unless the colors
used for a pixel in one frame also match the same color, in the next frame,
when that part of the image did NOT change!  This may seem like an easy problem
but <A HREF="../quantize/#intro" >Color Reduction</A> is itself an extremely
complex field, which required its own full section in IM Examples. </P>

Color problems are actually why most GIF animations you find on the World Wide
Web are of the cartoon variety, or are very bad looking. Especially if resized
from a larger version of the animation.  In <A HREF="../anim_mods/#resize"
>Resizing Animations</A> will probably require more effort in color
optimization, than in the actual resize process itself. </P>

Here I will assume you have the original source of the animation.  But that is
not always possible, so if you are optimizing a modified GIF animation, some
extra caution may be needed.  However if you have an animation with to many
colors, the first thing you need to remember is... </P>

<DIV ALIGN=center><B>
                Do not save directly to GIF format,
<BR>     use the MIFF file format, &nbsp; OR &nbsp; separate PNG images.
</B></DIV></P>

As soon as you save to GIF, you have lost control of your GIF color
optimization efforts, and you probably have a very bad looking GIF animation
that will not optimize very well using various <A HREF="#frame_opt" >Frame
Optimization</A> techniques. </P>


<A NAME="speed"></A>
<H3>Speed Animation
<FONT SIZE=-1>- an Animation with too many colors</FONT></H3>

First we need to generate a GIF animation with a vast number of colors, so
that we can really test out the problems involved in color optimization.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=middle><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
                  <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -dispose none -channel RGBA \
          \( medical.gif -repage 100x60+5+14  -coalesce -set delay 100 \) \
          \( medical.gif -repage 100x44+34+6  -coalesce -set delay 10 \
             -motion-blur 0x12+0  -motion-blur 0x12+180 -wave -8x200 \) \
          \( medical.gif -repage 100x60+63+14 -coalesce -set delay 100 \) \
          \( medical.gif -repage 100x44+34+6  -coalesce -set delay 10 \
             -motion-blur 0x12+0  -motion-blur 0x12+180 -wave +8x200 \) \
          null: \( +page  -size 120x15 xc:SkyBlue xc:RoyalBlue \
                   -size 120x70 gradient:SkyBlue-RoyalBlue \
                   +swap -append -blur 0x3 -background white -rotate -25 \
                \) -gravity center -compose DstOver -layers Composite \
          -loop 0   speed.miff

  convert   speed.miff  speed.gif
  gif_anim_montage  speed.gif  speed_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speed.gif"
     ><IMG SRC="speed.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="speed_frames.gif"
     ><IMG SRC="speed_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I did not save the animation directly to the GIF format but saved it
in a MIFF format file, "<CODE><A HREF="speed.miff" >speed.miff</A></CODE>"
first.  This preserves all aspects of the originally created (or modified)
animation, including GIF meta-data, timing delays, as well as all the colors
of the image without distortion.  </P>

Only after preserving the original animation, did I directly convert
the original animation to GIF format. That way I could show what the above code is
meant to achieve, and why I called it 'speed'.  This was done also to provide a base
line GIF animation for study and later comparison. </P>

So lets look at various details of our original animation..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=speed_nframes.txt>
  identify -format "Number of Frames: %n\n" speed.miff | head -1
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="speed_nframes.txt"
     ><IMG SRC="speed_nframes.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=speed_ncf.txt>
  identify -format "Colors in Frame %p: %k\n"  speed.miff
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="speed_ncf.txt"
     ><IMG SRC="speed_ncf.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=speed_ncolors.txt>
  convert speed.miff +append  -format "Total Number of Colors: %k"  info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="speed_ncolors.txt"
     ><IMG SRC="speed_ncolors.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see, each image in the animation has a very large number of colors.
Not only does each frame have a different number of colors, but the first
and third frames are very similar color-wise, though not quite exactly the
same. </P>

However the GIF file format can only save a maximum of 256 color per frame,
the ImageMagick saved this to GIF format it did so in the fastest, and dumbest
way possible... </P>

It reduced the number of colors of each frame in the animation (a
process called <A HREF="../quantize/#colors" >Color Quantization</A>)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=speed_ncolors2.txt>
  identify -format "Colors in Frame %p: %k\n"  speed.gif
  convert speed.gif +append  -format "Total Number of Colors: %k"  info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="speed_ncolors2.txt"
     ><IMG SRC="speed_ncolors2.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Because the reduced number of colors in each frame is slightly different,
IM also needed to supply a separate colormap for each frame in the animation.
This means that the GIF file has one 'Global Color Table' and it always does,
but also three separate 'Local Color Tables'. </P>

The "<CODE>identify</CODE>" command cannot tell you how many such local color
tables a GIF file has, as the information is too format specific, and not
important to the image processing IM normally does. However the more specific
"<CODE><A HREF="http://www.ict.griffith.edu.au/anthony/software/#giftrans"
>Giftrans</A></CODE>" program can tell you how many low level local color
tables were used...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=speed_ctables.txt>
  giftrans -L speed.gif 2>&1 | grep -c "Local Color Table:"
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="speed_ctables.txt"
     ><IMG SRC="speed_ctables.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  [ "`cat speed_ctables.txt`" -lt 3 ] && echo >&2 \
    "ASSERTION FAILURE: Color Example had too few Local Color Tables"
</CODE> -->

As you can see this animation has
  <A HREF="speed_ctables.txt"
     ><IMG SRC="speed_ctables.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
local color tables, one less than the number of frames present in the image,
just as I predicted. </P>

Not only does each frame have a different set of colors, but also a slightly
different pattern of colors (the image dither pattern), as described in <A
HREF="../quantize/#dither_sensitive" >Problems with Error Correction
Dithers</A>. </P>

Normally this default operation of IM <A HREF="../quantize/" >Color
Quantization and Dithering</A> is very good, and perfectly suited for
pictures, especially real life photos. In fact the individual frames of an
animation will generally look great.  All the problems are when we try to
later string those individually color reduced frames into an single animation
sequence. </P>


<A NAME="color_frame_first"></A>
<H3>Frame Opt before Color Opt?</H3>

As you saw above saving an animation directly to a GIF format, works, but you
will get quite a lot of color differences from one frame to the next, which s
bad for later <A HREF="#optframe" >Frame Optimization</A> (as you will see
later).  </P>

To prevent color differences causing such problems you can do the <A
HREF="#optframe" >Frame Optimization</A> before saving the animation, and thus
avoiding the introduced color differences from one frame to another.

<!--
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE _EXECUTE>
  convert speed.miff  -layers OptimizeFrame  speed_opt.gif
  gif_anim_montage  speed_opt.gif  speed_opt_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speed_opt.gif"
     ><IMG SRC="speed_opt.gif"         WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="speed_opt_frames.gif"
     ><IMG SRC="speed_opt_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see the animation was frame optimized perfectly, reducing the
overlays to just the areas that changed from one frame to the next. </P>
-->

However be warned that doing frame optimization before color reducing however
change the dynamics of the color reduction.  Often less of the static unmoving
areas will appear in the optimized sub-frame, which means that the color
quantization for that frame can give those colors less importance, and
therefor less colors. </P>

<A NAME="color_fuzz"></A>
<H3>Fuzzy Color Optimization</H3>

However sometimes you don't have access to the original animation before it
was saved to GIF format.  This is especially true if you downloaded the
original animation from the WWW.  That means you already have an animation
with all those GIF color distortions already present, producing problems
with later optimizations. </P>

Now because a slightly different set of colors are used from one frame to the
next, and a different pattern of pixels are used for each frame in the
animation, each frame can be regarded as a completely different image. </P>

For example lets compare the first and third frames, which share large amount
of the same background image....

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  compare  speed.gif'[0,2]' speed_compare.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speed_compare.gif"
     ><IMG SRC="speed_compare.gif"              WIDTH=100  HEIGHT=60
           ALIGN=absmiddle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The red areas of the above example shows two solid square areas of the areas
that are different, just as you would expect. But it also shows bands of
color differences outlining the background of the two frames. These represent
the 'churning' dither pattern along the edges of the background gradient where
different color pixels were used to represent the exact same background. </P>

This was also the frame pair showing least background disturbances caused by
using different sets of colors, and dither patterns.  The actual consecutive
frame differences are far worse, producing near a near solid red difference.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Image differences like this are also a problem if your source images were
  stored using the JPEG image format.  This format uses a lossy-compression
  method that (even at 100% quality) causes slight color differences,
  in the images. However the differences are generally confined to a halo
  around the actual areas of difference, rather that throughout the image.
  </P>

  All I can say is, avoid JPEG images for use in animations unless you plan
  to use one single image as a static background image for ALL your frames.

</I></FONT></TD></TR></TABLE></P>

As so many pixels in the animation are different from one frame to the next it
is not surprising then that when we try to <A HREF="#frame_opt" >Frame
Optimize</A> the animation, we get no optimization at all...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert speed.gif  -layers OptimizeFrame  speed_opt2.gif
  gif_anim_montage  speed_opt2.gif  speed_opt2_frames.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="speed_opt2_frames.gif"
     ><IMG SRC="speed_opt2_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

However most the pixel color differences between unchanging parts of the
animation frames are actually rather small.  It wouldn't have been a very good
<A HREF="../quantize/#intro" >Color reduction</A>, if this wasn't the case.
That means that by asking IM to relax its color comparisons a little, you can
ask it to ignore minor color differences.  This is done by setting an
appropriate <A HREF="../color_basics/#fuzz" >Fuzz Factor</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert speed.gif  -fuzz 5%  -layers OptimizeFrame  speed_opt3.gif
  gif_anim_montage speed_opt3.gif speed_opt3_frames.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="speed_opt3_frames.gif"
     ><IMG SRC="speed_opt3_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see with the addition of a small <A HREF="../color_basics/#fuzz"
>Fuzz Factor</A>, IM will now ignore the pixels that are only slightly
different, producing a reasonable <A HREF="#frame_opt" >Frame
Optimization</A>.  How much of a fuzz factor you need depend on just how much
trouble IM had in color reducing the original images. In this case not a lot,
so only a very small factor was needed. </P>

If a small fuzz factor produces an acceptable result, then just set it for
your <A HREF="#optframe" >Frame Optimization</A> and <A HREF="#trans_opt"
>Transparency Optimization</A>.   Just remember you still have a separate
color table for each frame to take care of, which is the next point of
discussion. </P>

Note also that the <A HREF="#frame_opt" >Frame Optimization</A> decided to
use a '<A HREF="../anim_basics/#previous" >Previous Disposal</A> for the
second frame.  That is after displaying the second frame return the image to
the previous frame disposal (the first image) before overlaying. This resulted
in a smaller overlay image size, than if no disposal was used thoughout. </P>

If you wanted just a simple <A HREF="../anim_basics/#overlay" >Overlay
Animation</A>, only using <A HREF="../anim_basics/#none" >None Disposal</A>
thoughout, you could have used the old <A HREF="../anim_basics/#deconstruct"
>Deconstruct</A> operator (also known as <A HREF="../anim_basics/#compareany"
>Layers CompareAny</A>) to generate it instead.  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert speed.gif  -fuzz 5%  -deconstruct  speed_opt4.gif
  gif_anim_montage speed_opt4.gif speed_opt4_frames.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="speed_opt4_frames.gif"
     ><IMG SRC="speed_opt4_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="colortables"></A>
<H3>Generating a Single Global Color Table</H3>

Now as each and every frame has a different set of colors, IM was forced to
save the image, with a separate color table for every frame: one global one
for the first frame, and 3 local color tables for the later frames. </P>

For example, here I used the very simple program "<CODE><A
HREF="http://www.ict.griffith.edu.au/anthony/software/#giftrans"
>Giftrans</A></CODE>" program to report how many frame color tables were
created.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  giftrans -L speed.gif 2>&1 | grep -c "Local Color Table:"
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="speed_ctables.txt"
     ><IMG SRC="speed_ctables.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

For a fully-coalesced (or film strip like) animation, having separate color
tables for each frame is perfectly fine and reasonable, and in such
situations this is not a problem.  That is for slide shows of very different
images, separate color tables will produce the best looking result. As such
this is the normal working behaviour of IM. </P>

All these extra color tables is however very costly as each colortable can use
a lot of space. Up to 768 bytes (256 colors &times; 3 bytes per color or 3/4
kilobytes) for each frame in the image. Not only that, but the GIF compression
does not compress these color tables, only pixel data!  </P>

If having this much file space for separate color tables is a problem,
especially for an image that doesn't change color a lot, as is the case with
most GIF animations, then you can get IM to only use the requires global color
table, and not add any local color tables. </P>

---</P>

To remove local color maps all the image must become type palette and all use
the same palette,  For the command line you can do this by setting a "-map
image" to define the command palette,  You cannot use -colors as that works
of individual images. </P>

The command line solution is a special "<CODE><A HREF="../option_link.cgi?map"
>+map</A></CODE>" option, that does a global color reduction to a common
palette that is added to all images. </P>

NOTE any change to the image will likely invalidate the palette, so while
color reduction should be done BEFORE you do GIF frame and/or compression
optimizations, the common palette needs to be last, just before saving.  If
"<CODE><A HREF="../option_link.cgi?map" >+map</A></CODE>" does not need to reduce
the number of colors in an image it will not do it or dither colors, just add
a common palette across all images. </P>

--- </P>

IM can generate a single global color table, if all the frames use the same
color palette.  In IM color palettes are only assigned to an image either by
reading them in from an image format that is using such a palette, or by
assigning it one using the "<CODE><A HREF="../option_link.cgi?map"
>-map</A></CODE>" color reduction operator. See <A HREF="../quantize/#map"
>Dither with Pre-defined Colormap</A> for more details. </P>

One way to generate this single color table is to simply "<CODE><A
HREF="../option_link.cgi?append" >-append</A></CODE>" all the frames together,
then using the "<CODE><A HREF="../option_link.cgi?colors" >-colors</A></CODE>"
command to reduce the number of colors to a minimal set (less than 256, or
smaller if you want an even smaller color table).  The resulting color table
can then be applied to the original image using "<CODE><A
HREF="../option_link.cgi?map" >-map</A></CODE>". </P>

For example here reduce the image to a single set of 64 colors.  This uses the
special <A HREF="../files/#mpr" >MPR in-memory register</A> to assign the
generated color map to the "<CODE><A HREF="../option_link.cgi?map"
>-map</A></CODE>" command.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert speed.gif \
          \( -clone 0--1 -background none +append \
              -quantize transparent  -colors 63  -unique-colors \
             -write mpr:cmap    +delete \) \
          -map mpr:cmap      speed_cmap.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speed_cmap.gif"
     ><IMG SRC="speed_cmap.gif"         WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now if you examine the resulting animation using  "<CODE><A
HREF="http://www.ict.griffith.edu.au/anthony/software/#giftrans"
>Giftrans</A></CODE>" you will find that the image now uses a single 'global'
color table, rather than a separate color table for each frame. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  I use a "<CODE><A HREF="../option_link.cgi?background"
  >-background</A></CODE>" color of '<CODE>None</CODE>' before appending the
  images together, allowing you to use this on un-coalesced animations, and
  not have the possibility adding extra unneeded colors. </P>

  The special "<CODE><A HREF="../option_link.cgi?quantize"
  >-quantize</A></CODE>" setting of '<CODE>transparent</CODE>' colorspace was
  used to ensure that IM does not attempt to generate semi-transparent colors
  in its colormap. An useless thing as we are saving the result to GIF which
  cannot handle semi-transparency. </P>

  Finally I color reduce to 63 colors, to leave space for a transparent color.
  Some animations need transparency, while others (like this one) may still
  need it later for <A HREF="#compress_opt" >Compression Optimization</A>.

</I></FONT></TD></TR></TABLE></P>

To make this easier, IM also provides a special option  "<CODE><A
HREF="../option_link.cgi?map" >+map</A></CODE>" which will generate a common
color map (of 256 colors) over all the frames, applying it globally.   This is
a lot simpler than the DIY method above.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert speed.miff  +matte +map   speed_map.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speed_map.gif"
     ><IMG SRC="speed_map.gif"         WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!-- <CODE EXECUTE NOIMAGE OUT=speed_map_ctables.txt>
  giftrans -L speed_map.gif 2>&1 | grep -c "Local Color Table:"
</CODE>
<CODE EXECUTE ASSERT>
  [ "`cat speed_map_ctables.txt`" != 0 ] && echo >&2 \
    "ASSERTION FAILURE: Map Common Palette did not remove Local Color Tables!"
</CODE> -->

This resulted in
  <A HREF="speed_map_ctables.txt"
     ><IMG SRC="speed_map_ctables.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
'local' (or extra unwanted) color tables in the resulting image. </P>

I will be using the single color table version of the animation for the next
optimization sections, though you could actually do this at any point in your
animation optimizations and especially before the final save. </P>

<!-- <CODE EXECUTE>
  ls -l speed.gif | awk '{printf "%d", $5}' > speed_size.txt
  ls -l speed_map.gif | awk '{printf "%d", $5}' > speed_map_size.txt
</CODE> -->
As a result of color table optimization, the animation which was
  <A HREF="speed_size.txt"
     ><IMG SRC="speed_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes for our directly converted GIF, is now
  <A HREF="speed_map_size.txt"
     ><IMG SRC="speed_map_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes, after using the "<CODE><A HREF="../option_link.cgi?map" >+map</A></CODE>"
operator.  The more frames (and 'local color tables') an animation has, the
larger the saving. </P>

Now as any modification to an animation will generally remove the saved
palette for each of the images, it is important that the  "<CODE><A
HREF="../option_link.cgi?map" >+map</A></CODE>" operator be the last operation
before saving the animation to GIF. </P>

Remember
<DIV ALIGN=center><B>
    Removal of local color maps should be the last optimization,
           before saving to GIF format.
</B></DIV></P>


<A NAME="dithering"</A>
<H3>Ordered Dither, removing the 'static'</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

Note however that in all the techniques we have looked at so far all can have
a dither pattern that changes from one overlay to another. A churning of the
pixels that can look like TV static. </P>

<PRE>... small number of colors ...</PRE>

With a frame optimization of a smaller unmoving area, you can even get a
rectangular areas of static that looks even worse. </P>

... Ordered Dither ... </P>

For now refer to the more practical and less detailed <A HREF="../video/#gif"
>Video to GIF, Optimization Summary</A>. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="compress_opt"></A>
<H2>Compression Optimization</H2>

Once you have your animation saved into a GIF format, by handling
semi-transparent pixels and using color and frame optimizations, you are
also able to get some smaller file size reductions by catering to the GIF
compression algorithm. </P>

The LZW compression or Run-length Compression that the GIF file format can use
will compress better if it finds larger areas of constant color, or pixel
sequences that repeat over and over. </P>


<A NAME="opttrans"></A>
<A NAME="opt_trans"></A>
<H3>Transparency Optimization</H3>

As you saw in <A HREF="#frame_opt" >Frame Optimization</A> an overlaid image
will often be just repeating what is already being displayed.  That is it is
overlaying the same colored pixels that is already present after the GIF
disposal methods have been applied. </P>

But why bother repeating those pixels.  If you are already using transparency
in an image, you have a transparent pixel color available.  But converting
those areas into transparency, get larger areas of uniform transparent pixels.
That can compress better, than using a mix of different colors, needed to
match the same area being overlaid. </P>

For example here is a simple <A HREF="#frame_opt" >Frame Optimized</A>,  <A
HREF="../anim_basics/#overlay" >Overlay Animation</A>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=middle><TD WIDTH=10%></TD>
<TD WIDTH=80% ALIGN=center>
  <A HREF="bunny_bgnd_frames.gif"
     ><IMG SRC="bunny_bgnd_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center ROWSPAN=3>
  <A HREF="bunny_bgnd.gif"
     ><IMG SRC="bunny_bgnd.gif"          WIDTH=120 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Lets now use the  "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE>", method '<CODE><B>OptimizeTransparency</B></CODE>' (Added
IM v6.3.4-4) to replace any pixel that does change the displayed result with
transparency.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=middle><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
                  <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert bunny_bgnd.gif -layers OptimizeTransparency \
                                    +map   bunny_bgnd_opttrans.gif
  gif_anim_montage bunny_bgnd_opttrans.gif bunny_bgnd_opttrans_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bunny_bgnd_opttrans.gif"
     ><IMG SRC="bunny_bgnd_opttrans.gif"          WIDTH=120 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="bunny_bgnd_opttrans_frames.gif"
     ><IMG SRC="bunny_bgnd_opttrans_frames.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE>
  ls -lH bunny_bgnd.gif | awk '{printf "%d", $5}' >  bunny_bgnd_size.txt
  ls -l  bunny_bgnd_opttrans.gif | awk '{printf "%d", $5}' \
                                            > bunny_bgnd_opttrans_size.txt
</CODE> -->

As you can see the sub-frames now have large transparent areas, which do not
effect the final resulting animation.  Areas that need the pixels changed are
still overlaid, but the areas that does not change have been made
transparent.  That includes within the object being animated as well, leaving
rather horible looking 'holes'.  </P>

As the larger constant transparent colored areas  will (in theory) compress
better, the resulting 'messy' animation is a lot smaller, reducing the file
size from the frame optimized result of
  <A HREF="bunny_bgnd_size.txt"
     ><IMG SRC="bunny_bgnd_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes down to
  <A HREF="bunny_bgnd_opttrans_size.txt"
     ><IMG SRC="bunny_bgnd_opttrans_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes. This is quite a big savings for a very small effort. </P>

Note that the optimization method did not need to be a <A
HREF="../anim_basics/#coalesced" >Coalesced Animation</A>, and that the size
of the sub-frames is left unchanged, so as to preserve the disposal needs of
this and later frames.  As such any savings is just in terms of improved
compression ratios for the same number of pixels in the animation, and not in
that actual number of pixels saved into the file.  It should thus be done
after you have completed any  <A HREF="#frame_opt" >Frame Optimization</A>
needed, as one of your final optimization steps. </P>

<PRE>FUTURE: link to a 'remove background' from animation</PRE>

Of course like most of the other "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE>" methods (comparison or optimization) you can specify a <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A> to adjust, 'how similar' colors
are thought to be.  That lets you handle animations that were badly color
dithered, though if you had studied the <A HREF="#color_opt" >Color
Optimization</A> above you should not have that problem. </P>

The free animated GIF tool "<CODE><B><A
HREF="http://utter.chaos.org.uk/~pdh/software/intergif.htm"
>InterGIF</A></B></CODE>" also provides this same type of transparency
compression optimization shown above, but without the ability to also support
a 'fuzz factor' to also make 'close' color changes transparent.  I do not
recommend it, except as an alternative when IM is not available. </P>


<A NAME="opt_lzw"></A>
<H3>LZW Optimization <FONT SIZE=-1>- (non-IM)</FONT></H3>

Some applications can further optimise the compression ratio of the images in
an animation to make it them even smaller.  However to do this requires a
specialized knowledge of the LZW compression that the GIF image file format
typically uses. </P>

Basically, if a specific sequence of pixels has already been handled by the LZW
compression algorithm, it will not bother to convert them into transparent
pixels as doing so will not improve the images compression.  </P>

It sounds weird but it works. </P>

Unfortunately <I>ImageMagick will not do this</I>, as it is such a complex
process that takes a great deal of skill and resources to get a reasonably
good heuristic to produce a good result in the general case.  </P>

I can however give you a practical example of this technique using the
"<CODE><A HREF="http://www.lcdf.org/gifsicle/" >Gifsicle</A></CODE>"
application at its highest '<CODE>-O2</CODE>' optimization level.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  gifsicle -O2 bunny_bgnd.gif -o bunny_bgnd_lzw_gifsicle.gif
  gif_anim_montage bunny_bgnd_lzw_gifsicle.gif bunny_bgnd_lzw_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bunny_bgnd_lzw_gifsicle.gif"
     ><IMG SRC="bunny_bgnd_lzw_gifsicle.gif"          WIDTH=120 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="bunny_bgnd_lzw_frames.gif"
     ><IMG SRC="bunny_bgnd_lzw_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

<!-- <CODE EXECUTE>
  ls -l bunny_bgnd_lzw_gifsicle.gif | awk '{printf "%d", $5}' \
                                     > bunny_bgnd_lzw_gifsicle_size.txt
</CODE> -->
LZW compression optimization reduced the image from
  <A HREF="bunny_bgnd_opttrans_size.txt"
     ><IMG SRC="bunny_bgnd_opttrans_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes with simple transparency optimization, to
  <A HREF="bunny_bgnd_lzw_gifsicle_size.txt"
     ><IMG SRC="bunny_bgnd_lzw_gifsicle_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes for "Gifsicle".  Not a large improvement. </P>

The more important aspect however is that while LZW optimization converted
unchanged pixel to transparency (as we did using <A HREF="#opt_trans"
>Transparency Optimization</A> above), it did not change a sequence of pixels
that had already been seen.  That is, only groups of pixels that have
<I>not</I> already been repeated within the animation were changed, as those
pixel would (presumably) already compress well using LZW compression patterns.
</P>

Note that the selection of what pixels should be made transparent, to generate
repeated pixel patterns, is very complex and difficult, and can even depend on
the exact LZW implementation as well.  It is a heuristic, not a perfectly
predictable algorithm.  As such different programs will generally produce
different results depending on the specific image being compressed.  One
program may produce a better compression ratio for one image, and another may
be better for a different image. </P>

<A NAME="opt_lzw_lossy"></A>
<H3>Lossy LZW Optimization <FONT SIZE=-1>- (non-IM)</FONT></H3>

Another compression improvement method involved the slight modification of the
pixel colors themselves to 'close color matches' so as to increase the
repetition of the color references in the image. A repeated pattern naturally
compresses better, and as such can produce a higher compression ratios. </P>

A fork of the previous "Gifsicle" application, known as <A
HREF="https://kornel.ski/lossygif" >giflossy</A>, also generats
a '<CODE>gifsicle</CODE>' program, but one with the option to modify the image
in minor ways (it is 'lossy') to reduce the size of GIF images, especially in
animation, much further. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  gifsicle -O3 --lossy=80 bunny_bgnd.gif -o bunny_bgnd_giflossy.gif
  gif_anim_montage bunny_bgnd_giflossy.gif bunny_bgnd_lossy_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bunny_bgnd_giflossy.gif"
     ><IMG SRC="bunny_bgnd_giflossy.gif"          WIDTH=120 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="bunny_bgnd_lossy_frames.gif"
     ><IMG SRC="bunny_bgnd_lossy_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

<!-- <CODE EXECUTE>
  ls -l bunny_bgnd_giflossy.gif | awk '{printf "%d", $5}' \
                                     > bunny_bgnd_giflossy_size.txt
</CODE> -->
This resulted in a size of
  <A HREF="bunny_bgnd_giflossy_size.txt"
     ><IMG SRC="bunny_bgnd_giflossy_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
, which is amazing 1/3 reduction in size. </P>

Unfortunately this method involved changing the resulting image, and as such
the optimization is lossy, as it can loose subtle color information.  On the
plus side it allows you to compress the individual frames, rather than the
frame-to-frame optimization. Here for example I generated a difference image
of the previous non-lossy LWZ compression against a lossy LWZ compression.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  compare bunny_bgnd_lossy_frames.gif bunny_bgnd_lzw_frames.gif \
          bunny_bgnd_diff_frames.gif
</TD></TR></TABLE>
  <A HREF="bunny_bgnd_diff_frames.gif"
     ><IMG SRC="bunny_bgnd_diff_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see almost all the color modifications was in the original 'grass'
background image, rather than the cartoon bunny. Basically it slightly
modified things just enough to make a huge difference, and for this image not
a real noticable difference in look.  </P>

Of course <A HREF="../quantize/" >Color Quantization and Dithering</A> is
itself a lossy operation and is usually needed anyway, so using a lossy
compression method for GIF images, and GIF animations is not regarded as very
bad. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Another example of such an algorithm that was patented for use by Photoshop
  see <A HREF="http://www.patentstorm.us/patents/7031540-fulltext.html" >US
  Patent 7031540 - Transformation to increase the lempel-ziv compressibility
  of images with minimal visual distortion</A>.  It is heavy reading but
  details the methods it uses to achieve better compression.
</I></FONT></TD></TR></TABLE></P>

<A NAME="opt_lzw_dithered"></A>
<H3>Ordered Dithered LZW Optimization <FONT SIZE=-1></FONT></H3>

As the dithering process is usually a more lossy process than LZW
optimizations, a better solution may be to try to introduce the repeatable
patterns as part of the dithering process. That can be achieved by using <A
HREF="../quantize/#ordered-dither" >Ordered Dithering</A> to produce such
patterns, and thus much stronger LZW compression savings than all the previous
LZW Optimization method.  </P>

As a bonus it can also improve the <A HREF="#frame_opt" >Frame
Optimization</A> of real life animations with static backgrounds. That would
be especially true if you artificially clean up the background so it does
become a static unchanging background. </P>

Of course Ordered Dither Compression Optimization only works for images that
have not previously been dithered or otherwise color optimized. As such it
only works for animations that have yet to be optimized for the GIF image
format. </P>

Also currently IM Ordered dither only works for an uniform color palette. IM
has yet to have a 'best color' or 'user supplied' palette implementation of
ordered dither, though I have seen programs that use such an algorithm for
very limited (and fixed) color pallets.   <I>Do you know of such an
algorithm?</I> </P>

For a practical example of using ordered dither for improved LZW compression
optimization, see <A HREF="../video/#gif_ordered_dither" >Ordered Dithered
Video</A>. </P>

<A NAME="opt_lzw_other"></A>
<H3>Other LZW Optimization <FONT SIZE=-1></FONT></H3>

Other improvements in LZW optimization can also be achieved by other
re-arragements of the 'dither pattern' in the image.  And some GIF tools can
do exactly that. </P>

However any such optimization should always be checked by a human eye before
being approved, as sometimes a subtile but bad color changes can result. </P>

<H3>Compression Optimization Summary</H3>

Here is a complete summary of the final file sizes achieved using
compression optimizations.
<!-- <CODE EXECUTE NOIMAGE OUT=bunny_bgnd_compress_sizes.txt>
  ( ls -lH bunny_bgnd.gif; \
    ls -l  bunny_bgnd_opttrans.gif; \
    ls -l  bunny_bgnd_lzw_gifsicle.gif; \
  ) | awk '{printf "%6s %s\n", $5, $NF}' -
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="bunny_bgnd_compress_sizes.txt"
     ><IMG SRC="bunny_bgnd_compress_sizes.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see only slight improvements in final animation size was achieved
by using the very complex <A HREF="#lwz_opt" >LZW Optimization</A>, over the
built-in <A HREF="#trans_opt" >Transparency Optimization</A>. </P>

However the results are also highly variable between the many GIF optimization
application programs available, and the specific animation that is being
optimized. </P>

If you really need to get the very last byte from a file size, then a <A
HREF="#lwz_opt" >LZW Optimization</A> may be just what you need.  And if you
really need the very best results, you should try a number of different
programs (and thus heuristic implementations) to see which one compresses your
specific animation better, including what other optimization features they
provide. </P>

Typically a <A HREF="#trans_opt" >Transparency Optimization</A> is good enough
for most purposes.  With <A HREF="#lwz_opt" >LZW Optimization</A> only
producing a slightly better result, producing a very minor saving for network
transmission sizes, rather than disk storage size, as the latter uses larger
'chunks' or 'blocks' of storage. Because of this I feel the <A HREF="#lwz_opt"
>LZW Optimization</A>, overkill, and I don't think it is worth the effort, or
the money (most of these tools are commercially sold). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Unfortunately I have found that these GIF optimizers do not handle ALL
  types of pre-optimized animations very well. </P>

  For example, my tests show that "<CODE><A
  HREF="http://www.lcdf.org/gifsicle/" >Gifsicle</A></CODE>" fails to handle
  an animation that was already optimized using a 'background disposal'
  technique. </P>

  On the other hand I found that "<CODE><A
  HREF="http://www.chaos.org.uk/~pdh/software/intergif.htm"
  >InterGIF</A></CODE>" will not handle animations that have already been
  optimized to use an initial canvas and 'previous disposals' technique.  It
  also is limited to the use of <A HREF="#trans_opt" >Transparency
  Optimization</A>, which IM now provides.  </P>

  I thus recommend you do not mix GIF optimization utilities by feeding one
  utilities output into another. At least not without first coalescing the
  animation to remove any previous frame optimizations. </P>

  IM, Gifsicle and InterGIF, all provide such coalescing options to remove
  their own optimizations, though I cannot guarantee the non-IM
  applications will coalesce ALL animations correctly. IM will. </P>

</I></FONT></TD></TR></TABLE></P>

Because you can't use these programs reliably with IM's advanced <A
HREF="#frame_opt" >Frame Optimization</A> techniques (which selects and
switches to using different GIF disposal techniques automatically), I have
often found that IM will often produce an overall better result that just using
these LZW compression optimizers. </P>

I also suggest you also <A HREF="../anim_basics/#coalesce" >Coalesce</A> the
result again afterward and compare its frames against the original
un-optimized animation, to ensure that the non-IM program did not somehow
stuff up the animation entirely (see note above).  Believe me I have seen it
happen, and scripts should double check animations remain valid. </P>

<BR>

Another tutorial (using windows tools) about this type of optimization is <A
HREF="http://www.webreference.com/dev/gifanim/frame.html" >WebReference Frame
Optimation</A>. Note that the site is mis-named as it is about compression
optimization. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="minor_opt"></A>
<H2>Minor Optimizations</H2>

There are a few other optimization techniques that you can use with GIF
animations that are often so obvious that they are overlooked. </P>

<UL>
<LI><B>Remove GIF comments.</B>

<BR>Many GIF animations have a large text comment added. Often these were
    added automatically by graphical editors as a form of advertising.  For
    example, "<CODE>Gimp</CODE>" by default adds "<CODE>Created with The
    GIMP</CODE>" to images.  If the comment is not needed, it is a waste of
    space.  Remove them by adding a "<CODE><A HREF="../option_link.cgi?set"
    >+set</A> comment</CODE>" operator to the IM "<CODE>convert</CODE>"
    command before the GIF is saved.  </P>

    Please note however that if the comment is a copyright notice, it may not
    be a good idea to remove it for legal reasons.  </P>

<LI><B>Reduce the number of colors.</B>
<BR>If animation looks okay with fewer colors, use a smaller color table. The
    color tables are always a power of two, so if you can use less than 32
    colors, that is a lot smaller than using 256 colors.  This is especially
    important as color tables are not compressed by the LZW compression used
    for the GIF image data. </P>

    Also using fewer colors will generally produce better LZW compression as
    more common pixel sequences are found.  This is not always the case
    however as color dithering (due to the color reduction) can also make the
    compression worse.  Turning of dithering or using an ordered dither can be
    important here.  </P>

<LI><B>Half the number of user visible frames.</B>
<BR>If you can handle a less smooth animation, then halving the total number
    frames can produce a good improvement in the final file size.  Of course
    you don't get a file half the size, and the animation quality is reduced.
    But it can produce a very large file size reduction.
    </P>

<LI><B>Crop/Resize the animation.</B>
<BR>A smaller image size means a smaller file size.  So if you don't need a
    big animation, don't use a big animation. A small thumbnail to represent a
    larger animation or video, is often preferable in a listing that the real
    thing. </P>

<LI><B>Alternative Compressions.</B>
<BR>If you do not plan to use the animation as an animation, that is you just
    want to store it, turn off the LZW compression, and "gzip" or "bzip2"
    compress the WHOLE file for storage! </P>

    The result is a lot smaller, though it requires web servers to give the
    right 'content' and 'compression' hints to browsers for it to be directly
    usable by client browsers.  The "<CODE>Apache</CODE>" web server, doesn't
    do this by default, but can be made to do so.  </P>

    Better still, archive the whole directory of uncompressed animations
    into a single file, for even better storage compression. </P>

</UL>

If you have any other optimization ideas, please let me know. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="gif_links"></A>
<H2>Other Sources of Information on GIF Optimization</H2>

The above completes the various basic methods and techniques for handling
animations. However to form a complete picture.  You should continue into the
next IM examples page, detailing techniques for handling actual problems with
real <A HREF="../anim_mods/" >Animations of Images</A>.  Also many of the
above techniques are demonstrated in the practical examples of  <A
HREF="../video/#gif" >Video to GIF Optimization</A>. </P>

I also recommend you thoroughly read about <A HREF="../quantize/" >Color
Quantization</A>, if you are really serious about dealing with GIF animations,
as color reduction is often the key to good GIF animation handling. </P>

Other useful sources for GIF Animation Optimization techniques that I have
found on the WWW include...

<UL>
<LI><A HREF="http://www.ddj.com/documents/s=2904/nam1012433888/index.html"
    >Dr Dobb's - Optimizing GIF Animations</A>
<LI><A HREF="http://www.webreference.com/dev/gifanim/"
    >Optimizing Animated GIFs</A>
</UL></P>

Mail me if you think you have a page I should list here.  I will only add
pages of useful content, so no guarantees about adding your link. </P>

</DIV>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 22 March 2007 ((sub-division of "animation") <BR>
Updated: 23 April 2007 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/anim_opt/</CODE>
</ADDRESS></BODY></HTML>
