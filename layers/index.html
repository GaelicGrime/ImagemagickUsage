<html lang="en"><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Layering -- ImageMagick Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://imagemagick.org/Usage/layers/">
</HEAD><body><main class="container"><div class="magick-template"><div class="magick-header">

<H1>ImageMagick Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Multi-Image Layers</H1>

<div>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#intro"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Layers Introduction</A>
<DD><A HREF="#append"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Appending Images</A> (-append)
    <UL>
    <LI> <A HREF="#append_array"
        >Append an Array of Images</A>
    <LI> <A HREF="#append_overlap"
        >Append with Overlap</A>
    <LI> <A HREF="#smush"
        >Smushing Append</A> (-smush)
    </UL>
<DD><A HREF="#composition"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Composition of Multiple Pairs of Images</A>
    <UL>
    <LI><A HREF="#composite"
        > Using Composite Command</A> (composite, -geometry)
    <LI><A HREF="#convert"
        > Composite Operator of Convert</A>  (-composite, -geometry)
    <LI><A HREF="#draw"
        > Draw Multiple Images</A>  (-draw 'image ..')
    </UL>
<DD><A HREF="#layers"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Layering Multiple Images</A>
    <UL>
    <LI><A HREF="#flatten"
        > Flatten - onto a Background Image</A>
    <LI><A HREF="#mosaic"
        > Mosaics - Canvas Expanding</A>
    <LI><A HREF="#merge"
        > Merging - to Create a New Layer Image</A>
    <LI><A HREF="#coalesce"
        > Coalesce Composition - a Progressive Layering</A>
    <LI><A HREF="#compose"
        > Compose Methods and Layering</A>
    <LI><A HREF="#layer_composite"
        > Layers Composite - Merge Two Image Lists</A>
    </UL>
<DD><A HREF="#layer_examples"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Layering Image Examples</A>
    <UL>
    <LI><A HREF="#layer_thumbnails" >Layering Thumbnails</A>
    <LI><A HREF="#layer_calc"       >Calculated Positioning of Images</A>
    <LI><A HREF="#layer_prog"       >Two Stage Positioning of Images</A>
    <LI><A HREF="#layer_pins"       >Pins in a Map</A>
    <LI><A HREF="#layer_shadow"     >Layers of Shadows</A>
    <LI><A HREF="#layer_distort"    >Distorted Image Placement using Layers</A>
    </UL>
<DD><BR>
<DD><A HREF="#evaluate-sequence"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Evaluate Sequence Multi-Image Merging</A>
    <DL>
    <DD><A HREF="#eval-seq_mean"     >Mean (average)</A>,&nbsp;
        <A HREF="#eval-seq_max"      >Min/Max Value</A>,&nbsp;
        <A HREF="#eval-seq_median"   >Median Pixel</A>, &nbsp;
        <A HREF="#eval-seq_add"      >Add</A>,&nbsp;
        <A HREF="#eval-seq_multiply" >Multiply</A>
    </DL>
<DD><A HREF="#poly"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Poly - Merge Mutli-images Using a Polynomial</A>
</DL>

Overlaying multiple images onto each other to generate a larger 'composite' is
generally known as using image 'layering'.  These examples involve the
combining of multiple 'layers' of images to produce the final larger more
complex image. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="intro"></A>
<H2>Layering Images Introduction</H2>

As we have previously noted, ImageMagick does not deal with just one image,
but a sequence or list of images. This allows you to use IM in two very
special image processing techniques. </P>

You can for example think of each image in the list as a single frame in time,
so that the whole list can be regarded as being a <I>Animation</I>.  This will
be explored in other IM Example Pages.  See <A HREF="../anim_basics/"
>Animation Basics</A>. </P>

Alternatively, you can think of each image in the sequence as <I>Layers</I> of
a set of see-through overhead transparencies.  That is, each image represents
a small part of the final image.  For example: the first (lowest) layer can
represent a  background image.  Above that you can have a fuzzy see though
shadow. Then the next layer image contains the object that casts that shadow.
On top of this a layer with some text that is written over that object. </P>

That is, you can have a sequence of images or 'layers' that each adds one more
piece to a much more complex image.  Each image layer can be moved,
edited, or modified completely separately from any other layer, and even saved
into a multi-image file (such as TIFF:, MIFF: or XCF:) or as separate images,
for future processing.  And that is the point of image layering. </P>

Only when all the image layers have been created do you <A HREF="#flatten"
>Flatten</A>, <A HREF="#mosaic" >Mosaic</A>, or <A HREF="#merge" >Merge</A>
all the <A HREF="#example" >Layered Images</A> into a single final image. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="append"></A>
<H2>Appending Images</H2>

Appending is probably the simplest, of the multi-image operations provided to
handle multiple images. </P>

Basically it joins the current sequence of images in memory into a column, or
a row, without gaps.  The "<CODE><A HREF="../option_link.cgi?append"
>-append</A></CODE>" option appends vertically, while the plus form "<CODE><A
HREF="../option_link.cgi?append" >+append</A></CODE>" appends horizontally.
</P>

For example here we append a set of letter images together, side-by-side,
to form a fancy word, in a similar way that individual 'glyphs' or letters of
a 'font', are joined together.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick font_A.gif font_P.gif font_P.gif font_E.gif font_N.gif \
          font_D.gif font_E.gif font_D.gif +append  append_row.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="append_row.gif"
     ><IMG SRC="append_row.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The above is similar (in a very basic way) to how fonts are handled.  Unlike
real fonts you are not limited to just two colors, but can generate some very
fancy colorful alphabets from individual character images.  Many of these
'image fonts' are available on the WWW for download. A very small set can be
found in <A HREF="http://www.ict.griffith.edu.au/anthony/icons/" >Anthony's Icon
Library</A>, in <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/prog/fonts/Icons.html" >Fonts
for Text and Counters</A>, which is also where I found the above <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/prog/fonts/bubble_blue.xpm"
>Blue Bubble Font</A>. </P>

Note also how the "<CODE><A HREF="../option_link.cgi?append"
>+append</A></CODE>" operator was done as the last operation, after all the
images that you want to append have been added to the current image sequence.
</P>

This is great for appending a label to an image, for example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background LawnGreen label:Rose \
          -background white  -append append_label.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_label.jpg"
     ><IMG SRC="append_label.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the  "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color was used to fill in any space that was not
filled in. Of course if the all the images are the same width, no space will
be left for this fill. </P>

From IM v6.4.7-1 the "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>" setting can be used to specify how the images should be
added together. As such in a vertical append, a setting of
'<CODE>Center</CODE>' will center the image relative to the final resulting
image (so will a setting of either '<CODE>North</CODE>' or
'<CODE>South</CODE>'). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background LawnGreen label:Rose \
          -background white -gravity center -append \
          append_center.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_center.jpg"
     ><IMG SRC="append_center.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Naturally any '<CODE>East</CODE>' gravity setting will align the images on the
right side.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background LawnGreen label:Rose \
          -background white -gravity east -append \
          append_east.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_east.jpg"
     ><IMG SRC="append_east.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Similar vertical alignment can be achieved when using "<CODE><A
HREF="../option_link.cgi?append" >+append</A></CODE>" </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.4.7 it was much more difficult to align appended images, and
  generally involved using a "<CODE><A HREF="../option_link.cgi?flop"
  >-flop</A></CODE>" for right alignment. Or using "<CODE><A
  HREF="../option_link.cgi?extent" >-extent</A></CODE>" or "<CODE><A
  HREF="../option_link.cgi?border" >-border</A></CODE>" to adjust the image
  width for centered aligned appends. </P>

  For example, this will work with an older 6.3.2 version of IM...</I>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background SkyBlue label:Rose \
          -background White -gravity center -extent 200x \
          -append -trim +repage   append_center_old.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_center_old.jpg"
     ><IMG SRC="append_center_old.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

</I></FONT></TD></TR></TABLE></P>


You can also use multiple append operations, in the same command without
conflict or confusion as to the outcome of the operations (which was not the
case before IM v6).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<!-- <CODE EXECUTE>
  magick $HOME/icons/dragons/dragon_long.xpm  dragon_long.gif
</CODE> -->
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick font_{0,0,6,1,2}.gif +append  dragon_long.gif \
          -background none   -append   append_multi.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_multi.gif"
     ><IMG SRC="append_multi.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

We appended each row of images together, then appende a larger image below
that.  This is very simple, and straight-forward.  </P>

By using <A HREF="../basics/#parenthesis" >parenthesis</A>, you can append
just the numbers after the larger image. For example, here append all the
numbers together, before appending them vertically to the dragon image we read
in before the numbers.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick dragon_long.gif  '(' font_{0,0,6,2,9}.gif +append ')' \
          -background none   -append   append_parenthesis.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_parenthesis.gif"
     ><IMG SRC="append_parenthesis.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The parenthesis in the above must be either quoted, or escaped with a
  backslashed ('<CODE>\</CODE>') when used with an UNIX shell, otherwise they
  will be interpreted by the shell as something completely different.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  As only two images were involved we could have just used "<CODE><A
  HREF="../option_link.cgi?swap" >+swap</A></CODE>" or "<CODE><A
  HREF="../option_link.cgi?reverse" >-reverse</A></CODE>" instead of using
  parenthesis.
</I></FONT></TD></TR></TABLE></P>

<A NAME="append_array"></A>
<H2>Append an Array of Images</H2>

<A NAME="append_array"></A>
You can take this further to make a whole array of images, and build them
either by rows, or by columns.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick \( font_1.gif font_2.gif font_3.gif +append \) \
          \( font_4.gif font_5.gif font_6.gif +append \) \
          \( font_7.gif font_8.gif font_9.gif +append \) \
          \( -size 32x32 xc:none  font_0.gif +append \) \
          -background none -append   append_array.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_array.gif"
     ><IMG SRC="append_array.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Technically the first set of parenthesis is not needed, as no images have been
read in yet, but it makes the whole thing look uniform and shows the intent of
the command, in making an array of images. </P>

See also <A HREF="../montage/#concatenate" >Montage Concatenation Mode</A>,
for an alternative way of creating arrays of equal sized images. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?append" >-append</A></CODE>" operator
  will only append the actual images, and does not make use the virtual canvas
  (image page) size, or the image offset.   However the virtual canvas
  information seems to be left in a funny state with the canvas sizes being
  added together and the offset set to some undefined value.  </P>

  This may be regarded as a bug, and means either the input images or result
  should have the virtual canvas reset using "<CODE><A
  HREF="../option_link.cgi?repage" >+repage</A></CODE>", before saving, or
  using the image in operations where this information can become important.
  </P>

  This situation will probably be fixed in some future expansion of the
  operation.  Caution is thus advised, especially if re-appending <A
  HREF="../crop/#crop_tile" >Tile Cropped</A> images.

</I></FONT></TD></TR></TABLE></P>

<A NAME="append_overlap"></A>
<H2>Append with Overlap</H2>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>

On the IM Forum an user asked for a simple way to <A
HREF="../forum_link.cgi?t=30720" >Append images with some overlap</A>.  Many
solutions were offered.  This was one of the simplest solutions, with the
amount of overlap given in a single location.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick granite: rose: -gravity east -background none \
          \( -clone 1 -chop 30x0 \) \( -clone 0,2 +append \) \
          -delete 0,2 +swap -composite append_overlap.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="append_overlap.gif"
     ><IMG SRC="append_overlap.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above did not need to any image positioning calculations, typically
involving image sizes, that would represent a more general solution. See <A
HREF="#layer_examples" >Handling Image Layers</A> below. </P>

What this did was chop off the part that overlapped, before appending the
result to the first image, producing the final image size. The original image
is then composed (with gravity) on top to generate the actual overlap. </P>

It can be easily modified for vertical overlapping, or even right to left
overlapping relatively easily. </P>

<A NAME="smush"></A>
<H2>Smushing Append</H2>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>

Another way of appending images is by smushing.  The "<CODE><A
HREF="../option_link.cgi?smush" >-smush</A></CODE>" operator works much like
the <A HREF="#addend" >Append Operator</A> (see above) does, but it takes an
argument of how much space (or anti-space) you want between the images. </P>

For example, lets use it to so the previous example more simply.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick granite: rose: -background none -gravity Center \
          +smush -20 smush_overlap.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="smush_overlap.png"
     ><IMG SRC="smush_overlap.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

That works very well, though that is not what the operator is actually
designed for, and it is probably a lot slower. </P>

What smush actually is ment to do is move 'shaped images' as close togther as
posible.  For example here I generate the letters '<CODE>A</CODE>' and
'<CODE>V</CODE>' and 'smush' them together with as little space between them
as posible.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -background none -pointsize 72 \
          -fill red label:A -fill blue label:V \
          +smush 0 smush_append.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="smush_append.png"
     ><IMG SRC="smush_append.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice that how the two letters were appended together far closer than append
would, taking advantage of the empty space of the images 'shape'.  The gap in
the above is caused by anti-aliasing edge pixels of the two letters. </P>

That is, what "<CODE><A HREF="../option_link.cgi?smush" >-smush</A></CODE>" is
designed to do, though it requires a lot of calculations, so is a lot slower
than <A HREF="#addend" >Append</A> (see above). </P>

The argument, is an offset for that final position, and is usually a positive
value to generate a gap, but can be negative to create an overlap.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -background none -pointsize 72 \
          -fill red label:A -fill blue label:V \
          +smush -15 smush_offset.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="smush_offset.png"
     ><IMG SRC="smush_offset.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Images may become clipped in undocumented ways if a very large negative value
is used. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="composition"></A>
<H2>Composition of Multiple Pairs of Images</H2>

Composition is the low-level operation that is used to merge two individual
images together.  Almost all layering techniques eventually devolve down to
merging images together two at a time, until only one image is left. </P>

So lets start by looking at ways of doing low-level composition of image
pairs. </P>

<A NAME="composite"></A>
<H3>Using the Composite Command</H3>

The traditional method of combining two images together using ImageMagick is
though the "<code>magick composite</code>" command.  This command can only combine
only two images at a time, saving the results of each operation into a file.
This of course does not stop you from using it to layer multiple images, one
image at a time...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOWARN>
  magick -size 100x100 xc:skyblue composite.gif
  magick composite -geometry  +5+10 balloon.gif composite.gif composite.gif
  magick composite -geometry +35+30 medical.gif composite.gif composite.gif
  magick composite -geometry +62+50 present.gif composite.gif composite.gif
  magick composite -geometry +10+55 shading.gif composite.gif composite.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="composite.gif"
     ><IMG SRC="composite.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  As all input images are read in by ImageMagick BEFORE the output image is
  opened, you can output to one of the input images.  This allows you to
  work on the same image over and over, as shown above, without problems. </P>

  Do not do this with a lossy image format like "JPEG" as the format errors
  are accumulative, and the base image will quickly degrade.

</I></FONT></TD></TR></TABLE></P>

You can also resize the overlaid image as well as position it using the
"<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" setting.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOWARN>
  magick -size 100x100 xc:skyblue comp_resize.gif
  magick composite -geometry 40x40+5+10  balloon.gif comp_resize.gif comp_resize.gif
  magick composite -geometry      +35+30 medical.gif comp_resize.gif comp_resize.gif
  magick composite -geometry 24x24+62+50 present.gif comp_resize.gif comp_resize.gif
  magick composite -geometry 16x16+10+55 shading.gif comp_resize.gif comp_resize.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="comp_resize.gif"
     ><IMG SRC="comp_resize.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The "<code>magick composite</code>" command also has a few other advantages in that
you can use to control the way the image is drawn onto the background with the
"<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>" option and
its relative position is effected by the "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" setting. </P>

You can also "<CODE><A HREF="../option_link.cgi?tile" >-tile</A></CODE>" the
overlay so that it will just cover the background image, without needing to
specify tile limits. This is something only available when using
"<code>magick composite</code>". </P>

The big disadvantage with this method is that you are using multiple commands,
and IM has to write-out the working image, either to a pipeline, or to disk,
for the next command to read-in again. </P>

To find more examples of using the "<code>magick composite</code>" command, to
overlay images on top of other images, see "<A HREF="../annotating/#overlay"
>Annotating by Overlaying Images</A>" and "<A
HREF="../annotating/#image_gravity" >Image Positioning using Gravity</A>".
</P>

<A NAME="magick"></A>
<H3>Composite Operator of Convert</H3>

The "<CODE><A HREF="../option_link.cgi?composite" >-composite</A></CODE>"
operator is available within the "<code>magick</code>" command. For more
details see <A HREF="../compose/#composite" >Image Composition in IM</A>.
This allows you to do the same as the above, but all in one command.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          balloon.gif  -geometry  +5+10  -composite \
          medical.gif  -geometry +35+30  -composite \
          present.gif  -geometry +62+50  -composite \
          shading.gif  -geometry +10+55  -composite \
          compose.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="compose.gif"
     ><IMG SRC="compose.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This first creates a <A HREF="../canvas/#solid" >Canvas Image</A> which is
"<CODE>skyblue</CODE>" in color, and then layers each of the later images onto
that canvas at the given locations. </P>

Now the "<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" is
is a very special operator that not only sets an overlay position for the next
"<CODE><A HREF="../option_link.cgi?composite" >-composite</A></CODE>"
operation, it will also "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" the <I>last</I> image (and only the last image) in the
current image sequence. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          balloon.gif  -geometry 40x40+5+10   -composite \
          medical.gif  -geometry      +35+30  -composite \
          present.gif  -geometry 24x24+62+50  -composite \
          shading.gif  -geometry 16x16+10+55  -composite \
          compose_geometry.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="compose_geometry.gif"
     ><IMG SRC="compose_geometry.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note it is recommended that you avoid this 'resize' side-effect of of the
"<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>", even
if it is convenient.  Basically as it is more of a backward compatibility
effect and may in some situations generate other effects. </P>

Here is the more verbose recommendation...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          \( balloon.gif -resize 40x40 \) -geometry +5+10   -composite \
          \( medical.gif               \) -geometry +35+30  -composite \
          \( present.gif -resize 24x24 \) -geometry +62+50  -composite \
          \( shading.gif -resize 16x16 \) -geometry +10+55  -composite \
          compose_resize.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="compose_resize.gif"
     ><IMG SRC="compose_resize.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="draw"></A>
<H3>Draw Multiple Images</H3>

Also using "<code>magick</code>" you can also use <A
HREF="../draw/#primitive" >Draw Primitives</A> to overlay images onto its
working canvas.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          -draw "image over  5,10 0,0 'balloon.gif'" \
          -draw "image over 35,30 0,0 'medical.gif'" \
          -draw "image over 62,50 0,0 'present.gif'" \
          -draw "image over 10,55 0,0 'shading.gif'" \
          drawn.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="drawn.gif"
     ><IMG SRC="drawn.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can of course also specify a resize for the overlaid image too..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          -draw "image over  5,10 40,40 'balloon.gif'" \
          -draw "image over 35,30  0,0  'medical.gif'" \
          -draw "image over 62,50 24,24 'present.gif'" \
          -draw "image over 10,55 16,16 'shading.gif'" \
          drawn_resize.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="drawn_resize.gif"
     ><IMG SRC="drawn_resize.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The 'drawn' images can also be <A HREF="../draw/#transform" >Rotated, Scaled,
and Affine Distorted</A> during the overlay process. Though that can be tricky
to get working the way you want. </P>

Drawn images are "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>" effected, just like text. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="layers"></A>
<H2>Layering Multiple Images</H2>

True layering of images requires methods to combine multiple images together,
without needing to individually compose each pair of images separately.  This
is where the various <CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE> operator methods come into their own. </P>

Ordering of layered images can be important, so it is a good idea to
understand the special <A HREF="../basics/#image_seq" >Image Sequence or List
Operators</A>. </P>

Note that 'layered images' is practically identical to the handling 'animated
frames'. As such it is recommended you also look at both <A
HREF="../anim_basics/" >Animation Basics</A> and <A HREF="../anim_mods/"
>Animation Modifications</A> for techniques involving processing individual
'layers' or 'frames'.  Actually animations often use the same <CODE><A
HREF="../option_link.cgi?layers" >-layers</A></CODE> operator for processing
images. </P>

<A NAME="flatten"></A>
<H3>Flatten - onto a Background Image</H3>

The "<CODE><A HREF="../option_link.cgi?layers" >-layers</A>
<B>flatten</B></CODE>" image list operator, (or its shortcut "<CODE><A
HREF="../option_link.cgi?flatten" >-flatten</A></CODE>") will basically "<A
HREF="../compose/" >Compose</A>" each of the given images on to a background
to form one single image. However the image positions are specified using
their current  <A HREF="../basics/#page" >Virtual Canvas, or Page</A> offset.
</P>

For example, here I create a nice canvas, and specify each of the images
I want to overlay onto that canvas.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:skyblue \
          -fill dodgerblue -draw 'circle 50,50 15,25' \
          -page +5+10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50 present.gif   -page +10+55 shading.gif  \
          -layers flatten  flatten_canvas.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_canvas.gif"
     ><IMG SRC="flatten_canvas.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  As of IM v6.3.6-2 the "<CODE><A HREF="../option_link.cgi?flatten"
  >-flatten</A></CODE>" operator is only an alias for a  "<CODE><A
  HREF="../option_link.cgi?layers" >-layers</A> 'flatten'</CODE>" method. </P>

  Thus the "<CODE><A HREF="../option_link.cgi?flatten" >-flatten</A></CODE>"
  option can be regarded as a short cut for the "<CODE><A
  HREF="../option_link.cgi?layers" >-layers</A></CODE>" method of the same
  name.

</I></FONT></TD></TR></TABLE></P>

You don't need to create an initial canvas as we did above, you can instead
let "<CODE><A HREF="../option_link.cgi?flatten" >-flatten</A></CODE>" create
one for you.  The canvas color will be the current "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" color, while its
size is defined by the first images <A HREF="../basics/#page" >Virtual
Canvas</A> size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page 100x100+5+10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50        present.gif   -page +10+55 shading.gif  \
          -background dodgerblue  -layers flatten  flatten_page.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_page.gif"
     ><IMG SRC="flatten_page.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  While the "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"
  setting will effect image placement defined using "<CODE><A
  HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" settings, it will
  not effect image positioning using <A HREF="../basics/#page" >virtual canvas
  offsets</A> set via the "<CODE><A HREF="../option_link.cgi?page"
  >-page</A></CODE>" setting.  This is part of the definition of such offsets.
  See <a HREF="../compose/#geometry" >Geometry vs Page Offsets</A> for more
  details.  </P>

  If placement with "<CODE><A HREF="../option_link.cgi?gravity"
  >-gravity</A></CODE>" is need look at either the above multi-image
  composition methods, or the special <A HREF="../anim_mods/#composite"
  >Layers Composition</A> method that can handle both positioning methods
  simultaneously.

</I></FONT></TD></TR></TABLE></P>

If any image does not appear in the defined virtual canvas area, it will
either be clipped or ignored, as appropriate. For example here we used a smaller
canvas size, causing the later images not to appear completely on that canvas.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page 75x75+5+10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50 present.gif   -page +10+55 shading.gif  \
          -background dodgerblue  -flatten  flatten_bounds.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_bounds.gif"
     ><IMG SRC="flatten_bounds.gif"      WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The normal use of <A HREF="#flatten" >Flatten</A> is to merge multiple
'layers' of images together. </P>

That is, you can be generating various parts of a larger image, usually using <A
HREF="../basics/#parenthesis" >Parenthesis</A> to limit image operators to the
single 'layer' image being generated, and then flatten the final result
together. </P>

For example one typical use is to create a <A HREF="../blur/#shadow"
>Shadow Image</A> layer, onto which the original image is flattened.  For
example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick balloon.gif \( +clone  -background navy  -shadow 80x3+5+5 \) +swap \
          -background none   -flatten   flatten_shadow.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_shadow.png"
     ><IMG SRC="flatten_shadow.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that as I want the shadow under the original image, I needed to <A
HREF="../basics/#swap" >swap</A> the two images place them in the right order.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Using <A HREF="#flatten" >Flatten</A> for adding generated  <A
  HREF="../blur/#shadow" >Shadow Images</A> is not recommended, as generated
  shadow images can have negative image offsets.  </P>

  The recommended solution, as given in the section on <A
  HREF="../blur/#shadow" >Shadow Images</A>, is to use the more advanced <A
  HREF="#merge" >Layer Merging</A> technique, we will look at later.

</I></FONT></TD></TR></TABLE></P>


Because the <A HREF="../basics/#page" >Virtual Canvas</A> consists of just a
size, the resulting image will be that size, but have no virtual canvas
offset, as such you do not need to worry about any offsets present in the
final image. </P>

This use of the virtual canvas to define the canvas on which to overlay the
image means you can use it to add a surrounding border to an image.  For
example here I set an image's size and virtual offset to 'pad out' an image to
a specific size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick medical.gif -set page 64x64+20+20 \
          -background SkyBlue   -flatten   flatten_padding.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_padding.gif"
     ><IMG SRC="flatten_padding.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course there are better ways to <A HREF="../thumbnails/#pad" >Pad Out an
Image</A> so that IM automatically centers the image in the larger area. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Strangely the exact same handling can be used to 'clip' or <A
HREF="../crop/#crop" >Crop</A> an image to a virtual canvas that is smaller
than the original image.  In this case however you want to use a negative
offset to position the 'crop' location, as you are offsetting the image and
not positioning the crop 'window'.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick logo:  -repage 100x100-190-60  -flatten  flatten_crop.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_crop.gif"
     ><IMG SRC="flatten_crop.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course a  <A HREF="../crop/#crop_viewport" >Viewport Crop</A> would also do
this better, without the extra processing of canvas generation and overlaying
that "<CODE><A HREF="../option_link.cgi?flatten" >-flatten</A></CODE>" also
does. It also will not 'expand' the image itself to cover the whole viewport
if the image was only partially contained in that viewing window. </P>

A common mis-use of the "<CODE><A HREF="../option_link.cgi?flatten"
>-flatten</A></CODE>" operator is to <A HREF="../masking/#remove" >Remove
Transparency</A> from an image.  That is, to get rid of any transparency that
an image may have, but overlaying it on the background color.  However this
will not work when multiple images are involved as as such no longer
recommended. </P>


<A NAME="mosaic"></A>
<H3>Mosaic - Canvas Expanding</H3>

The "<CODE><A HREF="../option_link.cgi?layers" >-layers</A>
<B>mosaic</B></CODE>" operator (or its "<CODE><A
HREF="../option_link.cgi?mosaic" >-mosaic</A></CODE>" shortcut) is more like
an expanding canvas version of the <A HREF=".#flatten" >Flatten Operator</A>.

Rather than only creating an initial canvas based on just the canvas size of
the initial image, the <A HREF="#mosaic" >Mosaic Operator</A> creates a canvas
that is large enough to hold all the images (in the positive direction only).
</P>

For example here I don't even set an appropriate <A HREF="../basics/#page"
>Virtual Canvas</A>, however the "<CODE><A HREF="../option_link.cgi?mosaic"
>-mosaic</A></CODE>" operator will work out how big such a canvas needs to be
to hold all the image layers.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page +5+10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50 present.gif   -page +10+55 shading.gif  \
          -background dodgerblue  -layers mosaic  mosaic.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="mosaic.gif"
     ><IMG SRC="mosaic.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  As on IM v6.3.6-2 the "<CODE><A HREF="../option_link.cgi?mosaic"
  >-mosaic</A></CODE>" operator is only an alias for a  "<CODE><A
  HREF="../option_link.cgi?layers" >-layers</A> 'mosaic'</CODE>". </P>

  Thus the "<CODE><A HREF="../option_link.cgi?mosaic" >-mosaic</A></CODE>"
  option can be regarded as a short cut for the "<CODE><A
  HREF="../option_link.cgi?layers" >-layers</A></CODE>" method  of the same
  name.

</I></FONT></TD></TR></TABLE></P>

Note that both  "<CODE><A HREF="../option_link.cgi?mosaic"
>-mosaic</A></CODE>" and "<CODE><A HREF="../option_link.cgi?flatten"
>-flatten</A></CODE>" still creates a canvas that started from the 'origin' or
0,0 pixel. This is part of the definition of an images 'virtual canvas' or
'page' and because of this you can be sure that the final image for both
operators will have a no virtual offset, and the whole canvas will be fully
defined in terms of actual pixel data. </P>

Also note that "<CODE><A HREF="../option_link.cgi?mosaic" >-mosaic</A></CODE>"
will only expand the canvas in the positive directions (the bottom or right
edges), as the top and left edge are fixed to the virtual origin. That of
course means "<CODE><A HREF="../option_link.cgi?mosaic" >-mosaic</A></CODE>"
will still clip images with negative offsets...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page -5-10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50 present.gif   -page +10+55 shading.gif  \
          -background dodgerblue  -mosaic  mosaic_clip.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="mosaic_clip.gif"
     ><IMG SRC="mosaic_clip.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="merge"></A>
<H3>Merging - to Create a New Layer Image</H3>

The "<CODE><A HREF="../option_link.cgi?layers" >-layers</A> <B>merge</B></CODE>"
operator is almost identical to the previous operators and was added with IM
v6.3.6-2.   It only creates a canvas image just large enough to hold all the
given images at their respective offsets. </P>

Like <A HREF="#mosaic" >Mosaic</A> will also expand the canvas, but not only
in the positive direction, but also in the negative direction.  Basically it
means that you don't have to worry about clipping, offset, or other aspects
when merging layer images together.  All images will be merged relative to
each others location. </P>

The output does not include or ensure the origin is part of the expanded
canvas.  As such the output of a <A HREF="#merge" >Layers Merge</A> can
contain a 'layers offset' which may be positive or negative. </P>

In other words.. <A HREF="#merge" >Layers Merge</A> merges layer images to
produce a new <I>layer image</I>. </P> As such if you don't want that offset
when finished you will probably want to include a "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" operator before the
final save. </P>

For example here is the same set of layer image we have used previously...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page +5+10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50 present.gif   -page +10+55 shading.gif  \
          -background dodgerblue  -layers merge  +repage layers_merge.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="layers_merge.gif"
     ><IMG SRC="layers_merge.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the image is only just big enough to hold all the images which
were placed relative to each other, while I discarded the resulting images
offset relative to the virtual canvas origin.   This preservation of relative
position without clipping or extra unneeded space is what make this variant so
powerful. </P>


Lets try this again by giving one image a negative offset...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page -5-10  balloon.gif   -page +35+30 medical.gif  \
          -page +62+50 present.gif   -page +10+55 shading.gif  \
          -background dodgerblue  -layers merge  +repage layers_merge_2.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="layers_merge_2.gif"
     ><IMG SRC="layers_merge_2.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the "balloon" was not clipped, just moved further away from the
others so as to preserve its relative distance to them. </P>

Of course the "<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>"
operator in the above examples, removes the absolute virtual canvas offset in
the final image, preserving only the relative image placements between the
images.  The offset was removed as web browsers often have trouble with image
offsets and especially negative image offsets, unless part of a GIF animation.
</P>

But if I did not remove that offset, all the images will remain in their
correct location on the virtual canvas within the generated single layer
image, allowing you to continue to process and add more images to the merged
image.  Typically you would use a "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" color of
'<CODE>None</CODE>', to make the unused areas of the merged image transparent.
</P>

When applied to a single image, <A HREF="#merge" >Layer Merging</A> will
replace any transparency in the image with the solid color background, but
preserve the images original size, as well as any any offsets in that image,
The virtual canvas size of the image however may be adjusted to 'best fit'
that images size and offset. </P>

The operators original purpose was allow users to more easily merge multiple
distorted images into an unified whole, regardless of the individual images
offset.  For example when aligning photos to form a larger 'panorama'.   You
could simply start with a central undistorted base image (without an offset),
and use this operator to overlay the other images around that starting point
(using either negative or positive offsets) that have been aligned and
distorted to match that central image.  </P>

For other examples of using this operator by distorting images to align common
control points, see <A HREF="../distorts/#cube3d" >3D Isometric Photo
Cube</A>, and <A HREF="../distorts/#cube3d" >3D Perspective Box</A>. </P>

Other examples of using this operator is to generate a simple series of <A
HREF="../photos/#overlap" >Overlapping Photos</A>. </P>

<PRE>
The operation "<CODE>-layers trim-bounds</CODE>" can be used to ensure all
images get a positive offset on a minimal canvas size, while retaining there
relative positions, and without actually layer merging the images into one
final image.

This lets you then perform further processing of the images before they are
actually merged, such as placing more images relative to the that image group
but looking up the resulting virtual canvas bounds.

However if images have a transparency, it is probably a good idea to trim
that transparency from images first, making the ideal usage...

  -alpha set -bordercolor none -border 1x1 -trim -layers trim-bounds

This minimizes the image layers including any and all transparent areas of
actual image data, while ensuring everything is contained on a valid
virtual (positive) canvas of minimal size.

</PRE>

<A NAME="coalesce"></A>
<H3>Coalesce Composition - a Progressive Layering</H3>

The "<CODE><A HREF="../option_link.cgi?layers" >-layers</A>
<B>coalesce</B></CODE>" image operator (or its "<CODE><A
HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" shortcut) is really
designed for converting GIF animations into a sequence of images. For
examples, see <A HREF="../anim_basics/#coalesce" >Coalescing Animations</A>
for details. </P>

However, it is very closely associated with "<CODE><A
HREF="../option_link.cgi?flatten" >-flatten</A></CODE>" and has very useful
effects for multi-layered images in this regard.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example using <A HREF="#coalesce">Coalesce</A> on a single image, will do
exact the same job as using <A HREF="#flatten" >Flatten</A> with a "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" color of
'<CODE>None</CODE>' or '<CODE>Transparency</CODE>'.  That is, it will 'fill
out' the canvas of the image with transparent pixels.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page 100x100+5+10 balloon.gif -layers coalesce  coalesce_canvas.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="coalesce_canvas.gif"
     ><IMG SRC="coalesce_canvas.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

When dealing with an image consisting on multiple layers, <A HREF="#coalesce"
>Coalesce</A> can be used to generate a  'Progressive Layering' of the image.
But to do this we need to take a few precautions, to disable any 'GIF
animation' handling by the operator.  </P>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick -page 100x100+5+10 balloon.gif   -page +35+30 medical.gif  \
           -page +62+50       present.gif   -page +10+55 shading.gif  \
           -set dispose None  -coalesce  miff:- |\
     montage - -frame 4 -tile x1 -geometry +2+2 \
             -background none -bordercolor none  coalesce_none.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="coalesce_none.gif"
     ><IMG SRC="coalesce_none.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

In the above, we "<CODE><A HREF="../option_link.cgi?set" >-set</A></CODE>" all
the "<CODE><A HREF="../option_link.cgi?dispose" >-dispose</A></CODE>" settings
to '<CODE><A HREF="../anim_basics/#none" >None</CODE></A>'.  This effectively
tells "<CODE><A HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" to
just overlay each frame on top the results of the previous overlays. </P>

The result is the first image is just a 'fill out' of the images canvas, with
a transparency background.  The next image is the previous image with that
layer overlaid. And so on.   A 'progressive' flatten of the image sequence.
</P>

The last image in the sequence will thus be the same as if you did a normal
"<CODE><A HREF="../option_link.cgi?flatten" >-flatten</A></CODE>" with a
transparent background. </P>

You can get a completely different sort of effect if you had used a "<CODE><A
HREF="../option_link.cgi?dispose" >-dispose</A></CODE>" setting of '<CODE><A
HREF="../anim_basics/#background" >Background</CODE></A>'.   In this case
"<CODE><A HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" will just
'fill out' the canvas of each image, as if they were completely separate
images!

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page 100x100+5+10 balloon.gif   -page +35+30 medical.gif  \
          -page +62+50       present.gif   -page +10+55 shading.gif  \
          -set dispose Background  -coalesce  miff:- |\
    montage - -frame 4 -tile x1 -geometry +2+2 \
            -background none -bordercolor none  coalesce_bgnd.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="coalesce_bgnd.gif"
     ><IMG SRC="coalesce_bgnd.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Please note however that unlike <A HREF="#flatten" >Flatten</A>, <A
HREF="#mosaic" >Mosaic</A>, or <A HREF="#merge" >Merge</A> the "<CODE><A
HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" operator does
<I>not</I> make use of the current "<CODE><A HREF="../option_link.cgi?compose"
>-compose</A></CODE>" alpha composition setting. It only uses an '<CODE><A
HREF="../compose/#over" >Over</A></CODE>' compose method, as this is what is
required for GIF animation handling.  </P>

Using different "<CODE><A HREF="../option_link.cgi?compose"
>-compose</A></CODE>" methods with the more standard image layering operators
is the subject of the next set of examples. </P>

<A NAME="compose"></A>
<H3>Compose Methods and Layering</H3>

The three <A HREF="#layers" >Layering</A> methods: <A HREF="#flatten"
>Flatten</A>, <A HREF="#mosaic" >Mosaic</A>, and <A HREF="#merge" >Merge</A>;
will make use of the "<CODE><A HREF="../option_link.cgi?compose"
>-compose</A></CODE>" setting to determine the composition method used to
overlay each image in sequence.  As such you could think of these functions as
a multi-image "<CODE><A HREF="../option_link.cgi?composite"
>-composite</A></CODE>" operator with the ability to set an initial "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" canvas of
a specified color.
</P>

However using anything but the default <A HREF="../compose/" >Alpha
Composition</A> of '<CODE>Over</CODE>' requires some thought before applying
or you will get unexpected results. You may also may need to think about the
effect of the "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color that is used by these operators to generate
a starting canvas, onto with each image (including the first) in composed.
</P>

For example lets place each successive image <I>under</I> the previous images
using a '<CODE><A HREF="../compose/#dstover" >DstOver</A></CODE>'...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page 100x100+5+10 balloon.gif   -page +35+30 medical.gif  \
          -page +62+50       present.gif   -page +10+55 shading.gif  \
          -background none  -compose DstOver  -flatten  flatten_dstover.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="flatten_dstover.gif"
     ><IMG SRC="flatten_dstover.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here the background was set to be transparent, otherwise you will only see the
background canvas in the result as all the other images will have been placed
'under' this initial canvas!  This does provide a way of 'blanking' an image
with a particular color, as shown in <A HREF="../canvas/#sized" >Canvases
Sized to an Existing Image</A>.  </P>

Here is a more practical example.  Rather than layering the images with the
background canvas first, which awkward and un-natural in some image processing
situations, you can just generate the images top-down or foreground to
background order.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -repage +10+10 \
          \( +clone -background black -shadow 60x3+5+5 \) \
          \( granite: -crop 100x80+0+0 +repage \) \
          -background none  -compose DstOver -layers merge layer_dstover.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="layer_dstover.gif"
     ><IMG SRC="layer_dstover.gif"    WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Each of the first three lines generates one layer image, with the
final line merging all the layers under the previous layers, effectively
reversing the order. <P>

As you can see the image processing for the above was simpler and cleaner
than you normally would see with shadow generation, just by underlaying each
image in sequence (with a transparent starting canvas) </P>

Of course I could have just as easily <A HREF="../basics/#reverse"
>Reverse</A> the image list instead.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -repage +10+10 \
          \( +clone -background black -shadow 60x3+5+5 \) \
          \( granite: -crop 100x80+0+0 +repage \) \
          -reverse -layers merge layer_reverse.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="layer_reverse.gif"
     ><IMG SRC="layer_reverse.gif"    WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However remember that this only re-orders the existing images, and does
not effect the 'starting background canvas' that the layering methods create.

The compose methods can also be used to produce some interesting effects.  For
example, if you draw three circles, then by overlaying them using the
'<CODE>Xor</CODE>' compose method, you get an unusual and complex looking
symbol, for minimal effort.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x60 \
          \( xc:none -fill blue   -draw 'circle 21,39 24,57' \) \
          \( xc:none -fill red    -draw 'circle 39,39 36,57' \) \
          \( xc:none -fill green  -draw 'circle 30,21 30,3'  \) \
          -background none  -compose Xor   -flatten  flatten_xor.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="flatten_xor.png"
      ><IMG SRC="flatten_xor.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="layer_composite"></A>
<H3>Layers Composite - Merge Two Layer Lists</H3>

With IM v6.3.3-7 the "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE>" method, '<CODE><B>Composite</B></CODE>' was added
allowing you compose two completely separate sets of images together. </P>

To do this on the command line a special  '<CODE><A HREF="../files/#null"
>null:</A></CODE>' marker image is needed to define where the first
<I>destination</I> list of images ends and the overlaid <I>source</I> image
list begins. But that is the only real complication of this method. </P>

Basically each image from the first list is composed against the corresponding
image in the second list, effectively merging the two lists together. </P>

The second list can be positioned globally relative to the first list, using
a <A HREF="../compose/#geometry" >Geometry Offset</A>, just as you can with
a normal <A HREF="../compose/#convert" >Composite Operator</A> (see above).
Gravity is also applied using the canvas size of the first image, to do the
calculations. </P>

On top of that 'global offset', the individual virtual offset of image is also
preserved, as each pair of images is composited together. </P>

One special case is also handled.  If one of the image lists contains only one
image, that image will be composed against all the images of the other list.
Also in that case the image meta-data (such as animation timings) of larger
list is what will be kept, even if it is not the destination side of the
composition. </P>

<BR>

This laying operator is more typically used when composing two animations,
which can be regarded as a sort of time-wise layered image list.  Because of
this it is better exampled in the <A HREF="../anim_mods/" >Animation
Modifications</A> section of the examples. So see <A
HREF="../anim_mods/#compose" >Multi-Image Alpha Composition</A> for more
details. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="layer_handling"></A>
<A NAME="layer_examples"></A>
<H2>Handling Image Layers</H2>

Laying multiple images using the various layer operators above is a very
versatile technique.  It lets you work on a large number of images
individually, and then when finished you combine them all into a single
unified whole.  </P>

So far we have shown various ways of merging (composing or layering) multiple
images in many different ways.  Here I provide some more practical examples on
just how to make use of those techniques. </P>


<A NAME="layer_thumbnails"></A>
<H3>Layering Of Thumbnail Images</H3>

You can also use this technique for merging multiple thumbnails together in
various complex ways. </P>

Here I add a <A HREF="../thumbnails/#soft_edges" >Soft Edge</A> to the images
as you read and position them, you can generate a rather nice composition of
images, on a <A HREF="../canvas/#tile" >Tiled Canvas</A>.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -page +5+5    holocaust_tn.gif \
          -page +80+50  spiral_stairs_tn.gif \
          -page +40+105 chinese_chess_tn.gif \
          +page \
          -alpha Set -virtual-pixel transparent \
          -channel A -blur 0x10  -level 50,100% +channel \
          \( -size 200x200 tile:tile_fabric.gif -alpha Set \) -insert 0 \
          -background None -flatten  overlap_canvas.jpg
</samp></pre></TD></TR></TABLE>
   <A HREF="overlap_canvas.jpg"
      ><IMG SRC="overlap_canvas.jpg"     WIDTH=200  HEIGHT=200
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<A NAME="layer_calc"></A>
<H3>Calculated Positioning of Images.</H3>

The <A HREF="../basics/#page" >Virtual Canvas Offset (page)</A> can be set in
many ways.  More specifically you can "<CODE><A HREF="../option_link.cgi?set"
>-set</A></CODE>" set this per-image <A HREF="../basics/#attribute"
>Attribute</A>, and even calculate a different location for each and every
image. </P>

For example here I read in a big set of images (small icon images all the same
size) and arrange them in a circle.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick {balloon,castle,eye,eyeguy,ghost,hand_point,medical}.gif \
          {news,noseguy,paint_brush,pencil,present,recycle}.gif \
          {shading,skull,snowman,storm,terminal,tree}.gif \
          \
          -set page '+%[fx:80*cos((t/n)*2*pi)]+%[fx:80*sin((t/n)*2*pi)]' \
          \
          -background none -layers merge +repage image_circle.png
</samp></pre></TD></TR></TABLE>
   <A HREF="image_circle.png"
      ><IMG SRC="image_circle.png"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The key to the above example is the "<CODE><A HREF="../option_link.cgi?set"
>-set</A> page</CODE>" operation that uses the normalized image index (the <A
HREF="https://imagemagick.org/script/fx.php" >FX Expression</A>
'<CODE>t/n</CODE>'&nbsp;) to create a value from 0.0 to not quite 1.0 for each
individual image. This value is then mapped to position the image (by angle)
in a circle of 80 pixels radius, using <A HREF="../transform/#fx_escapes" >FX
Expressions as a Percent Escape</A>. </P>

The position calculated is of the top-left corner of the image (not its
center, though that is a simple adjustment), which is then <A HREF="#merge"
>Merged</A> to generate a new image.  The positioning is done without regard
of the offset being positive or negative, which is the power of the  <A
HREF="#merge" >Merge Laying Operator</A>.  That is, we generated a new image of
all the images as they are relative to each other. </P>

The final "<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>"
removes the final resulting negative offset of the merged layer image, as this
is no longer needed and can cause problems when viewing the resulting image.
</P>

Note that the first image (right-most in result) is layered below every other
image.  If you want the layering to be truly cyclic so the last image was
below this first one, you may have to divide that first image in half and put
the top half at the end of the sequence so the top half of the first image
layers over last image, while the lower half remains below the second image.
</P>

This technique is powerful, but it can only position images to an integer
offset. If you need more exact sub-pixel positioning of images then the
images will need to be distorted (translated) to the exact sub-pixel location
rather than simply adjusting its virtual offset. </P>


<A NAME="layer_calc_inc"></A>
<H4>Incrementally Calculated Positions</H4>

You can access some image attributes of other images using FX expressions,
while setting the attribute of images as they are processed.  This means that
you can set the location of each image, relative the calculated position of
the previous image. </P>

For example this sets the position of each image to be to the right of the
previous image. That is, the previous image's position plus its width.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: netscape: granite: \
          \
          +repage -set page '+%[fx:u[t-1]page.x+u[t-1].w]+0' \
          \
          -background none -layers merge +repage append_diy.png
</samp></pre></TD></TR></TABLE>
   <A HREF="append_diy.png"
      ><IMG SRC="append_diy.png"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Each image is appended to the location of the previous image, by looking up
that location and adding that images width.  This previous location was in
fact just calculated, as IM looped through each image setting the
'<CODE>page</CODE>' (virtual offset) attribute.  The result is a DIY <A
HREF="#append" >Append Operator</A> equivalent, and from which you can develop
your own variations.  </P>

You should note that the whole sequence is actually shifted by
'<CODE>u[-1].w</CODE>' set during the position calculation of the first image.
This should be the width of the last image in the current image sequence.
That overall displacement however is junked by the final "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>". You can use some extra
calculation to have it ignore this offset, but it isn't needed in the above.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  When using an image index such as '<CODE>u[t]</CODE>' all image selectors
  '<CODE>u</CODE>', '<CODE>v</CODE>', and '<CODE>s</CODE>', all references the
  same image, according to the '<CODE>[index]</CODE>' given. As such it is
  better to use '<CODE>u</CODE>' (the first or zeroth image) as a mnemonic of
  this indexing behaviour (and in case this changes).</P>

  For more information see <A HREF="../transform/#fx" >FX, The DIY Image
  Operator</A>.

</I></FONT></TD></TR></TABLE></P>

Here is another example. Each image is offset relative to the previous image,
using both position and width of that image, so as to calculate a <A
HREF="#append_overlap" >Overlapped Append</A>.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
magick font_[0-9].gif \
        -set page '+%[fx:u[t-1]page.x+u[t-1].w-8]+%[fx:u[t-1]page.y+4]' \
        -background none -layers merge +repage append_offset.gif
</samp></pre></TD></TR></TABLE>
   <A HREF="append_offset.gif"
      ><IMG SRC="append_offset.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This ability to access attributes of other images, also includes the pixel
data of other images.   That means you could create a special image where the
color values represent the 'mapped positions' of the other images.  Of course
that 'mapping' image would also be positioned, and would need to be removed
before the overlay is performed.  How useful creating special 'mapped
position' images is another matter.  It is just another possibility. </P>


<A NAME="layer_prog"></A> <H3>Two Stage Positioning of Images</H3>

You can simplify your image processing, by separating them into two steps. One
step can be used to generate, distort, position and add fluff to images, with
a final step to merge them all together.

For example, lets create <A HREF="../transform/#polaroid" >Polaroid
Thumbnails</A> from the larger original images in <A
HREF="../img_photos/INDEX.html" >Photo Store</A>, processing each of them
individually (keeping that aspect separate and simple). </P>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT RANDOM IMAGE=overlapped_polaroids.jpg>
  center=0   # Start position of the center of the first image.
             # This can be ANYTHING, as only relative changes are important.

  for image in ../img_photos/[a-m]*_orig.jpg
  do

    # Add 70 to the previous images relative offset to add to each image
    #
    center=`magick xc: -format "%[fx: $center +70 ]" info:`

    # read image, add fluff, and using centered padding/trim locate the
    # center of the image at the next location (relative to the last).
    #
    magick -size 500x500 "$image" -thumbnail 240x240 \
            -set caption '%t' -bordercolor Lavender -background black \
            -pointsize 12  -density 96x96  +polaroid  -resize 30% \
            -gravity center -background None -extent 100x100 -trim \
            -repage +${center}+0\!    MIFF:-

  done |
    # read pipeline of positioned images, and merge together
    magick -background skyblue   MIFF:-  -layers merge +repage \
            -bordercolor skyblue -border 3x3   overlapped_polaroids.jpg

</samp></pre></TD></TR></TABLE>
  <A HREF="overlapped_polaroids.jpg"
     ><IMG SRC="overlapped_polaroids.jpg"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The script above seem complicated but isn't really. It simply generates each
thumbnail image in a loop, while at the same time center pads (using <A
HREF="../crop/#extent" >Extent</A>) and <A HREF="../canvas/#trim" >Trims</A>
each image so that the images 'center' is in a known location on the virtual
canvas.  It could actually calculate that postion, though that may require
temporary files, so it is better to ensure it is in a well known location,
for all images. </P>

The image is then translated (using a relative "<CODE><A
HREF="../option_link.cgi?repage" >-repage</A></CODE>" operator, see <A
HREF="../basics/#page" >Canvas Offsets</A>), so that each image generated will
be exactly 60 pixels to the right of the previous image.  That is, each image
center is spaced a fixed distance apart, regardless of the images actual size,
which could have changed due to aspect ratios and rotations. </P>

The other major trick with this script is that rather than save each 'layer
image' into a temporary file, you can just write the image into a pipeline
using the <A HREF="../files/#miff" >MIFF:</A> file format.  A method known as
a <A HREF="../files/#miff_stream" >MIFF Image Streaming</A>.  </P>

This works because the "<CODE>MIFF:</CODE>" file format allows you to simply
concatenate multiple images together into a single data stream, while
preserving all the images meta-data, such as its virtual canvas offset. </P>

This technique provides a good starting point for many other scripts.  Images
can be generated, or modified and the final size and position can be
calculated in any way you like. </P>

Another example is the script "<CODE><A HREF="../scripts/hsl_named_colors"
>hsl_named_colors</A></CODE>" which takes the list of named colors found in
ImageMagick and sorts them into a chart of those colors in HSL colorspace.
You can see its output in <A HREF="../color_basics/#colors" >Color
Specification</A>.  </P>

Other possibilities include...<UL>
<LI>Use any type of thumbnail (or other <A HREF="../thumbnails/#fluff"
    >Fluff</A>), or just simply use a raw small thumbnail directly.

<LI>Generate images so the first image is centered and the other images are
    arrange to the left and right under that first image, like a pyramid.

<LI>Position images into Arcs, Circles and spirals, by placing them at
    specific X and Y coordinates relative to each other.  For example: <A
    HREF="http://www.flickr.com/photos/dsevilla/2363002372" >PhD Circle</A>,
    <A HREF="http://www.flickr.com/photos/krazydad/4994679" >Sunset
    Flower</A>, <A HREF="http://www.flickr.com/photos/krazydad/4109739"
    >Fibonacci Spiral</A>.

<LI>Position images according to their color.  For example: <A
    HREF="http://www.flickr.com/photos/davepattern/2954305171" >Book
    Covers</A>.

<LI>Position images by time of day or time submitted.  For example: <A
    HREF="http://www.flickr.com/photos/krazydad/292081922" >Year of
    Sunsets</A>

</UL>

Basically you have complete freedom in the positioning of images on the
virtual canvas, and can then simply leave IM to sort out the final size of the
canvas needed to whole all the images. </P>


<A NAME="layer_pins"></A>
<H3>Pins in a Map</H3>

Here is a typical layering example, placing coloured pins in a map,
at specific locations.  </P>

<A HREF="../images/push_pin.png"
   ><IMG SRC="../images/push_pin.png"     WIDTH=50  HEIGHT=43
         ALIGN=left VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>

To the left is a 'push pin' image.  The end of the pin is at position
<CODE>+18+41</CODE>.
</P>

I also have an image of a <A HREF="../images/map_venice.jpg" >Map of Venice</A>, and want
to put a pin at various points on the map.  For example 'Accademia' is locate
at pixel position, <CODE>+160+283</CODE>. </P>

To align the push-pin with that position you need to subtract the location of
the end of the pin from map position. This produces an offset of
<CODE>+142+242</CODE> for our 'pin' image. </P>

Here is the result, using layered images

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick map_venice.jpg    -page +142+242 push_pin.png \
          -flatten  map_push_pin.jpg
</samp></pre></TD></TR></TABLE>
   <A HREF="map_push_pin.jpg"
      ><IMG SRC="map_push_pin.jpg"     WIDTH=466  HEIGHT=350
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This example was from an IM Forum Discussion, <A
HREF="../forum_link.cgi?f=1&t=20251" >Layering Images with Convert</A>. </P>

<B>Lets automate this further.</B> </P>

We have a file listing the locations and colors for each of the pins we want
to place in the map. The location name in the file is not used and is just
a reference comment on the pixel location listed.

<!-- <CODE EXECUTE>
  txt2gif map_venice_pins.txt
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="../images/map_venice_pins.txt"
     ><IMG SRC="map_venice_pins.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[Data File]"></A>
</TD></TR></TABLE>
</DIV></P>

Lets read this text file, to create 'pins' in a loop.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT RANDOM IMAGE=map_venice_pins.jpg>

  pin_x=18  pin_y=41

  cat map_venice_pins.txt |\
    while read x y color location; do

      [ "X$x" = "X#" ] && continue   # skip comments in data

      x=$(( x - pin_x ))    # magick x,y to pin image offsets
      y=$(( y - pin_y ))

      # magick 'color' to settings for color modulate (hue only)
      # assumes a pure 'red' color for the original push pin
      mod_args=$(
         magick xc:$color -colorspace HSL txt: |
           tr -sc '0-9\012' ' ' |\
             awk 'NR==1 { depth=$3 }
                  NR==2 { hue=$3;
                          print  "100,100,"  100+200*hue/depth
                        }'; )

      # re-color and position the push pin
      magick push_pin.png -repage +${x}+${y} -modulate $mod_args miff:-

    done |\
      # read pipeline of positioned images, and merge together
      magick map_venice.jpg  MIFF:-  -flatten  map_venice_pins.jpg

</samp></pre></TD></TR></TABLE>
  <A HREF="map_venice_pins.jpg"
     ><IMG SRC="map_venice_pins.jpg"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note it assumes the original pin color is red ( which has a hue of 0 ) and
uses the <A HREF="../color_mods/#modulate" >Modulate Operator</A> to re-color
it to other colors, with the appropriate scaling calculations.  Note that the
modulate argument for a no-op hue change is 100, with it cycling over a value
of 200 (a sort of pseudo-percentage value). </P>

<I>FUTURE: perspective distort map, adjust pin size for 'depth' on the map
calculate change in pin position due to distortion, and 'pin' it to the
distorted map. </I></P>

The above used a method known as a <A HREF="../files/#miff_stream" >MIFF Image
Streaming</A>, with each image generated individually in a loop, then 'piped'
into the 'layering' command to generate the final image.  </P>

The alternative method (commonly using in PHP scripts) is to use a 'generated
command' technique, that uses a shell script to generate a long
"<code>magick</code>" command to be run. The scripts in <A
HREF="../warping/#animations" >Image Warping Animations</A> use this
technique. </P>

Both methods avoid the need to generate temporary images. </P>


<A NAME="layer_shadow"></A>
<H3>Layers of Shadows</H3>

Correctly handling semi-transparent shadow effects in a set of overlapping
images is actually a lot more difficult than it seems.  Just overlaying photos
with shadows will cause the shadows to be applied twice.  That is, two
overlapping shadows become very dark, where in reality they do not overlay
together in quite the same way that the overlaying images do. </P>

The various parts of the image should be simply shadowed or not
shadowed. That is, shadows should be applied once only to any part of the
image.  You should not get darker areas, unless you have two separate light
sources, and that can make things harder still. </P>

Tomas Zathurecky &lt; tom &#64; ksp.sk &gt; took up the challenge of handling
shadow effects in layered images, and developed image accumulator technique,
to handle the problem. </P>

Basically we need to add each image to the bottom of stack one at a time.
As we add a new image the shadow of all the previous images needs to
darken the new image, before it is added to the stack.

However only the shadow falling on the new image, needs to be added. Shadows
not falling on the new image needs to be ignored until later, when it falls on
some other image, or the background (if any). </P>

Here is an example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( -clone 0   -background black -shadow 70x3+4+7 \
       -clone 1   -background black -compose DstATop -layers merge \
       -trim \) \
    \( -clone 2,0 -background none  -compose Over -layers merge \) \
    -delete 0--2 \
    \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \( -clone 0   -background black -shadow 70x3+4+7 \
       -clone 1   -background black -compose DstATop -layers merge \
       -trim \) \
    \( -clone 2,0 -background none  -compose Over -layers merge \) \
    -delete 0--2 \
    \
    \( +clone -background black -shadow 70x3+4+7 \) +swap \
    -background none -compose Over -layers merge +repage \
    layers_of_shadows.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="layers_of_shadows.png"
     ><IMG SRC="layers_of_shadows.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above program seems complex, but is actually quite straight forward. </P>

The first image is used to start an accumulating stack of images (image index
#0). </P>

Note we could have actually started with a single transparent pixel
("<CODE>-size&nbsp;1x1&nbsp;xc:none</CODE>"), if you don't want to use that
first image to initialize the stack.  </P>

Now to add a new image to the bottom of the image stack, we apply the same set
of operations, each time...

<UL>
<LI>First the thumbnail image is read into memory, and any rotations, relative
    placements (may be negative), is applied.  You could also do apply other
    thumbnailing operations to the image at this point if you want, though for
    his example that have already been performed.  The new image forms image
    index #1.
<LI>We now grab the previous stack of images (#0), generate a shadow with
    appropriate color, blur, offset, and ambient light percentage.
<LI>This shadow is overlaid on the new image (#1) so only the shadow that
    falls '<CODE><A HREF="../compose/#atop" >ATop</A></CODE>' the new image is
    kept.  We also (optionally) apply a <A HREF="../crop/#trim" >Trim
    Operation</A> the result to remove any extra space added from the
    shadowing operation, to form image #2.
<LI>Now we simply add the new image (#2) to the accumulating stack of images
    (#0).
<LI>and delete all the previous working images, except the last.
</UL></P>

To add more images we basically just repeat the above block of operations.
</P>

After all the images has been added to the stack, it is simply a matter of
doing a normal shadowing operation on the accumulated stack of images.
removing any remaining image offsets (which many web browsers hate). </P>

Using <A HREF="#merge" >Merge</A> I can automatically handle virtual offsets,
especially negative ones, allowing to to simply place images anywhere you like
relative to the previous image placements.  It also make applying shadows
which can generate larger images with negative offsets properly. </P>

<BR>

Now the above handles multi-layered image shadows properly, but while the
shadow is offset, it is actually offset equally for all the images! </P>

What really should happen is that the shadow should become more offset
and also more blurry as it falls on images deeper and deeper in the stack.
That is, an image at the top should case a very blurry shadow on the background,
compared to the bottom-most image.  </P>

This is actually harder to do as you not only need to keep a track of the
stack of images, you also need to keep a track of how 'fuzzy' the shadow has
become as the stack of images becomes larger.  Thus you really need two
accumulators.  The image stack (as above), and the shadow accumulation, as we
add more images. </P>

For example here is the same set of images but with shadows that get more
blurry with depth.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick xc:none xc:none \
    \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \( -clone 1   -background black -shadow 70x0+0+0 \
       -clone 2   -background black -compose DstATop -layers merge \
       -clone 0   -background none  -compose Over    -layers merge \) \
    \( -clone 2,1 -background none  -compose Over    -layers merge \
                  -background black -shadow 100x2+4+7 \) \
    -delete 0-2 \
    \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( -clone 1   -background black -shadow 70x0+0+0 \
       -clone 2   -background black -compose DstATop -layers merge \
       -clone 0   -background none  -compose Over    -layers merge \) \
    \( -clone 2,1 -background none  -compose Over    -layers merge \
                  -background black -shadow 100x2+4+7 \) \
    -delete 0-2 \
    \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \( -clone 1   -background black -shadow 70x0+0+0 \
       -clone 2   -background black -compose DstATop -layers merge \
       -clone 0   -background none  -compose Over    -layers merge \) \
    \( -clone 2,1 -background none  -compose Over    -layers merge \
                  -background black -shadow 100x2+4+7 \) \
    -delete 0-2 \
    \
    \( -clone 1 -background black -shadow 70x0+0+0 \
       -clone 0 -background none -compose Over -layers merge \) \
    -delete 0-1 -trim +repage \
    layers_of_deep_shadows.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="layers_of_deep_shadows.png"
     ><IMG SRC="layers_of_deep_shadows.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Look carefully at the result.  The offset and blurriness of the shadow is
different in different parts of the image.  It is very thin between images in
adjacent layers, but very thick when it falls on an image, or even the
background much deeper down. </P>

Of course in this example, the shadow offset is probably too large, but the
result seems very realistic giving a better sense of depth to the layers.  </P>

Note how we split the operation of shadow into two steps.  When applying the
accumulated shadow (image index #1) to the new image (#2), we only add the
ambient light percentage, without any blur, or offset ('<CODE>70x0+0+0</CODE>'
in this case). </P>

The new image is then added to the accumulating stack of images (#0). </P>

But after adding new images (#2) shadow directly to the accumulated shadow
(#1), again without blur or offset, only then do we blur and offset ALL the
shadows, to form the new accumulated shadow image. </P>

In other words, the accumulated shadow image becomes more and more blurry and
offset as the stack gets thicker and thicker. Only the shadow of deeper images
has not accumulated the effect as much. </P>

This program essentually separates the application of the shadow, from the
incremental shadow accumulator.  This allows you control things like...

<UL>
<LI>Realistic Shadow (as above): 70x0+0+0 and 100x2+4+7
<LI>Constant Shadow (as basic example): 70x2+4+7 and 100x0+0+0
<LI>constant blur, but cumulative offset: 70x2+0+0 and 100x0+4+7
<LI>both constant and progressive offset: 60x0+4+7 and 100x0+1+1
<LI>cumulative ambient light effect: 80x0+0+0 and and 95x2+4+7
</UL>
Most of them are probably unrealistic, but may look good in another situations.

Also setting the "<CODE>-background</CODE>" color before the "<CODE>-compose
ATOP</CODE>" composition will let you define the color of the shadow (actually
a colored ambient light). </P>

You can even even use a different color for the shadow that eventually falls
on the final background layer (the last "<CODE>-background black</CODE>"
setting), or leave it off entirely to make it look like the images are not
above any background at all (that is floating in mid-air). </P>

It is highly versitile. </P>

<BR>

Tomas Zathurecky went on to develop another method of handling the shadows of
layered images, by dealing with a list of layered images as a whole. Something
I would not have considered posible myself. </P>


The advantage of this method is that you can deal with a whole list of images
as a whole, rather than having to accumulate one image at a time, and
repeating the same block of operations over and over. </P>

First lets again look at the simplier 'contant shadow' problem.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \
    -layers trim-bounds \
    \
    \( -clone 0--1 -dispose None -coalesce \
       -background black -shadow 70x2+4+7 \
       xc:none +insert null: +insert +insert xc:none \) \
    -layers trim-bounds -compose Atop -layers composite \
    \
    -fuzz 10% -trim \
    -reverse -background none -compose Over -layers merge +repage \
    coalesced_shadows.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="coalesced_shadows.png"
     ><IMG SRC="coalesced_shadows.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The first block of opertors is just generating the list of layered images.  It
could be a separate programmed loop, as shown previously. </P>

The the operation starts with a "<CODE>-layers trim-bounds</CODE>", a <A
HREF="../anim_mods/#trim" >Bounds Trimming</A> operation that expands the
virtual canvas of all images so as to contain all the images, and also ensure
all offsets are positive. </P>

This is then cloned, <A HREF="#coalesce" >Coalesced</A> and shadowed to create
a separate progressing list of shadows. </P>

Now we can use <A HREF="#layer_composite" >Layer Compostion</A> to merge the
shadows and the original list of images together. The complication here is
that before merging we need to not only add a special '<CODE>null:</CODE>'
marker image to divide the two lists, but also add a special blank image
'<CODE>xc:none</CODE>' so as to offset the shadow list. that way each shadow
image will be overlaid '<CODE><A HREF="../compose/#atop" >ATop</A></CODE>' the
next image of the original list. </P>

All that is left is to merge the now correctly shadowed images from bottom to
top (<A HREF="../basics/#reverse" >Reverse</A>) order. </P>

<BR>

To handle 'deep shadows' requires <A HREF="#layer_calc" >Layer
Calculations</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick \
    \( holocaust_tn.gif -frame 10x10+3+3 \
          -background none  -rotate 5 -repage +0+0 \) \
    \( spiral_stairs_tn.gif -frame 10x10+3+3 \
          -background none -rotate -15 -repage -90+60 \) \
    \( chinese_chess_tn.gif -frame 10x10+3+3 \
          -background none -rotate 20 -repage +60+90 \) \
    \
    \( -clone 0--1 \
       -set page '+%[fx:page.x-4*t]+%[fx:page.y-7*t]' -layers merge \) \
    -layers trim-bounds +delete \
    \
    \( -clone 0--1 \
       -set page '+%[fx:page.x-4*t]+%[fx:page.y-7*t]' \
            -dispose None -coalesce \
       -set page '+%[fx:page.x+4*t]+%[fx:page.y+7*t]' \
            -background black -shadow 70x2+4+7 \
       xc:none +insert null: +insert +insert xc:none \) \
    -layers trim-bounds -compose Atop -layers composite \
    \
    -fuzz 10% -trim \
    -reverse -background none -compose Over -layers merge +repage \
    coalesced_deep_shadows.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="coalesced_deep_shadows.png"
     ><IMG SRC="coalesced_deep_shadows.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can see the same set of blocks that was used previously, but with much
more complicated caculations to set the initial  <A HREF="../anim_mods/#trim"
>Bounds Trimming</A>, and later calculate the offsets needed for the
'progressive shadow list'. </P>

However the shadow currently does not become more blurry with depth. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The above will be a lot simplier using the IMv7 "magick" command, which
  would allow you to use 'fx calculations' directly the argument to
  "<CODE>-shadow</CODE>",  that would let you not only calculate a larger
  offset for the shadow with depth, but also let you mak ethe shadow more
  blurry with depth.
</I></FONT></TD></TR></TABLE></P>


<A NAME="layer_distort"></A>
<A NAME="layer_distort_perspective"></A>
<H3>Positioning Distorted Perspective Images</H3>

Aligning distorted images can be tricky, and here I will look at aligning
such images to match up at a very specific location.

Here I have two images that highlight a specific point on each image.

<!-- <CODE EXECUTE>
  magick -size 100x64 xc:SkyBlue -fill None \
          -draw 'stroke Blue  rectangle 0,0 99,63   fill Black  point 59,26
             stroke DodgerBlue
             path "M 53,26 56,26 M 62,26 65,26 M 59,20 59,23 M 59,29 59,32"' \
          align_blue.png
  magick -size 60x40 xc:LightPink -fill None \
          -draw 'stroke Tomato rectangle 0,0 59,39   fill Red point 35,14
             stroke Tomato
             path "M 31,10 33,12 M 37,16 39,18 M 31,18 33,16 M 37,12 39,10"' \
          -alpha set -channel A -evaluate set 65%  align_red.png
  magick -size 60x40 xc:LightPink -stroke Tomato -fill LightPink \
          -draw 'rectangle 0,0 59,39   fill Red point 35,14' \
</CODE> -->
<DIV ALIGN=center>
   <A HREF="align_blue.png"
      ><IMG SRC="align_blue.png"     WIDTH=100  HEIGHT=64
            ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
   <A HREF="align_red.png"
      ><IMG SRC="align_red.png"     WIDTH=60  HEIGHT=40
            ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The second image is 65% semi-transparent, which allow you to see though it
when it is composed onto the blue image, so you can see if the marked points
align.  The marked control points themselves are at the coordinates
<CODE>59,26</CODE> (blue) and <CODE>35,14</CODE> (red) respectively. </P>

If you are simply overlaying the two images, you can just subtract the offsets
and 'compose' the two image on top of each other, producing an offset of
<CODE>+24+12</CODE>.


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png align_red.png -geometry +24+12 \
          -composite align_composite.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_composite.png"
     ><IMG SRC="align_composite.png"    WIDTH=100 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that this offset could be negative! And that is something we will deal
with shortly. </P>

This only works as the coordinates are integer pixel coordinates.  If the
matching coordinates are sub-pixel locations (as is typically the case in
a photo montage), simple composition will not work.  It will also not work
well if any sort of distortion is involved (which is also common for real-life
images). And this is the problem we will explore. </P>

<BR>

When distorting the image, you will want to ensure the two pixels remain
aligned.  The best way to do that would be to use the points you want to align
as <A HREF="../distorts/#control_points" >Distort Control Points</A>.  This
will ensure they are positioned properly.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort SRT '35.5,14.5  1 75  59.5,26.5' \
          \) -flatten  align_rotate.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_rotate.png"
     ><IMG SRC="align_rotate.png"    WIDTH=100 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As distort generates a 'layer image' with a 'canvas offset' you can not simply
use <A HREF="../compose/#composite" >Composite</A> to overlay the images (too
low level), instead we need to use a <A HREF="#flatten" >Flatten</A> operator,
so that it will position them using the distort generated offset. </P>

Note how I also added a value of 0.5 to the 'pixel' coordinates.  This is
because pixels have area, while mathematical points do not, as such if you
want to align the center of a pixel, you need to add 0.5 to the location of
the center 'point' within the pixel.  See <A
HREF="../distorts/#control_coordinates" >Image Coordinates vs Pixel
Coordinates</A> for more information. </P>

The other problem with the above was that the overlaid image was 'clipped' by
the blue background canvas image, just as the <A HREF="../compose/#composite"
>Composite Operator</A> does. That is, to say the 'blue' image provided the
'clipping viewport' for the result during the composition.  To prevent this we
use <A HREF="#merge" >Layer Merge</A> instead which automatically calculates
a 'viewport' canvas that is large enough contain hold all the images being
composted together.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort SRT '35.5,14.5  1 75  59.5,26.5' \
          \) -background none -layers merge +repage  align_rotate_merge.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_rotate_merge.png"
     ><IMG SRC="align_rotate_merge.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As the result of the 'merge' the image will have a 'negative' offset (so as to
preserve layer positions of the images). To display the results I needed to
junk that offset as many browsers do not handle negative offsets in images.
I do this using "<CODE>+repage</CODE>" before saving the final image. If I was
going to do further processing (without displaying the result on the web)
I would keep that offset (remove the "<CODE>+repage</CODE>"), so the image
positions remains in their correct and known position for later processing.
</P>

<BR>

Now the same techniques as shown above would also apply if you were doing
a more complex distortion such as <A HREF="../distorts/#perspective"
>Perspective</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort Perspective '35.5,14.5  59.5,26.5
                       0,0 32,4    0,%h 14,36    %w,%h 72,53  ' \
          \) -background none -layers merge +repage  align_perspective.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_perspective.png"
     ><IMG SRC="align_perspective.png" WIDTH=100 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The problem with this technique is that you position the perspective
distortion using an internal control point.  That is, one point in the inside
of the image, and 3 points around the edge.  That can make it hard to control
the actual perspective shape, as a small movement of any control point can
make the 'free corner' move wildly. </P>

This situation can be even worse if you are using a large list of 'registered
points' to get a more exact 'least squares fit' to position images. In that
case the point you are interested in be no wehere near one of the control
'registered' points used to distort the image. </P>

The alternative is to simply distort the image the way we need to, then figure
out how we need to translate the resulting image to align the points we are
interested in.  To make this work we will need to know how the 'point of
interest' moved as a result of the distortion.  This is real problem with
distorting and positioning images, especially real life images. </P>

For example, here I distort the image using all four corners to produce
a specific (suposedally desired) distortion shape, but I will not try to align
the control points at this point, just apply the distortion...


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort Perspective '0,0  10,12  0,%h 14,40
                               %w,0 68,6  %w,%h 63,48 ' \
          \) -background none -layers merge +repage  align_persp_shape.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_persp_shape.png"
     ><IMG SRC="align_persp_shape.png" WIDTH=100 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see while the red image was distorted, the position of the red
control point is no where near the blue control point we want to align.

You can not just simply measure these two points as the red point is unlikely
to be at an exact pixel position, but will have a sub-pixel offset involved. We
will need to first calculate exactly where the red point is. </P>

To do that we can re-run the above distortion with verbose enabled to get the
perspective forward mapping coefficients.  These can then be used to calculate
as described in <A HREF="../distorts/#perspective_projection" >Perspective
Projection Distortion</A>.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=align_persp_verbose.txt>
  magick align_red.png  -define distort:viewport=1x1  -verbose \
          +distort Perspective '0,0  10,12  0,%h 14,40
                                %w,0 68,6  %w,%h 63,48 ' null:
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="align_persp_verbose.txt"
     ><IMG SRC="align_persp_verbose.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

All we want is just the calculated coefficients used by the distortion. As such
we don't need the destination image, so we just the output using
a "<CODE>null:</CODE>" image file format. We also tell the distort that the
new image it is generating is only one pixel is size using a <A
HREF="../distorts/#distort_viewport" >Distort Viewport</A>. That way it does the
distortion preparation and verbose reporting, but then only distorts a
single 'destination' pixel, which is then junked. This can save a lot of
processing time. </P>

Actually if the distortion did not use source image meta-data (needed for the
percent escapes '<CODE>%w</CODE>' and '<CODE>%h</CODE>') as part of its
calculations, we would not even need the source image
"<CODE>align_red.png</CODE>". In that case we could have used a single pixel
"<CODE>null:</CODE>" image, for the input image too.  </P>

We are also not really interested in the virtual pixels, backgrounds, or
anything else for this information gathering step, so we don't need to worry
about setting those features.  </P>

<BR>

Now we can get the distort information, we need to extract the 8 perspective
coefficients, from the 3rd and 4th line of the output.  These can then be used
to map the red control point to its new distorted position, and from there
subtract it from the blue control point, so as to get the actual amount of
translation that is needed, to align the marked red coordinate with the blue
coordinate. </P>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE SCRIPT OUT=align_persp_coord.txt>
  bluex=59; bluey=26
  redx=35; redy=14

  magick align_red.png  -verbose \
             +distort Perspective '0,0  10,12  0,%h 14,40
                               %w,0 68,6  %w,%h 63,48 ' null: 2>&1 |\
    tr -d "',"  |\
      awk 'BEGIN   { redx='"$redx"'+0.5;   redy='"$redy"+0.5';
                     bluex='"$bluex"'+0.5; bluey='"$bluey"'+0.5; }
           NR == 3 { sx=$1; ry=$2;  tx=$3; rx=$4; }
           NR == 4 { sy=$1; ty=$2;  px=$3; py=$4; }
           END { div =  redx*px + redy*py + 1.0;
                 dx = ( redx*sx + redy*ry + tx ) / div;
                 dy = ( redx*rx + redy*sy + ty ) / div;
                 printf "red point now at %f,%f\n", dx, dy;
                 printf "translate shape by %+f %+f\n", bluex-dx, bluey-dy; }'
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="align_persp_coord.txt"
     ><IMG SRC="align_persp_coord.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The above used the "<CODE>tr</CODE>" text filter to remove extra quotes and
commas from the output.  It then uses the "<CODE>awk</CODE>" program to
extract the coefficients, and do the floating point mathematics required to
'forward map' the red marker to match the blue marker. </P>

Note that I again added 0.5 to the 'pixel coordinates' of the control points
to ensure that the center of the pixel is what is used for the calculations.
See <A HREF="../distorts/#control_coordinates" >Image Coordinates vs Pixel
Coordinates</A>. </P>

Now we know the amount of translation needed by the distorted image, we have
two ways you add that translation to the distortion. Either by modifying the
coefficients of the perspective projection appropriately (not easy). Or we
could just add the translation amounts to each of the destination coordinates
of the original (very easy). </P>

Here is the result of the latter (add translations to destination
coordinates)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_blue.png \
          \( align_red.png -alpha set -virtual-pixel transparent \
             +distort Perspective '0,0   31.408223,15.334305
                                   0,%h  35.408223,43.334305
                                   %w,0  89.408223, 9.334305
                                   %w,%h 84.408223,51.334305 ' \
          \) -background none -layers merge +repage  align_persp_move.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_persp_move.png"
     ><IMG SRC="align_persp_move.png"  WIDTH=100 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

To the right I have cropped and scaled the result around the control points
to show they are perfectly aligned!

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick align_persp_shape.png -crop 19x19+50+17 +repage \
          -scale 500%   align_persp_shape_mag.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="align_persp_shape_mag.png"
     ><IMG SRC="align_persp_shape_mag.png"     WIDTH=95  HEIGHT=95
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see we have a perfect alignment of the two pixels, without any
sub-pixel overflow to any one side. Even the smallest miss-alignment would
show as an asymmetrical coloring on either side of the central pixel.  </P>

This scaling even shows a slight asymmetrical difference between left and right
sides of the red cross due to the perspective distortion.  That is, how
accurate this pixel level view test is. </P>

<BR>

A similar but simpler problem is looked at in <A
HREF="../annotating/#distort" >Text Positioning using Distort</A>. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="evaluate-sequence"></A>
<H2>Evaluate-Sequence - Direct Mutli-Image Merging Methods</H2>

The "<B><CODE><A HREF="../option_link.cgi?evaluate-sequence"
>-evaluate-sequence</A></CODE></B>" methods, are designed to merge multiple
images of the <B>same size</B> together in very specific ways. </P>

In some ways it is a blend of the <A HREF="../transform/#evaluate" >Evaluate
and Function Operators</A> combined with multi-image <A HREF="#composite"
>Composition</A> techniques we have seen above. Many of the methods provided
can even be performed using normal multi-image layering composition
techniques, but not all.</P>

The operator uses the same methods as "<CODE><A
HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>" so you can get
a list of them using "<CODE>-list Evaluate</CODE>".  Though some of these
(such as '<CODE>Mean</CODE>' and '<CODE>Medium</CODE>') are really only useful
when used with this operator. </P>

<A NAME="average"></A>
<A NAME="eval-seq_mean"></A>
<H3>Mean (Average) of multiple images</H3>

Essentially both the older "<CODE>-evaluate-sequence mean</CODE>" and the newer "<CODE><A
HREF="../option_link.cgi?evaluate-sequence" >-evaluate-sequence</A>
<B>mean</B></CODE>" will create an average of all the images provided. </P>

For example, here is an average of the rose image using all its <A
HREF="../warping/#flip" >Flipped and Flopped</A> versions.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence mean  average.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="average.png"
      ><IMG SRC="average.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Averaging hundreds of images of the same fixed scene, can be used to remove
most transient effects, such moving people, making them less important.
However areas that get lots of transient effects may have a 'ghostly blur'
left behind that may be very hard to remove. </P>

As video sequences are notoriously noisy when you look at the individual
frames, you can average a number of consecutive, but unchanging, frames
together to produce much better cleaner and sharper result. </P>

Matt Leigh, of the University of Arizona, reports that he has used this
technique to improve the resolution of microscope images. He takes multiple
images of the same 'target' then averages them all together to increase the
signal/noise ratio of the results. He suggests others may also find it useful
for this purpose.  </P>

An alternative for averaging two images together is to use a "<CODE>composite
-blend 50%</CODE>" image operation, which will work with two different sized
images. See the example of <A HREF="../compose/#blend" >Blend Two Images
Together</A> for more detail. </P>

The <A HREF="../forum_link.cgi?f=1" >IM Discussion Forum</A> had a discussion
on <A HREF="../forum_link.cgi?f=1&t=19945" >Averaging a sequence 10 frames at
a time</A>, so as to average thousands of images, without filling up the
computers memory (making it very slow). Related to this, and containing
relevent maths is the discussion <A HREF="../forum_link.cgi?f=1&t=19855"
>Don't load all images at once</A>. </P>

Another alternative to using '<CODE>mean</CODE>' is to use the newer <A
HREF="#poly" >Poly Operator</A>, which can individually weight each image.
</P>


<A NAME="eval-seq_min"></A>
<A NAME="eval-seq_max"></A>
<H3>Max/Min Value of multiple images</H3>

The '<B><CODE>Max</CODE></B>' and '<B><CODE>Min</CODE></B>' methods
will get the  maximum (lighter) values and minimum (darker) values from
a sequence of images. </P>

Again they are basically equivalent to using a <A HREF="../compose/#lighten"
>Lighten and Darken Composition Methods</A>, but with multiple images.  With
the right selection of background canvas color, you could use <A
HREF="#flatten" >Flatten Operator</A> with the equivelent compose method.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence max  max.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="max.png"
      ><IMG SRC="max.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence min  min.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="min.png"
      ><IMG SRC="min.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

WARNING: This is not a selection of pixels (by intensity), but a selection of
values. That means the output image could result in the individule red, green
and blue values from different images, resulting in a new color not found in
any of the input images. </P>

If you need the pixels selected by their max/min by intensity, see the <A
HREF="../compose/#lighten_intensity" >Lighten by Intensity Compose
Method</A>.</P>


<A NAME="eval-seq_median"></A>
<H3>Median Pixel by Intensity</H3>

The "<CODE><A HREF="../option_link.cgi?evaluate-sequence"
>-evaluate-sequence</A> <B>Median</B></CODE>" will look for the pixel which has
an intensity of the middle pixel from all the images that are given. </P>

That is, for each position it collects and sorts the pixel intensity from each
of the images. Then it will pick the pixel that falls in the middle of the
sequence. </P>

It can also be used as an alternative to simply averaging the pixels of
a collection of images. </P>

This could be used for example by combining an image with two upper and lower
'limiting' images.  As the pixel will be the middle intensity you will either
get the pixel from the original image, or a pixel from the 'limiting' images.
In other words you can use this to 'clip' the intensity of the original image.
Strange but true. </P>

For an even number of images, the pixel on the brighter side of the middle
will be selected. As such with only two images, this operator will be
equivalent to a pixel-wise "lighten by intensity". </P>

The key point is that each pixel will come completely from one image, and
sorted by intensity.  The exact color of each pixel will come completely from
one of the given images, as such no new colors are generated. </P>

For example, here is pixels of median intensity of the rose image using all
its <A HREF="../warping/#flip" >Flipped and Flopped</A> versions. Note how it
isn't as smooth, but could get sharp boundaries, as it is basied on
intensities of the pixels.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -flip rose: \( -clone 0--1 -flop \) \
          -evaluate-sequence median  median.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="median.png"
      ><IMG SRC="median.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="eval-seq_add"></A>
<H3>Add Multiple Images</H3>

The '<B><CODE>Add</CODE></B>' method is will of course simply add all the
images together.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick ... -evaluate-sequence add ...
</samp></pre></TD></TR></TABLE>
</DIV></P>

Which is a faster (more direct) version of using <A HREF="#flatten"
>Flatten</A> to <A HREF="../compose/#plus" >Plus Compose</A> all the images
together...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick ... -background black -compose plus -layers flatten ...
</samp></pre></TD></TR></TABLE>
</DIV></P>

Be warned that adding images in this way can very easilly overflow the Quantum
Range of the image, and as such it may get 'clipped', unless you use a <A
HREF="../basics/#hdri" >HDRI version of IM</A>.  This is why an <A
HREF="#eval-seq_mean" >Average, or Mean</A> is generally used instead, as this
will divide all images equally to ensure the resulting image is not clipped.
Another alturnative is to use the newer <A HREF="#poly" >Poly Operator</A>,
which can individually weight each image. </P>


<A NAME="eval-seq_subtract"></A>
<H3>Subtract Multiple Images</H3>

The '<B><CODE>Subtract</CODE></B>' method subtracts each image from the first.
Or at least that is what it should do.  Internally it has arguments swapped
and it is subtracting the previous results from the next image.  Arrggggg! </P>

However by using a quirk of the <A HREF="../compose/#linearburn" >Linear Burn
Compose Method</A> you can subtract the second and later images from the
first.  Basically by <A HREF="../color_mods/#negate" >Negating</A> all but the
first image, and setting a '<CODE>white</CODE>' (negated zero) as a
the starting background color you can then use <A HREF="../layering/#flatten"
>Flatten</A> to subtract all the images from the first.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick ...  \
         -negate \( -clone 0 -negate \) -swap 0 +delete \
         -compose LinearBurn -background white -flatten \
         ...
</samp></pre></TD></TR></TABLE>
</DIV></P>

<A NAME="eval-seq_multiply"></A>
<H3>Multiple/Divide Multiple Images</H3>

'<B>Multiply</B>' and '<B>Divide</B>' are accepted as methods by "<CODE><A
HREF="../option_link.cgi?evaluate-sequence" >-evaluate-sequence</A></CODE>"
but they generate unexpected and odd results, as they are using the actual
color value of the images rather than the normalised color value, just as
"<CODE><A HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>" does. As
a result the scale of the multiply and divide is too large. </P>

This could be classed as a bug. </P>

In the meantime, you are better using the equivelent 'flatten' method for
Multiply, which does work as expected.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick ... -background white -compose multiply -layers flatten ...
</samp></pre></TD></TR></TABLE>
</DIV></P>

<A NAME="poly"></A>
<H2>Poly - Merge Multiple Images Using a Polynomial</H2>

Closely related to "<CODE><A HREF="../option_link.cgi?evaluate-sequence"
>-evaluate-sequence</A></CODE>" and specifically to the '<A
HREF="#eval-seq_mean" >mean</A></CODE>' method (image averaging), is the
"<CODE><A HREF="../option_link.cgi?poly" >-poly</A></CODE>" operator (added IM
v6.8.0-5). </P>

This operator is given a list of two numbers for each image in memory, one to
provide a multiplicative weight for each image, but also a power-of exponent
to each image. This lets you merge a list of images as if each image was the
variable input to a polynomial equation.  The color values from each image is
treated as if they were a normalized 0 to 1 value.</P>

With each pair of values the image color (normalized) is first powered by the
second 'power-of' exponent, then it is weighted (multiplied) by the first
number. </P>

If the exponent is '<CODE>1</CODE>' then the value is just multiplied by the
given weighting.  However if the exponent is '<CODE>0</CODE>' the weight
becomes the final value, producing a normalized color constant addition (value
from 0.0 to 1.0).  </P>

A single pixel image can be provided in the current image sequence, and can be
used to add a specific color, with a different normalized color value for each
channel.  (using a weight and exponent = 1.0).   Or you can provide
a "<CODE>NULL:</CODE>' image (or any other junk image), and use an exponent of
0.0. This will will only add the given weighting factor as constant.  </P>

The final image is generated from the first image (and its size and other
meta-data), just as it is with <A HREF="../transforms/#fx" >FX DIY
Operator</A>. </P>

For example...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: granite: null: -poly '1,1 2,1 -1.0,0' poly_rose.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="poly_rose.png"
      ><IMG SRC="poly_rose.png"        WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This takes a '<CODE>rose:</CODE>' (unmodified using a weight of 1 and power-of
1),  adds to this twice the color values from the '<CODE>granite:</CODE>'
image (weight=2), and finally subtracts a value of 1 using
a '<CODE>null:</CODE>' image, using an exponent of 0 (ignore image input) and
a weighting value of -1.0. </P>

The resulting image is equivalent to...
<DIV ALIGN=center><CODE>  rose + 2.0*granite - 1.0 </CODE></DIV>
or
<DIV ALIGN=center><CODE>  rose + 2.0*(granite-0.5) </CODE></DIV>
</P>

In other words the rose image is given a noisy granite texture overlay (with
a 50% grey bias).  This is in fact exactly like a very strong '<CODE><A
HREF="../compose/#hardlight" >Hard_Light</A></CODE>' composition lighting
effect but with very explicit weighting of the granite overlay. </P>

The key difference to this over other multi-image operations is the ability to
weight each image individually, but perform all calculations in a single image
processing operation without the need for extra intermediate images. This
avoids any quantum rounding, clipping or other effects on the final results,
in a non-<A HREF="../basics/#hdri" >HDRI</A> version of ImagMagick.  (See <A
HREF="#../basics/#quantium_effects" >Quantum Effects</A>).

It can for example be used to perform a weighted average of large numbers of
images, such as averaging smaller groups of images, then averaging those groups
together. </P>

<BR>

</DIV>
<HR><!-- ---------------------------------------------------------------- -->
</div></main><footer class="magick-footer"><div class="container-fluid">
Created: 3 January 2004 <BR>
Updated: 19 April 2012 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://imagemagick.org/Usage/layers/</CODE>
</div></footer></body></HTML>
