<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Drawing -- ImageMagick Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://imagemagick.org/Usage/draw/">
</HEAD><body><main class="container"><div class="magick-template"><div class="magick-header">

<H1>ImageMagick Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Drawing</H1>

<div>

<B>Index</B><BR>
<TABLE CELLSPACING=0>
<TR valign="top"><TD COLSPAN=2>
<A HREF="../"
   ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
   > ImageMagick Examples Preface and Index</A>
</TD></TR>
<TR VALIGN=middle><TD><DL>

<DD><A HREF="#draw"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Draw Command</A>
    <UL>
    <LI><A HREF="#primitives"   >Draw Primitives</A>
    <LI><A HREF="#bezier"       >Bezier Curve Primitive</A>
    <LI><A HREF="#color"        >Color Fill Primitives</A>
    <LI><A HREF="#alpha"        >Alpha Fill Primitives</A>
    </UL>
<DD><A HREF="#specifics"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Specifics about Draw Commands</A>
    <UL>
    <LI><A HREF="#coordinates" >Pixel Coordinates</A>
    <LI><A HREF="#colorspace"  >Drawing with Gamma and Colorspace Correction</A>
    <LI><A HREF="#stroke"      >Stroke and Strokewidth</A>
    <LI><A HREF="#strokewidth" >Drawing Lines with Strokewidth and Stroke</A>
    <LI><A HREF="#bounds"      >Draw Stroke and Fill Bounds</A>
    </UL>
<DD><A HREF="#mvg"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > MVG - Magick Vector Graphics</A>
    <UL>
    <LI><A HREF="#settings"     >Command Line Settings vs MVG Settings</A>
    <LI><A HREF="#mvg_settings" >MVG Specific Settings</A>
    <LI><A HREF="#paths"        >SVG Path Drawing</A>
        <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <A HREF="#lines"       >moves and lines</A>, &nbsp;
            <A HREF="#arcs"        >elliptical arcs</A>,
        <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <A HREF="#cubic"       >cubic curves</A>, &nbsp;
            <A HREF="#quad"        >quadratic curves</A>
    <LI><A HREF="#transform"    >Transformation of the Drawing Surface</A>
    <LI><A HREF="#affine"       >Affine Transformation</A>
    <LI><A HREF="#push_context" >Push/Pop Drawing Context</A>
    <LI><A HREF="#push_objects" >Push/Pop Special Objects</A>
    <LI><A HREF="#reading"      >Reading MVG files</A>
    </UL>

</DL></TD>
<TD><DL>

<DD><A HREF="#symbols"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Drawing Symbols</A>
    <UL>
    <LI><A HREF="#symbol_drawing" >Symbols Drawing Techniques</A>
    <LI><A HREF="#symbol_alts"    >Alternatives to Drawing Symbols</A>
    <LI><A HREF="#circles"        >Drawing Circles</A>
    <LI><A HREF="#arrows"         >Drawing Arrow Heads</A>
    </UL>
<DT>&nbsp;
<DD><A HREF="#objects"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Drawing Objects</A>
    <UL>
    <LI><A HREF="#wide_strokes"   >Wide Strokes of Color</A>
    <LI><A HREF="#cylinders"      >Cylinders</A>
    </UL>
<DT>&nbsp;
<DD><A HREF="#text"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Drawing Text Strings</A>
    <UL>
    <LI><A HREF="#quote"          >To Quote or Backslash?</A>
    <LI><A HREF="#percent"        >About Percent Characters</A>
    <LI><A HREF="#annotate"       >Use Annotate Instead</A>
    </UL>
<DT>&nbsp;
<DD><A HREF="#svg"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > IM and SVG Handling</A>
    <UL>
    <LI><A HREF="#svg_drivers"    >SVG Input Drivers: RSVG vs MSVG</A>
    <LI><A HREF="#svg_settings"   >SVG settings</A>
    <LI><A HREF="#svg_output"     >SVG Output Handling</A>
    </UL>
<DT>&nbsp;
<DD><A HREF="#other"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Non-IM Vector Graphic Programs</A>

</DL>
</TD></TR></TABLE></P>

Drawing in IM is the way to add new elements to an existing image.  While
a lot of text drawing is covered in the examples page for <A HREF="../fonts/"
>Compound Font Effects</A>, and in <A HREF="../annotating/" >Image
Annotating</A>, this page deals with the other more general aspects of the
"<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" operator. </P>

The draw command started as a means to create simple images. But has expanded
over time to be the interface for vector graphic to raster image conversion.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="intro">
<H2>ImageMagick Draw Commands</H2>
</A>

Images in computers are generally saved in two different ways.  The first and
most common way you have seen throughout these example pages is known as
Raster Graphics.  In this approach, images are stored in terms of a rectangular
array of pixels. </P>

The other way is less common, and less modifiable, but in another sense more
versatile,  Object Vector Graphics.  In this form the image is described in
terms of lines, arcs, color fills, and sometimes depth.  This is useful
because you can scale these images to just about any size you want and they
still display perfectly.  You can also describe very large and complex images
in a very small amount of space when compared to the raster format
equivalent. </P>

Examples of vector graphic images include postscript, and the new <A
HREF="http://www.w3.org/TR/SVG/" >SVG -- Scalable Vector Graphics</A>. </P>

True-Type Fonts are also examples of vector graphics, as this  allows the
individual character descriptions to be used at any scale. </P>

The "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" image
operator, is a window into the ImageMagick vector drawing functions, and forms
a set of commands quite separate from the normal command line image operators
of IM. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  There are only a few vector graphic file formats in general use as every
  such format is usually very different from other such formats.  The result
  is that there is very little in the way of code sharing possible. </P>

  For this reason, ImageMagick is more concerned with the use of vector
  graphics to draw SVG format images.  Postscript and true-type font graphics
  are passed to other external '<A HREF="../files/#delegate" >delegate</A>'
  libraries and applications that are much more suited to drawing those kinds
  of vector graphic formats. </P>

  That is not to say that delegates are not available for SVG. One example is
  a RSVG library or GTK SVG library which is available at compile time. IM
  will link to those libraries to magick SVG rather than attempting to do it
  itself.

</I></FONT></TD></TR></TABLE></P>


<A NAME="primitives"></A>
<H3>Primitive Draw Commands</H3>

Lets start with the oldest, simplest, and most common drawing primitives of
the "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" image operator
of MVG commands. </P>

Note that all arguments are treated as floating point, and do not have to be
integers, such as I typically use in these examples.  </P>

<A NAME="primitive_point"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Single Pixel Draw  (two ways -- these have been enlarged)

  # Point 'paints' the color pixel
  magick -size 10x6 xc:skyblue  -fill black \
          -draw 'point 3,2'         -scale 100x60   draw_point.gif

  # Color Point 'replaces' the color pixel
  magick -size 10x6 xc:skyblue  -fill black \
          -draw 'color 6,3 point'   -scale 100x60   draw_color_point.gif
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="draw_point.gif"
     ><IMG SRC="draw_point.gif"                WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_color_point.gif"
     ><IMG SRC="draw_color_point.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These two point methods produce different results when semi-transparent colors
are involved, according to the comment given.  See <A HREF="#color" >Color
Fill Primitives</A> below for details. </P>

<A NAME="primitive_rectangle"></A>
<A NAME="primitive_roundedrectangle"></A>
<A NAME="primitive_arc"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Rectangle  /  Rounded Rectangle  /  Rectangular Arc

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "rectangle 20,10 80,50"       draw_rect.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "roundrectangle 20,10 80,50 20,15"  draw_rrect.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "arc  20,10 80,50  0,360"     draw_arc.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "arc  20,10 80,50 45,270"     draw_arc_partial.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_rect.gif"
     ><IMG SRC="draw_rect.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5  HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_rrect.gif"
     ><IMG SRC="draw_rrect.gif"             WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_arc.gif"
     ><IMG SRC="draw_arc.gif"               WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5  HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_arc_partial.gif"
     ><IMG SRC="draw_arc_partial.gif"       WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5  HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

The '<CODE>arc</CODE>' draw primitive is listed with rectangles as it is
really just a 'ellipse' that is fitted inside the '<CODE>rectangle</CODE>'
defined by the two coordinates.  Partial arcs are rarely used as it can be hard
to determine the end points unless the angles are limited to multiplies of
ninety degrees. </P>

<BR>
<A NAME="primitive_circle"></A>
<A NAME="primitive_ellipse"></A>

The '<CODE>circle</CODE>' and '<CODE>ellipse</CODE>' primitives, involve
'center' coordinate with either a 'edge' coordinate, or 'size' and 'angle
values respectively.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Circle  /  Ellipse    (centered on a point)

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "circle 50,30 40,10"          draw_circle.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "ellipse 50,30 40,20 0,360"   draw_ellipse.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "ellipse 50,30 40,20 45,270"   draw_ellipse_partial.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_circle.gif"
     ><IMG SRC="draw_circle.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_ellipse.gif"
     ><IMG SRC="draw_ellipse.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_ellipse_partial.gif"
     ><IMG SRC="draw_ellipse_partial.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You may also like to look at <A HREF="#push_context" >Push/Pop Context</A> for
an example on how you can create a rotated ellipse. </P>

<A NAME="primitive_line"></A>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Line / Polyline / Polygon / Bezier

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "line   20,50 90,10"                 draw_line.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "polyline 40,10 20,50 90,10 70,40"   draw_polyline.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "polygon  40,10 20,50 90,10 70,40"   draw_polygon.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "bezier   40,10 20,50 90,10 70,40"   draw_bezier.gif

</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_line.gif"
     ><IMG SRC="draw_line.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_polyline.gif"
     ><IMG SRC="draw_polyline.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_polygon.gif"
     ><IMG SRC="draw_polygon.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_bezier.gif"
     ><IMG SRC="draw_bezier.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A better method of drawing lines and curves is to use the <A HREF="#paths"
>SVG Path Drawing</A>, which can be much more versatile and even allows for
'relative line drawing'. </P>

<A NAME="primitive_text"></A>
<A NAME="primitive_image"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # text drawing  / image

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -font Candice -pointsize 40 -gravity center \
          -draw "text 0,0 'Hello'"   draw_text.gif

  magick -size 100x60 xc:skyblue -gravity center \
          -draw "image over 0,0 0,0 'terminal.gif'"   draw_image.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_text.gif"
     ><IMG SRC="draw_text.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="draw_image.gif"
     ><IMG SRC="draw_image.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These last two fill type operations are currently the only draw operations
that are affected by "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>". </P>

Other modifiers for these operations, include:
"<CODE><A HREF="../option_link.cgi?fill"        >-fill</A></CODE>",
"<CODE><A HREF="../option_link.cgi?tile"        >-tile</A></CODE>",
"<CODE><A HREF="../option_link.cgi?origin"      >-origin</A></CODE>",
"<CODE><A HREF="../option_link.cgi?stroke"      >-stroke</A></CODE>",
"<CODE><A HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>",
"<CODE><A HREF="../option_link.cgi?font"        >-font</A></CODE>",
"<CODE><A HREF="../option_link.cgi?pointsize"   >-pointsize</A></CODE>",
"<CODE><A HREF="../option_link.cgi?box"         >-box</A></CODE>",
</P>

Their are other modifiers but these are related to the more advanced <A
HREF="#mvg" >Magick Vector Graphics language</A>. </P>


<A NAME="bezier"></A>
<H3>Bezier Primitive</H3>

The '<CODE>bezier</CODE>' primitive is used to draw curves.  Each command will
draw just one curve segment. Typically 4 points (8 numbers) is given: a start
point 'knot', two control points and an end point 'knot'.  The two control
points define the direction and how fast the curve deviates from the attached
end 'knot' points. </P>

To join two curves smoothly, the control point from the end should be mirrored
through the 'knot' to form the control point in the next Bezier curve. </P>

For example here I draw two bezier curves that join smoothly together.  Note
how the control lines and points (also drawn) mirror straight though the join
coordinate, both in angle and in length.  This is important or the curve will
not be smooth.


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=draw_bezier_joined.gif>
  points="10,10 30,90   25,10 50,50   50,50 75,90   70,10 90,40"
  clines=`echo "$points" | sed 's/   /\n/g' |\
             while read line; do echo "line $line"; done`
  symbols=`echo path "'"; for point in $points; do
             echo "M $point   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2"
           done;  echo "'"`
  magick -size 100x100 xc:skyblue -fill none \
          -draw "stroke gray $clines    stroke blue $symbols " \
          -draw "stroke red  bezier 10,10 30,90   25,10 50,50 " \
          -draw "stroke red  bezier 50,50 75,90   70,10 90,40 " \
          draw_bezier_joined.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_bezier_joined.gif"
     ><IMG SRC="draw_bezier_joined.gif"              WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If I move one of the control points, so that it is NOT 'reflected' though the
attached 'knot' from the other control point of the same 'knot', then the
curve will be dis-continuous.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=draw_bezier_disjoint.gif>
  points="10,10 30,90   25,10 50,50   50,50 80,50   70,10 90,40"
  clines=`echo "$points" | sed 's/   /\n/g' |\
             while read line; do echo "line $line"; done`
  symbols=`echo path "'"; for point in $points; do
             echo "M $point   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2"
           done;  echo "'"`
  magick -size 100x100 xc:skyblue -fill none \
          -draw "stroke gray $clines    stroke blue $symbols " \
          -draw "stroke red  bezier 10,10 30,90   25,10 50,50 " \
          -draw "stroke red  bezier 50,50 80,50   70,10 90,40 " \
          draw_bezier_disjoint.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_bezier_disjoint.gif"
     ><IMG SRC="draw_bezier_disjoint.gif"              WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If the control point is moved again so that it matches the related 'knot'
point the line will come directly from that point without any 'curve' at all.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=draw_bezier_no_curve.gif>
  points="10,10 30,90   25,10 50,50   50,50 50,50   70,10 90,40"
  clines=`echo "$points" | sed 's/   /\n/g' |\
             while read line; do echo "line $line"; done`
  symbols=`echo path "'"; for point in $points; do
             echo "M $point   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2"
           done;  echo "'"`
  magick -size 100x100 xc:skyblue -fill none \
          -draw "stroke gray $clines    stroke blue $symbols " \
          -draw "stroke red  bezier 10,10 30,90   25,10 50,50 " \
          -draw "stroke red  bezier 50,50 50,50   70,10 90,40 " \
          draw_bezier_no_curve.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_bezier_no_curve.gif"
     ><IMG SRC="draw_bezier_no_curve.gif"              WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If both control points are set to the their respective 'knots', then a
straight line will be generated.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=draw_bezier_lines.gif>
  points="10,10 10,10   50,50 50,50   50,50 50,50   90,40 90,40"
  clines=`echo "$points" | sed 's/   /\n/g' |\
             while read line; do echo "line $line"; done`
  symbols=`echo path "'"; for point in $points; do
             echo "M $point   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2"
           done;  echo "'"`
  magick -size 100x100 xc:skyblue -fill none \
          -draw "stroke gray $clines    stroke blue $symbols " \
          -draw "stroke red  bezier 10,10 10,10   50,50 50,50 " \
          -draw "stroke red  bezier 50,50 50,50   90,40 90,40 " \
          draw_bezier_lines.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_bezier_lines.gif"
     ><IMG SRC="draw_bezier_lines.gif"              WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The '<CODE>bezier</CODE>' primitive is not really useful without specifying all
4 points. Only the first and last point are classed as 'knots' through which
the curve will pass (or end).  All the other intervening points are regarded
purely as control points, effecting the curve in the sequence given, the
further away the control point is the larger its effect on that segment of the
curve.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=draw_bezier_multi.gif>
  points="10,10 30,90   25,10    75,90   70,10 90,40"
  symbols=`for point in $points; do
             echo "M $point   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2"
           done`
  magick -size 100x100  xc:skyblue  -fill none \
          -draw "stroke gray  polyline $points " \
          -draw "stroke red   bezier $points " \
          -draw "stroke blue  path '$symbols' " \
          draw_bezier_multi.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_bezier_multi.gif"
     ><IMG SRC="draw_bezier_multi.gif"              WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

It is not recommended that you use more or less than 4 points per
'<CODE>bezier</CODE>' curve segment, to keep things simple. </P>

Actually I recommend you don't use the '<CODE>bezier</CODE>' primitive at all,
but use the <A HREF="#cubic" >SVG Path Cubic Bezier</A> instead for generating
curves.  This has a special '<CODE>S</CODE>" curve continuation function that
automatically does the appropriate control point 'reflection' to generate
smoothly joining curve segments and reduces the number of control points you
need to use. You can also define points relative to the last end point
in the path. </P>


<A NAME="color"></A>
<H3>Color Fill Primitives</H3>

On top of the above 'simple' primitives, "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" also provides a set of color
fill or modification primitives.  These modify the color(s) in the image
starting at the point specified, according to the method chosen.  </P>

These fill methods are actually not true 'draw' commands, but color
replacement function.  They were added to draw as it was the easiest place to
insert their operations into ImageMagick in a very early version of the
program. </P>

Just as in the above, the color used is set with the "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" color setting, but if set,
the "<CODE><A HREF="../option_link.cgi?tile" >-tile</A></CODE>" image will be
used instead. </P>

The other setting options above are not used, and have no effect on these
operations. </P>

Two extra settings as you will also apply to these primitives, "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?fuzz" >-fuzz</A></CODE>" factor settings.  However
these settings can NOT be defined within the 'MVG' language, so can only be
set before using the "<CODE><A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" operator. </P>

The first of these '<CODE>color point</CODE>' you have already seen as an
alternative to the '<CODE>point</CODE>' draw primitive in the above examples.
If you look carefully you will see the single white pixel we set in our test
image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD COLSPAN=2 ALIGN=justify>
</TD></TR><TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill white \
          -draw 'color 30,20 point'      color_point.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="color_point.png"
     ><IMG SRC="color_point.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However when drawing transparent and semi-transparent colors, these functions
are not the same. </P>

Here we have a three pixel red image (enlarged), the second or middle pixel we
used the '<CODE>point</CODE>' function to <B>paint</B> over the red pixel with
a semi-transparent blue color, giving a purple result.  If however use use
the '<CODE>color point</CODE>' function (last or right pixel), the red color
is completely <B>replaced</B> by the semi-transparent blue pixel.  It is not
overlaid.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 3x1 xc:red -alpha on -fill '#00F8' \
          -draw 'point 1,0' \
          -draw 'color 2,0 point'   -scale 33x33  draw_points.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="draw_points.png"
     ><IMG SRC="draw_points.png"              WIDTH=99 HEIGHT=33
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

All the '<CODE>color</CODE>' functions do full color replacement, while all
other color primitive 'paint' the color on top of the image. As such you can
use '<CODE>color</CODE>' to draw the transparent color. </P>

The '<CODE>color replace</CODE>' draw function will replace all instances
of the exact given color at the location specified.  And as you can see the
areas do not have to be connected.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill white \
          -draw 'color 30,20 replace'      color_replace.png


  magick color_test.png   -fill white   -fuzz 13%\
          -draw 'color 30,20 replace'      color_replace_fuzz.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="color_replace.png"
     ><IMG SRC="color_replace.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/space.gif" WIDTH=1 HEIGHT=3 BORDER=0><BR>
  <A HREF="color_replace_fuzz.png"
     ><IMG SRC="color_replace_fuzz.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However as you can see in the first result, some pixels along the edges did
not get replaced.  These pixels are not <I>exactly</I> the same color as the
pixel selected, so they were ignored.  Adding a small <A
HREF="../color_basics/#fuzz" >fuzz factor</A> will also include colors that
are similar to the original color. As shown the second example above. </P>

Of course a 'fuzz factor' is not a great solution, as it will not capture all
such edge pixels. This is a recurring problem with all these 'color fill'
methods, and one that has no general solution. </P>

If you want to replace a specific known color, rather than select a color from
the image itself, then the "<CODE><A HREF="../option_link.cgi?opaque"
>-opaque</A></CODE>" image operator can be used instead. This function also
uses a "<CODE><A HREF="../option_link.cgi?fuzz" >-fuzz</A></CODE>" factor
setting to increase the range of colors that match the given color. </P>

The '<CODE>floodfill</CODE>' method is also quite simple as it will just fill
the the whole area around the point selected and not select any other area of
similar colors which are not connected in some way. </P>

You can also expand the area being filled by using "<CODE><A
HREF="../option_link.cgi?fuzz" >-fuzz</A></CODE>" to include similar colors.
In this case we chose a value high enough to also include the cross border,
allowing the flood fill to 'leak' to the other side of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill white \
          -draw 'color 30,20 floodfill'      color_floodfill.png


  magick color_test.png   -fill white   -fuzz 15%   \
          -draw 'color 30,20 floodfill'      color_floodfill_fuzz.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="color_floodfill.png"
     ><IMG SRC="color_floodfill.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/space.gif" WIDTH=1 HEIGHT=3 BORDER=0><BR>
  <A HREF="color_floodfill_fuzz.png"
     ><IMG SRC="color_floodfill_fuzz.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Flood-filling areas with a color is not without its problems.  The color can
leak across a thin boundary, into areas where it was not wanted, (see <A
HREF="../formats/#bg_pattern" >GIFs on a background pattern</A> as a
demonstration of this). Or it may not fill the area selected right to the
edge, (see <A HREF="../antialiasing/#floodfill" >Anti-Aliasing and Flood Fill
Problems</A>). But it does work. </P>

The '<CODE>filltoborder</CODE>' is like '<CODE>floodfill</CODE>' except you
specify a color which borders the area to be filled, rather that the color to
be replaced by the fill process. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Of course a <A HREF="../color_basics/#fuzz" >fuzz factor</A> is also
recommended to include 'similar colors' in that border color selection, to
further limit the floodfill.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill white  -bordercolor royalblue \
          -draw 'color 30,20 filltoborder'   color_filltoborder.png


  magick color_test.png   -fill white  -bordercolor blue \
          -draw 'color 30,20 filltoborder'   color_filltoborder2.png


  magick color_test.png   -fill white  -bordercolor blue  -fuzz 30% \
          -draw 'color 30,20 filltoborder'   color_filltoborder_fuzz.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="color_filltoborder.png"
     ><IMG SRC="color_filltoborder.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="color_filltoborder2.png"
     ><IMG SRC="color_filltoborder2.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=3 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="color_filltoborder_fuzz.png"
     ><IMG SRC="color_filltoborder_fuzz.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The final draw color method is '<CODE>reset</CODE>' which just replaces, or
resets the whole image to the fill color.  In this case the actual pixel
selected has no bearing on the results at all.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
</TD></TR><TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill white \
          -draw 'color 30,20 reset'      color_reset.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="color_reset.png"
     ><IMG SRC="color_reset.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is actually very useful in that it gives one simple way of generating a
plain solid color (or tiled image) canvas from an existing image.  (See <A
HREF="../canvas/#sized" >Canvases Sized to an Existing Image</A>) for this and
other ways of doing the same thing. </P>


FUTURE: Using a "<CODE><A HREF="../option_link.cgi?tile"
>-tile</A></CODE>" pattern to fill the area. </P>


<A NAME="alpha"></A>
<H3>Alpha Fill Primitives</H3>

The '<CODE>alpha</CODE>' draw primitive works in exactly the same way as the
'<CODE>color</CODE>' primitive described above, except it will not replace the
color of the areas selected, only the 'alpha' channel of the areas selected.
(That is only the 'alpha' hannel is adjusted by these fill functions). </P>

Just as like the '<CODE>color</CODE>' fill function, the 'alpha' value uses
the fill color (unless "<CODE><A HREF="../option_link.cgi?tile"
>-tile</A></CODE>" as the source of the 'alpha value' to use). </P>

Here we use the same '<CODE>color floodfill</CODE>' example above, but here
only adjust the alpha channel to make the filled parts fully-transparent.
That is the original color is still present, just transparent!

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR valign="top"><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill none \
          -draw 'alpha 30,20 floodfill'      matte_floodfill.png


  magick color_test.png   -fill none   -fuzz 15%   \
          -draw 'alpha 30,20 floodfill'      matte_floodfill_fuzz.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="matte_floodfill.png"
     ><IMG SRC="matte_floodfill.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/space.gif" WIDTH=1 HEIGHT=3 BORDER=0><BR>
   <A HREF="matte_floodfill_fuzz.png"
     ><IMG SRC="matte_floodfill_fuzz.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TD></TR></TABLE></P>

The '<CODE>alpha reset</CODE>' function can also be used to make a whole image
semi-transparent. Of course in this case we must output to PNG which can
accept semi-transparent colors in images. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick color_test.png   -fill '#00000080' \
          -draw 'alpha 30,20 reset'      matte_reset.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="matte_reset.png"
     ><IMG SRC="matte_reset.png"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice that the '<CODE>black</CODE>' color component was not used in
operations, only the alpha component of the color. The images original color
is left as is. </P>

FUTURE: Using "<CODE><A HREF="../option_link.cgi?tile"
>-tile</A></CODE>" pattern for in interesting alpha effect. </P>


Both '<CODE>color</CODE>' and '<CODE>alpha</CODE>' are full replacement of
color functions, which will always produce a Boolean (all or nothing) type of
color replacement. As such the edges of such areas will always show <A
HREF="../antialiasing/" >Aliasing effects</A>.  </P>

Because of this, these are generally not good image operators for general
image development, except for setting the transparent areas of GIF images
(which are also Boolean).  All is not lost however, as can be seen in the
examples for <A HREF="../masking/#bg_remove" >Background Removal</A>.  </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="specifics"></A>
<H2>Specifics about Draw Commands</H2>

<A NAME="coordinates"></A>
<H3>Pixel Coordinates</H3>

The "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" command (and
many others in IM) use what is calls "Pixel Coordinates".  That is
a coordinate of '<CODE>10,10</CODE> is the center of the pixel 10 pixels down
and to the left from the top-left corner. </P>

In this coordinate system 0,0 is the center of the top-left pixel, and w-1,h-1
is the center of the bottom-right corner. The actual edges are located at
-0.5,-0.5 and w-0.5,h-0.5  and the center pixel (if the image is an odd size)
is located at  '<CODE>(w-1)/2,(h-1)/2</CODE>'. </P>

However when you are processing an image mathematically (such as when using
distort) actual pixels have no real meaning, as such it uses "Image
Coordinates".  In this system the actual edge of the image is at
'<CODE>0,0</CODE>' and '<CODE>w,h</CODE>'.  And the center of the image (which
may or may not be the center of a pixel) is at '<CODE>w/2,h/2</CODE>'. </P>

To magick 'pixel coordinates' to image coordinates, add &frac12;  As such the
center of the top-left pixel is '<CODE>0.5,0.5</CODE>' and the bottom-right
pixel is '<CODE>w-0.5,h-0.5</CODE>'. </P>

<I>Example: center of a circle in small image</I> </P>

<A NAME="gamma"></A>
<A NAME="colorspace"></A>
<H3>Drawing with Gamma and Colorspace Correction</H3>

As with almost all ImageMagick operations, "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" is a linear operator.  and
as such works in a linear RGB colorspace. This means to get nice smooth edges
you may need to do some gamma correction of images, before you save them so
they are stored using non-linear (gamma corrected) sRGB colorspace. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example if you draw a large circle, and just save it...

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 81x81 xc:black -fill white -draw 'circle 40,40 40,3' \
          circle_raw.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="circle_raw.png"
     ><IMG SRC="circle_raw.png"          WIDTH=81 HEIGHT=81
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Look at the edges of the circle, they don't actually look really very
smooth.  You can see significant staircase effects. </P>

That is because you drew the circle in linear RGB colorspace.  But you then
saved the image as if it was really sRGB colorspace! </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

To fix this we need to add a gamma correction to the image before saving it.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 81x81 xc:black -fill white -draw 'circle 40,40 40,3' \
          -gamma 2.2 circle_gamma.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="circle_gamma.png"
     ><IMG SRC="circle_gamma.png"          WIDTH=81 HEIGHT=81
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now the circle edges actually looks smooth and rounded just like they should
be. </P>

If you want to do this properly, we really should be making the correction
using colorspace.  However as IM assumes RGB is the default colorspace for
saving you need do some tricky handling to get it to do things correctly.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 81x81 xc:black -set colorspace RGB \
          -fill white -draw 'circle 40,40 40,3' \
          -colorspace sRGB circle_sRGB.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="circle_sRGB.png"
     ><IMG SRC="circle_sRGB.png"          WIDTH=81 HEIGHT=81
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Note that sRGB colorspace (which is the correct way to save images) is not
  exactly the same as simply appling a 2.2 gamma correction.  However the
  differences in results between the two are minor, and only visible in very
  very dary images.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.7.5-1 the colorspace names 'sRGB' and 'RGB' (linear-RGB),
  was actually reversed.  As such on older versions of IM the two labels
  in the above should be swapped.
</I></FONT></TD></TR></TABLE></P>

To correctly draw (or do any 'linear' image processing) using a real image (in
IMv6) you need to first remove any existing gamma, process the image, then
restore that gamma correction. See <A HREF="../resize/#resize_colorspace"
>Resizing using Colorspace Correction</A> for more details. </P>

Here is an example of drawing on a real image...  First without any color
correction (raw), and then with gamma, and colorspace corrections.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -fill none -stroke white -draw 'line 5,40 65,5'  rose_raw.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="rose_raw.png"
     ><IMG SRC="rose_raw.png"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -gamma .454545 \
          -fill none -stroke white -draw 'line 5,40 65,5' \
          -gamma 2.2 rose_gamma.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="rose_gamma.png"
     ><IMG SRC="rose_gamma.png"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick rose: -colorspace RGB \
          -fill none -stroke white -draw 'line 5,40 65,5' \
          -colorspace sRGB rose_sRGB.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="rose_sRGB.png"
     ><IMG SRC="rose_sRGB.png"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see by using gamma or colorspace correction, the line become very
smooth looking without a jaggy 'staircase' aliasing effect, than can be seen
when drawing directly. (You need a very good monitor to see it) </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The line in the above was drawn using a "<CODE><A
  HREF="../option_link.cgi?stroke" >-stroke</A></CODE>" color.  You can draw
  the line using "<CODE><A HREF="../option_link.cgi?fill" >-fill</A></CODE>"
  and get the same results, but then you will not have line thickness control
  using "<CODE><A HREF="../option_link.cgi?strokewidth"
  >-strokewidth</A></CODE>".   See <A HREF="#stroke" >Stroke Color Setting</A>
  below for more information.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Colornames are actually defined using values for 'sRGB' colorspace BUT are
  being applied by draw as if the image is in linear-RGB colorspace.  As such
  using the above gamma correction with named colors (other than 'white' or
  'black') will result in those colors becoming distorted.  In such cases it
  may be better to not use gamma or colorspace correction, so that named
  colors will map correctly. </P>

  Correct mapping of named 'sRGB' colors, to the colorspace of the image
  being draw to, will be fixed as part of IMv7 Development. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="stroke"></A>
<H3>Stroke, StrokeWidth and Fill Interaction</H3>

The "<CODE><A HREF="../option_link.cgi?stroke" >-stroke</A></CODE>" and
"<CODE><A HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>"
options are used when drawing an outline around a font's
edge. </P>

These options commonly used with "<CODE><A HREF="../option_link.cgi?fill"
>-fill</A></CODE>" to make text more interesting, for very little effort.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    magick -size 380x70 xc:lightblue -pointsize 50 -font Chisel \
            -fill green  -stroke black  -draw 'text 10,55 "Black Border"' \
            stroke_font.jpg
</samp></pre></TD></TR></TABLE>
   <A HREF="stroke_font.jpg"
      ><IMG SRC="stroke_font.jpg"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The default settings is "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A> 1</CODE>"  and "<CODE><A HREF="../option_link.cgi?stroke"
>-stroke</A> None</CODE>". </P>

But this makes the outline stroke invisible, leaving just the "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" color, you will not see it.
</P>

The only effect "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A></CODE>" has when the "<CODE><A
HREF="../option_link.cgi?stroke" >-stroke</A></CODE>" is 'invisible', is on
font size attributes, which means it can still effect font positioning and the
size of a <A HREF="../text/#label" >Label and Caption</A> image generation.
Otherwise the width has not visible effect until you make the stroke visible.
</P>


To see how the "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A></CODE>" actually effects the look of a font (when made
visible) here I have drawn some text with various widths from 'turned off'
and getting larger.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    magick -size 320x420 xc:lightblue -pointsize 70 -font Vademecum \
      -fill red -stroke none                 -draw 'text 30,80  "Stroke -"' \
      -fill red -stroke black -strokewidth 0 -draw 'text 30,160 "Stroke 0"' \
      -fill red -stroke black -strokewidth 1 -draw 'text 30,240 "Stroke 1"' \
      -fill red -stroke black -strokewidth 2 -draw 'text 30,320 "Stroke 2"' \
      -fill red -stroke black -strokewidth 3 -draw 'text 30,400 "Stroke 3"' \
      stroke_table.jpg
</samp></pre></TD></TR></TABLE>
   <A HREF="stroke_table.jpg"
      ><IMG SRC="stroke_table.jpg"             WIDTH=320  HEIGHT=420
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note from the the above examples that setting a "<CODE><A
HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>" of
'<CODE>0</CODE>' is NOT the same as setting the "<CODE><A
HREF="../option_link.cgi?stroke" >-stroke</A></CODE>" color to
'<CODE>none</CODE>' (the default).  The former makes a very very thin stroke
outline, while the latter effectively turns it off.  In both cases the stroke
is still drawn. </P>

However you should also note that even with a "<CODE><A
HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>" of
'<CODE>0</CODE>' the image outline will be expanded very very slightly over
that of just a plain 'filled' image (using a "<CODE><A
HREF="../option_link.cgi?stroke" >-stroke</A></CODE>" color of
'<CODE>none</CODE>'. </P>

Essentually using any width smaller than '<CODE>1.0</CODE>' does not work
properly. And you should exercise caution in cases where this can matter. </P>

Remember however that "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A></CODE>" is also a floating point setting. That is a stroke
width of '<CODE>0.5</CODE>' is also valid.   However usally this is only
important when you are attempting to draw <A
HREF="../antialiasing/#thin_circles" >Drawing Thin Bitmapped Circles</A> with
the <A HREF="../antialiasing/#intro" >Anti-Alising</A> turned off. </P>

<BR>

Here is an example of using an extremely large stroke width.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick -size 320x100 xc:lightblue -font Candice -pointsize 72 -fill white \
           -stroke black -strokewidth 15 -draw "text 25,65 'Anthony'" \
           stroke_thick.jpg
</samp></pre></TD></TR></TABLE>
   <A HREF="stroke_thick.jpg"
      ><IMG SRC="stroke_thick.jpg"            WIDTH=320 HEIGHT=100
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A></CODE>" expands both lines inward and outward.  Here is the
same example but with the font re-drawn, without the stroke outline, to remove
the inside part of the very thick stroke.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick -size 320x100 xc:lightblue -font Candice -pointsize 72 -fill white \
           -stroke black -strokewidth 15 -draw "text 25,65 'Anthony'" \
           -stroke none                  -draw "text 25,65 'Anthony'" \
           stroke_outline.jpg
</samp></pre></TD></TR></TABLE>
   <A HREF="stroke_outline.jpg"
      ><IMG SRC="stroke_outline.jpg"            WIDTH=320 HEIGHT=100
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

For more examples of using stroke see <A HREF="../fonts/" >Compound Font
Effects</A>.  Have a special look at the "<A HREF="../fonts/#balloon" >Balloon
Effect</A>". </P>


<A NAME="strokewidth"></A>
<H3>Drawing (Stroke) Lines</H3>

The default line drawing in IM has few weird behaviours, which are worth
knowing about. </P>

Here is the default line draw...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -draw "line 5,35 95,5" \
          line_default.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_default.jpg"
     ><IMG SRC="line_default.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can set the color of the line with a "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" option.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -fill white -draw "line 5,35 95,5" \
          line.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line.jpg"
     ><IMG SRC="line.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Also you can make a line slightly thicker by setting the "<CODE><A
HREF="../option_link.cgi?stroke" >-stroke</A></CODE>" color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -fill white -stroke black -draw "line 5,35 95,5" \
          line_stroke.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke.jpg"
     ><IMG SRC="line_stroke.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


But what happened to the white color we specified with the "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" option? </P>

This is the tricky aspect of drawing lines in ImageMagick.  What the program
does is actually consider the line as a filled object about 1 pixel wide.
This is natural, as typically multiple lines are generally used to sweep out
an area that is to be filled.  </P>

So just as when we used stroke with fonts in the previous section, IM draws
the line (or object) using the fill color, then draws around it with the
stroke color.  The result is that the above stroke color line is now slightly
thicker, with the fill color completely hidden underneath.  If you make the
stroke color semi-transparent you can make that fill color visible again. </P>

To summarize, lines will appear to be drawn with the "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" color, but that option is of
no consequence once the "<CODE><A HREF="../option_link.cgi?stroke"
>-stroke</A></CODE>" color has been defined as something other than the
default "<CODE>none</CODE>" or "<CODE>transparent</CODE>" colors. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The option  "<CODE>-linewidth</CODE>" is really only an alias for
  "<CODE><A HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>",
  and should not be used.
</I></FONT></TD></TR></TABLE></P>

For example, you would probably think that this command would produce a very
thick line.  It does, but as the "<CODE><A HREF="../option_link.cgi?stroke"
>-stroke</A></CODE>" color is invisible you can't see it.  You only see the
inside 'fill' of the one pixel wide area of the line.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -fill white -strokewidth 3 -draw "line 5,35 95,5" \
          line_fill_3.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_fill_3.jpg"
     ><IMG SRC="line_fill_3.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The above result I actually regard as a bug.  Nothing should have been
  drawn, as there is no 'area' to be filled, and no line 'stroke color' has
  been set.  The reason IM currently does this is to avoid confusion with
  new users, but really it just causes problems with advanced users.
  See <A HREF="#bounds" >Draw Fill Bounds</A> for more details.
</I></FONT></TD></TR></TABLE></P>

But if the stroke color is also defined, you will get the thick line
requested...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -stroke black -strokewidth 3 -draw "line 5,35 95,5" \
          line_stroke_3.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_3.jpg"
     ><IMG SRC="line_stroke_3.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If the "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A></CODE>" setting is set to one, the above line will be
completely covered.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -stroke black -strokewidth 1 -draw "line 5,35 95,5" \
          line_stroke_1.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_1.jpg"
     ><IMG SRC="line_stroke_1.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course when you are armed with this knowledge, you can use it to be
creative, just as you can with font drawing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -stroke black -strokewidth 5 -draw "line 5,35 95,5" \
          -stroke white -strokewidth 2 -draw "line 5,35 95,5" \
          line_multi.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_multi.jpg"
     ><IMG SRC="line_multi.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here I used the thinnest "<CODE><A HREF="../option_link.cgi?strokewidth"
>-strokewidth</A></CODE>" setting of '<CODE>0</CODE>', just as I did for the
fonts above.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -fill white -stroke black -strokewidth 0 -draw "line 5,35 95,5" \
          line_stroke_0.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_0.jpg"
     ><IMG SRC="line_stroke_0.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This produces the very strange result of a dotted line, consisting of black
dots and grey segments.  This is the result of a weird "color beat frequency"
between the stroke, fill and background colors. </P>

Here is an enlarged view of the line...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 25x10 xc:lightblue \
          -fill white -stroke black -strokewidth 0 -draw "line 2,8 22,1" \
          -scale 400%    line_stroke_0_white.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_0_white.jpg"
     ><IMG SRC="line_stroke_0_white.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The "color beat frequency" effect is not unlike that of a "sound beat"
  you get when you have two guitars which are very slightly out of tune.  In
  this case you get a black dot where the stroke color completely overrides
  the underlying fill color and you get a grey dot where the stroke color
  mixes with BOTH the fill and the background colors. <P>

  The color mixing is a natural consequence of the anti-aliasing processes
  which IM uses to try to improve the look of lines and other draw objects.
  For more information see my <A HREF="../antialiasing/" >Anti-Aliasing in
  IM</A> discussion and examples page.

</I></FONT></TD></TR></TABLE></P>

Note that this effect only appears on slanted lines, not pure horizontal or
vertical lines, where aliasing has no effect and thus no "color beat
frequency" effects.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x40 xc:lightblue \
          -fill white -stroke black -strokewidth 0 -draw "line 5,20 95,20" \
          line_stroke_horz.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_horz.jpg"
     ><IMG SRC="line_stroke_horz.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Here I used different underlying fill colors on the enlarged view, so
you can see how the color changes the resulting beat.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 25x10 xc:lightblue \
          -fill none -stroke black -strokewidth 0 -draw "line 2,8 22,1" \
          -scale 400%     line_stroke_0_none.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_0_none.jpg"
     ><IMG SRC="line_stroke_0_none.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 25x10 xc:lightblue \
          -fill red -stroke black -strokewidth 0 -draw "line 2,8 22,1" \
          -scale 400%    line_stroke_0_red.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_0_red.jpg"
     ><IMG SRC="line_stroke_0_red.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 25x10 xc:lightblue \
          -fill black -stroke black -strokewidth 0 -draw "line 2,8 22,1" \
          -scale 400%    line_stroke_0_black.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_0_black.jpg"
     ><IMG SRC="line_stroke_0_black.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
<TR><TD width="100%" ALIGN=justify>
Lets compare that to a stroke of none...
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 25x10 xc:lightblue \
          -fill black -stroke none -draw "line 2,8 22,1" \
          -scale 400%    line_stroke_-_black.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="line_stroke_-_black.jpg"
     ><IMG SRC="line_stroke_-_black.jpg"   WIDTH=100 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

As you can see, when drawing very thin lines, you can reduce that 'beat' by
either using the same fill and stroke colors, OR setting one of the colors to
none to turn it off.  While the later is the best idea, the former may be more
practical for your specific programming needs.  </P>

Note the fill line thickness is '0'. But the the stroke line can have a larger
thickness. It is also a floating point value! A 2.5 pixel wide line is
perfectly valid.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  These results are caused by not only a buggy stroke width 0, causing a color
  beat, but also the 'fill color' being drawn with an extra 1.0 diameter
  thickness, when there is no actual area to be filled.   This I also regard
  as a bug. See <A HREF="#bounds" >Draw Fill Bounds</A>.
</I></FONT></TD></TR></TABLE></P>



<A NAME="bounds"></A>
<H3>Draw Fill Bounds</H3>

There are a few other points that you should note about the various draw
primitives. </P>

The stroke-width works well for floating point values above a value of 1.0,
but seems to break down for values less that 1.0. This is due to the
implementation algorithm used and not simply because it is wrong, as it works
fine with larger thickness lines. </P>

Basically if you use a stroke-width of zero you could expect that no stroke
color will be added. Instead you get a sort of beat pattern where stroke color
is at full strength when the line goes through the actual 'center' of the
pixel.. </P>

What really should happen is the amount of color added to a pixel should
reflect the area of the line being drawn, and not the pixels distance from
that line. As such lines of zero width should add no color to the image, while
lines of less than 1.0 thickness should only add a smaller amount of color.
</P>

See the examples <A HREF="#strokewidth" >Drawing Lines, with StrokeWidth and
Stroke</A> above.  </P>

The other problem is that the fill color is not being applied up to the edge
of the shape (polygon) being draw, but &frac12; pixel further out.  This
includes the situation where no 'stroke' is being applied, and the edge should
be exact.  It also includes drawing a 'line', which really has a 'zero' fill
thickness. </P>

Basically if you draw a line, without enabling stroke, technically you should
see, no line as it has no 'fill' thickness.  Instead lines are being drawn
with at minimum 1 pixel wide 'fill' color included. This is for historical
reasons, and generally avoids confusion by new users of IM. Unfortunatally it
is NOT correct for advanced users. </P>

What that means is that if you draw two polygons using fill color only, that
share an edge, that edge will overlap by 1 pixel as each polygon is &frac12;
pixel bigger along all its edges.  In other words polygons and other shapes
do not fit together, but overlap! </P>

For example here I try use draw to divide an image into two halves (drawing
black on white).  To do this I draw two polygons that share an edge, exactly
without overlap.  The resulting 'tiny' images, have been enlarged for display.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 10x10 xc: -draw 'polygon 2,-1 7,10 10,10 10,-1' bound_left.gif
  magick -size 10x10 xc: -draw 'polygon 2,-1 7,10 -1,10 -1,-1' bound_right.gif

  magick bound_left.gif bound_right.gif -compose Plus -composite bound_add.gif
</samp></pre></TD></TR></TABLE>
<!-- <CODE EXECUTE SCRIPT>
  for i in left right add; do
    enlarge_image -8 bound_${i}.gif bound_${i}_mag.gif
  done
</CODE> -->
</TD>
  <A HREF="bound_left_mag.gif"
     ><IMG SRC="bound_left_mag.gif"          WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="bound_right_mag.gif"
     ><IMG SRC="bound_right_mag.gif"          WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="bound_add_mag.gif"
     ><IMG SRC="bound_add_mag.gif"          WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The two black parts (which was what is actually drawn) actually overlap each
other!  In other words, even though we tried to draw the two areas separately
using drawn polygons, the filled area is slightly larger that what was
requested. </P>

I also added (<A HREF="../compose/#plus" >Plus Composited</A>) the two images
together so you can actually see the overlap of the drawn black areas.  If the
two polygons were a perfect fit the 'added' drawing would be a solid white
color. </P>

The actual amount of overlap is equivalent to the default "<CODE><A
HREF="../option_link.cgi?strokewidth" >-strokewidth</A> 1.0</CODE>" setting.
So it is normally expected that this extra area would be covered by a normal
stroke width. However it can cause some real problems. </P>

ASIDE: For a complete test of the join you would generate 50% grey areas on
a black background and add them together.  That way you can see if the areas
not only 'overlap' (as shown above), but also test if they 'underlap' (leaving
a gap between filled areas) when you add the areas together.  The resulting
image should be a perfectly smooth 50% grey color with no color variations
along the join. A transparency check would involve, a 50% transparent, 50%
gray color should be used on a fully transparent background. </P>

To see an example of a perfect cut and re-add, based on a single mask image,
see the composition method examples, <A HREF="../compose/#dstout" >Compose
DstOut</A>. </P>

FUTURE BUG FIX:  The area filled should be exact, but to compensate for this
when drawing shapes, the default 'stroke color' should be set to the fill
color (unless it is itself specifically set). </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="mvg"></A>
<H2>MVG - Magick Vector Graphics</H2>

The primitives shown above form the basis of all the "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" operations provided.
Together that are the starting point for a special internal language in
ImageMagick, called the <B>Magick Vector Graphics</B> language.  For more
detail of this language see <A
HREF="https://imagemagick.org/script/magick-vector-graphics.php" >Summary
of MVG Primitives and Syntax</A> on the IM website. </P>

This "MVG" language designed with the goal of allowing ImageMagick to handle
the even more complex SVG (<A HREF="http://www.w3.org/TR/SVG/" >Scalable
Vector Graphics</A>) language.  It does this by attempting to magick images
given the SVG format to the simpler internal MVG format.  For more details see
<A HREF="#svg" >SVG handling</A> below. </P>

Consequently what you saw above is only a tiny part of the capabilities of the
"<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" operator.  Though
if you want to draw complex objects, I do recommend you create a separate SVG
format image of the object using an SVG editor such as "<CODE><A
HREF="http://the-labs.com/Sodipodi/" >Sodipodi</A></CODE>".  (See <A
HREF="#other" >Non-IM Vector Graphic Programs</A> below). </P>

Unlike SVG, MVG does not have any form of 'containers' or sets of image
commands.  These are all removed during the conversion process to produce a
simplified sequence of MVG drawing commands.  Instead it uses a concept of <A
HREF="#push_context" >Graphic Contexts</A> to save and restore various
drawing settings, which is what we will now look at.  </P>

<A NAME="settings"></A>
<H3>Command Line Settings vs MVG Settings</H3>

First of all, almost all the settings you set via the command line options
that the the draw primitives use have direct equivalents in the MVG drawing
commands. </P>

The main difference between setting the via a command line option, (such as
"<A HREF="../option_link.cgi?strokewidth" >-strokewidth</A></CODE>") or using
a setting within a MVG drawing string (for example
'<CODE>stroke-width</CODE>), is that the MVG setting only lasts for the
duration of the MVG command string.  </P>


<PRE>
<B>Summary of the General Drawing Settings</B>
  __cmd_option__   __draw_MVG__        __Argument__
    -fill            fill                color/tile for inside shapes
    -tile            fill                image tile, replaces fill color

    -stroke          stroke              line color/tile around the shapes
    -strokewidth     stroke-width        pixel width
    +antialias       stroke-antialias    0/1 aliasing line edges

    -font            font                font_name / font_file
    -family          font-family            ?
    -weight            ?                    ?
    -stretch           ?                    ?
    -pointsize       font-size           height in points
    -kerning           -                 extra inter-character spacing

    +antialias       text-antialias      0/1 aliasing drawing text
    -box             text-undercolor     fill color for font bounding box
      -              decorate        (None, Underline, LineThrough or Overline)

    -gravity         gravity             (None, North, South-East,...)
    -fuzz              -                 color delta / percentage
    -bordercolor       -                 color

Notes:
  - no such option      ? unknown
</PRE>

These settings are usually well understood as they are regularly used and
demonstrated above. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  A font, stretch, style, and weight are used to identify a font from the
  ImageMagick font list. Most people however just select a specific font and
  pointsize to use instead.  As such they are rarely used in IM.
</I></FONT></TD></TR></TABLE></P>

As you can see the special settings for the 'color fill' primitives do not have
direct equivalents in the MVG.  That is the  "<A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" and the "<A
HREF="../option_link.cgi?fuzz" >-fuzz</A></CODE>" factor setting.  These must
be specified from the command line before using the "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" operator. </P>

Some MVG settings would probably be more useful as global command line
settings, such as the '<CODE>decorate</CODE>' setting for font drawing. </P>

WARNING: "<A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" is not
part of the SVG specification.  Within MVG it is only used for text and image
placement, and justification.  Their is currently no justification setting
that is separate to the default 'gravitational' effects. However as
justification is part of SVG text handling, that will probably change sometime
in the future. </P>

Now the global command line settings (outside the MVG draw string) are used to
initialise the settings for each "<A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" operation you apply, which is why you can set a "<A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" colour which you can then
use to draw a circle of that color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD COLSPAN=2 ALIGN=justify>
</TD></TR><TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue   -fill red \
          -draw "circle 50,30 40,10"          draw_circle_global.gif
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="draw_circle_global.gif"
     ><IMG SRC="draw_circle_global.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can override that global setting locally within the "<A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" MVG argument...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD COLSPAN=2 ALIGN=justify>
</TD></TR><TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue   -fill red \
          -draw "fill green   circle 50,30 40,10"  draw_circle_override.gif
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="draw_circle_override.gif"
     ><IMG SRC="draw_circle_override.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However settings set within a single "<A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" MVG argument only exist for the duration of that "<A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" operation.  That is settings
within a "<A HREF="../option_link.cgi?draw" >-draw</A></CODE>" are local only
to that draw and do not carry into later separate "<A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" arguments. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD COLSPAN=2 ALIGN=justify>
</TD></TR><TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue   -fill red   -draw 'fill green' \
          -draw "circle 50,30 40,10"          draw_circle_local.gif
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="draw_circle_local.gif"
     ><IMG SRC="draw_circle_local.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you plan to do a lot of operations, it may be better to do them all in the
single MVG string, rather than multiple "<A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" operations.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD COLSPAN=2 ALIGN=justify>
</TD></TR><TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 100x60 xc:skyblue  \
          -draw "fill green  circle 41,39 44,57
                 fill blue   circle 59,39 56,57
                 fill red    circle 50,21 50,3  "  draw_circle_multi.gif
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="draw_circle_multi.gif"
     ><IMG SRC="draw_circle_multi.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="mvg_settings">
<H3>MVG Specific Settings</H3>
</A>

Other MVG settings that control the way lines and objects are drawn are
also useful to know even when using the primitive operations. These include..

<PRE>
   __draw_MVG__       __Description/Argument__
  fill-opacity        fill transparency, from 0.0 to 1.0
  clip-rule           fill style for crossed lines (evenodd, nonzero)

  stroke-opacity      line transparency, number from 0.0 to 1.0
  stroke-dasharray    list of 'on' and 'off' lengths for lines
  stroke-dash
  stroke-linecap      End of line look: butt round square
  stroke-linejoin     Lines joins:  butt  miter round square
  stroke-miterlimit   Angle when 'miter' joins become 'bevel' (or 'butt')
</PRE>

Remember a full list of all MVG settings and drawing operators can be seen at
<A HREF="https://imagemagick.org/script/magick-vector-graphics.php"
>Summary of MVG Primitives and Syntax</A> in the IM website. </P>

Lets look at the effects of some of the simpler settings...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify ROWSPAN=2 >
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Stroke Opacity
  magick -size 100x60 xc:skyblue -fill none -stroke black \
          -draw "                           path 'M 10,10 L 90,10'" \
          -draw "stroke-opacity 0.8         path 'M 10,20 L 90,20'" \
          -draw "stroke-opacity 0.6         path 'M 10,30 L 90,30'" \
          -draw "stroke-opacity 0.4         path 'M 10,40 L 90,40'" \
          -draw "stroke-opacity 0.2         path 'M 10,50 L 90,50'" \
          set_stroke_opacity.gif

  # Fill Opacity
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "                    rectangle  5,10 15,50 " \
          -draw "fill-opacity 0.8    rectangle 20,10 30,50 " \
          -draw "fill-opacity 0.6    rectangle 35,10 45,50 " \
          -draw "fill-opacity 0.4    rectangle 50,10 60,50 " \
          -draw "fill-opacity 0.2    rectangle 65,10 75,50 " \
          -draw "fill-opacity  0     rectangle 80,10 90,50 " \
          set_fill_opacity.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="set_stroke_opacity.gif"
     ><IMG SRC="set_stroke_opacity.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="set_fill_opacity.gif"
     ><IMG SRC="set_fill_opacity.gif"        WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>

<TR><TD width="100%" ALIGN=justify ROWSPAN=2 >
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Plain and Dashed Lines
  magick -size 100x60 xc:skyblue -fill none -stroke black \
          -draw "                           path 'M 10,10 L 90,10'" \
          -draw "stroke-dasharray 5 3       path 'M 10,20 L 90,20'" \
          -draw "stroke-dasharray 5 5       path 'M 10,30 L 90,30'" \
          -draw "stroke-dasharray 10 3 3 3  path 'M 10,40 L 90,40'" \
          -draw "stroke-dasharray 1 6       path 'M 10,50 L 90,50'" \
          set_lines.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "                           path 'M 10,10 L 90,10'" \
          -draw "stroke-dasharray 5 3       path 'M 10,20 L 90,20'" \
          -draw "stroke-dasharray 5 5       path 'M 10,30 L 90,30'" \
          -draw "stroke-dasharray 10 3 3 3  path 'M 10,40 L 90,40'" \
          -draw "stroke-dasharray 1 6       path 'M 10,50 L 90,50'" \
          set_lines_fill.gif

  # Note: Technically the second image should be the same as the first
  # as the 'filled' lines contain no area.  This I regard as a BUG.

</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="set_lines.gif"
     ><IMG SRC="set_lines.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="set_lines_fill.gif"
     ><IMG SRC="set_lines_fill.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>

<TR><TD width="100%" ALIGN=justify ROWSPAN=3 >
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Stroke Ends and Joins
  magick -size 100x60 xc:skyblue -fill white -stroke black -strokewidth 8 \
          -draw "                           path 'M 20,20 L 20,70'" \
          -draw "stroke-linecap butt        path 'M 40,20 L 40,70'" \
          -draw "stroke-linecap round       path 'M 60,20 L 60,70'" \
          -draw "stroke-linecap square      path 'M 80,20 L 80,70'" \
          set_endcaps.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black -strokewidth 5 \
          -draw "                        path 'M  5,70 L 20,20  35,70'" \
          -draw "stroke-linejoin miter   path 'M 35,70 L 50,20  65,70'" \
          -draw "stroke-linejoin bevel   path 'M 55,70 L 70,20  85,70'" \
          -draw "stroke-linejoin round   path 'M 75,70 L 90,20 105,70'" \
          set_linejoin.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black -strokewidth 5 \
          -draw "                        path 'M  5,70 L 20,20  35,70'" \
          -draw "stroke-miterlimit 7     path 'M 35,70 L 50,20  65,70'" \
          -draw "stroke-miterlimit 6     path 'M 65,70 L 80,20  95,70'" \
          set_miterlimit.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="set_endcaps.gif"
     ><IMG SRC="set_endcaps.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="set_linejoin.gif"
     ><IMG SRC="set_linejoin.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="set_miterlimit.gif"
     ><IMG SRC="set_miterlimit.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

The '<CODE>stroke-miterlimit</CODE>' setting is rather hard to demonstrate.
This property defines the angle at which a '<CODE>miter</CODE>' join is
changed into a '<CODE>bevel</CODE>' join.  Basically for very sharp angles
a miter can extend a long way from the actual join in the two lines. This sets
a maximum limit to that sharpness, and blunting the corner point when it gets
too long.  Note however that it represents a trigonmetric value of an angle of
some kind, and is not a length or distance.  The value must be greater than
1.0. </P>

The above shows how for the join angle I am display, the miter will suddenly
be magick into a bevel somewhere between a value of 6 to 7. </P>

For example, a '<CODE>stroke-miterlimit</CODE>' of 1.414 converts
a '<CODE>miter</CODE>' to '<CODE>bevel</CODE>' for any angle of less than 90
degrees.  A value of 4.0 (the default) converts the join for angles less than
approximately 29 degrees. While a value of of 10.0 converts them for an angle
less than approximately 11.5 degrees. </P>


<A NAME="paths">
<H2>SVG Path Drawing</H2>
</A>

The SVG path is the basic drawing primitive of SVG.  It is used to draw lines
shapes, circles, curves, arcs and so on.  The full specification of the SVG
Paths can be found in the <A
HREF="http://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation" >SVG
Path Specification</A> document. </P>

This however is not an easy document to read as it is really for programmers,
not users, so I'll simplify and summarize the path specification...

<UL>
<LI>Letters are commands, while all numbers (floating point) are arguments.
<LI>Commas or spaces may be used as argument separators,
    otherwise they are completely ignored.
<LI>The last two arguments (x,y) of each path component will become the
    end point (or 'knot') of that path component.
<LI>Uppercase letters specify the final point absolute coordinates.
<BR>Lowercase letters are relative to the end point of the previous component.
<BR>For example:  "<CODE> M 1,2 &nbsp; l 3,4 &nbsp; l 2,-4 </CODE>"
    is the same as "<CODE> M 1,2 &nbsp; L 4,6 &nbsp; L 6,2 </CODE>".
<BR>That is 3,4 was added to 1,2, to draw a line to 4,6.
<BR>Then 2,-4 was added to draw a line to the final coordinate of 6,2.
<LI>The arguments of each element may be repeated without re-issuing the same
    path letter, by adding more number argument groups.  However for curves, I
    recommend you add the function letters anyway for ease of reading.
<LI>Repeated arguments of "<CODE>M</CODE>" or "<CODE>m</CODE>"
    are treated as "<CODE>L</CODE>" or "<CODE>l</CODE>"  respectively.
<BR>For example:  "<CODE> M 1,2 &nbsp; 3,4 &nbsp; 5,6 </CODE>" is the same as
    "<CODE> M 1,2 &nbsp; L 3,4 &nbsp; L 5,6 </CODE>"
<BR>And :  "<CODE> m 1,2 &nbsp; 3,4 &nbsp; 2,-4 </CODE>" is the same as
    "<CODE> m 1,2 &nbsp; l 3,4 &nbsp; l 2,-4 </CODE>"
<LI>For cubic bezier all points (control and end knot points) are given
    relative to the end point of the previous path component.
</UL></P>

Note how you can specify things as either absolute coordinates or relative
coordinates.  Thus you can define an object in terms of relative
coordinates and just supply an initial absolute 'move' coordinate to position
the whole path. </P>

On the other hand you can also use other 'graphic-content' commands to move a
whole drawing within a 'viewbox' or 'translation', (see below).  So really it
does not matter if you use absolute or relative coordinates in SVG paths. </P>

<A NAME="lines"></A>

<B>Moves, Lines and Path Closures</B> are the initial starting point
for learning about SVG object paths.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Open, Completed and Closed Paths (same points)

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 40,10 L 20,50 90,10 70,40'" path_open.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 40,10 L 20,50 90,10 70,40 40,10'" path_complete.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 40,10 20,50 90,10 70,40 Z'" path_closed.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_open.gif"
     ><IMG SRC="path_open.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="path_complete.gif"
     ><IMG SRC="path_complete.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_closed.gif"
     ><IMG SRC="path_closed.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note however that '<CODE>Z</CODE>' only closes the loop.  It does NOT create a
separate object.  As such two 'closed' paths are still classed as being a
single drawn object, weather they are overlapping or completely disconnected.
</P>

<A NAME="fill-rule"></A>

Here we show two closed but overlapping loops, drawn in the same direction. As
only a single path is used the object is a single object, and the
'<B><CODE>fill-rule</CODE></B>' setting controls how the overlapping region is
to be filled.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  # Overlapping Paths and Fill Rule

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "fill-rule evenodd \
                 path 'M 40,10 20,20 70,50 Z
                       M 20,40 70,40 90,10 Z' " path_evenodd.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "fill-rule nonzero \
                 path 'M 40,10 20,20 70,50 Z
                       M 20,40 70,40 90,10 Z' " path_nonzero.gif
</samp></pre></TD></TR></TABLE></TD><TD>
<BR><A HREF="path_evenodd.gif"
     ><IMG SRC="path_evenodd.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_nonzero.gif"
     ><IMG SRC="path_nonzero.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As the objects were drawn in the same angular direction around the center, the
two closed loops will inclose an area that has a cycle value of 2. as such the
'<CODE>evenodd</CODE>' rule made that area unfilled, while the non-zero
'<CODE>nonzero</CODE>' rule filled it.  Note however that all paths are
visible, as they are actually the same object. </P>

The direction in which paths are drawn is very important, and in general all
the paths should be drawn in exactly the same direction relative to the
'inside' of the object.  </P>

For example here I draw the second object in the reverse direction to the
first.  As such when the two objects overlap that area is circled
'<I>zero</I>' times.  That is it will be unfilled no matter what
'<CODE>fill-rule</CODE>' is used, creating a 'hole'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  # Overlapping Closed Objects, Second object drawn in reverse

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "fill-rule evenodd \
                 path 'M 40,10 20,20 70,50 Z
                       M 20,40 90,10 70,40 Z' " path_rvs_evenodd.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "fill-rule nonzero \
                 path 'M 40,10 20,20 70,50 Z
                       M 20,40 90,10 70,40 Z' " path_rvs_nonzero.gif
</samp></pre></TD></TR></TABLE></TD><TD>
<BR><A HREF="path_rvs_nonzero.gif"
     ><IMG SRC="path_rvs_nonzero.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_rvs_evenodd.gif"
     ><IMG SRC="path_rvs_evenodd.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This means that you can generate a 'holes' in an object, by reversing the
direction, so as to keep the 'inside' of the object to the same side of the
direction of travel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  # An object with a reversed drawn hole!

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,10 20,55 70,50 80,5 Z
                       M 50,20 60,40 40,30 Z' " path_with_hole.gif
</samp></pre></TD></TR></TABLE></TD><TD>
<BR><A HREF="path_with_hole.gif"
     ><IMG SRC="path_with_hole.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The result is the same regardless of the '<CODE>fill-rule</CODE>' setting, as
the hole is both 'even' and 'zero' so is unfilled. </P>

Of course if you use a completely separate '<CODE>path</CODE>' element, you
will generate a completely separate object.  In which case,  the
'<CODE>fill-rule</CODE>' does not apply and the objects are just drawn on top
of each other, in the order given. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  # Separate paths are separate objects

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 40,10 20,20 70,50 Z'
                 path 'M 20,40 70,40 90,10 Z' " path_separate.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_separate.gif"
     ><IMG SRC="path_separate.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<PRE>FUTURE: coordinate aligned paths  "H" and "V" </PRE>

<A NAME="arcs"></A>

<B>Elliptical Arcs</B> are the circle drawing function of SVG Paths...
<BR> The 'large' and 'sweep' parameters are especially important as they are
used to determine which of the four ways you will 'arc' from your starting
point to the finishing point for that path component. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify COLSPAN=2>

The two flags 'large' and 'sweep' define which of the four arcs of that radius
will connect the two points. </P>

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  #  Elliptical Arcs :   A  radius_x,y  angle   large,sweep  x,y

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,15 0 0,0 70,20'"    path_arc.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,15 0 0,1 70,20'"    path_arc2.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,15 0 1,0 70,20'"    path_arc3.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,15 0 1,1 70,20'"    path_arc4.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_arc.gif"
     ><IMG SRC="path_arc.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_arc2.gif"
     ><IMG SRC="path_arc2.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_arc3.gif"
     ><IMG SRC="path_arc3.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_arc4.gif"
     ><IMG SRC="path_arc4.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

the second flag 'sweep' simply determines which side of the direction of the
straight line path the arc should be drawn. </P>

The 'large' flag is used to select the longer path, going around the center of
the ellipse.  That is set angle of the arc will be larger that 180 degrees. If
turned off you get the smaller 'arc' not containing the center of the ellipse,
and arcing over an angle less than 180 degrees. </P>

Closing an arc with a 'Z' just draws a final straight line segment. </P>

To create a full ellipse or circle you will need at least two 'arc' segments,
going from the first to the second point, then back to the first point.  Both
arcs should have the same 'sweep' setting, so the arc will be on different
sides, with the different direction of travel. One of the arcs should have the
'large' setting set.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify COLSPAN=2>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Closed and angled elliptical arcs  (defined by two edge points)

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,20  20  0,0 70,20 Z '" path_arc5.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,20  20  1,1 70,20 Z '" path_arc6.gif

  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40  A 30,20  20  0,0 70,20 \
                                A 30,20  20  1,0 30,40 Z '" path_arc7.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_arc5.gif"
     ><IMG SRC="path_arc5.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_arc6.gif"
     ><IMG SRC="path_arc6.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="path_arc7.gif"
     ><IMG SRC="path_arc7.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that if the line is too long to fit the given ellipse size at the angle
given, the size of the ellipse will be enlarged to fit the line with the
ellipse centered on the line. </P>

This means that by using small numbers for the axis radii, you can just
specify a ratio of axis lengths, and gurantee the direct line path goes though
the center point of the ellipse. That is the path forms an elliptical
diameter from one side of the ellipse to the other. This is not nessarilly the
major or minor axis of the ellipse, just an elliptical diameter.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40   A 3,2  45  0,0 70,20'" path_arc_x.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_arc_x.gif"
     ><IMG SRC="path_arc_x.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course using lengths of "<CODE>1,1</CODE>" results in a perfect
half-circle, going from one point, to the next point.  The elliptical angle
in this case will make no difference.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40   A 1,1  0  0,0 70,20'" path_hcircle.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_hcircle.gif"
     ><IMG SRC="path_hcircle.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For a full circle centered between the two points use...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=path_circle.gif >
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40   A 1,1  0  0,0 70,20
                                 A 1,1  0  1,0 30,40  Z'" path_circle.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_circle.gif"
     ><IMG SRC="path_circle.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The SVG definition of 'arc' also declares that if either of the two radii are
zero, then a straight line should be drawn.  Thus any arc with
"<CODE>0,0</CODE>" radii, is just a simple straight line arc...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40   A 0,0  0  0,0 70,20'" path_arc_line.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_arc_line.gif"
     ><IMG SRC="path_arc_line.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


If you specify a very large radii for the arc, and do not specify a 'large
sweep' for the return path, you can create lens shape of that radius between
the two points.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=path_lens.gif >
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 30,40   A 50,50  0  0,0 70,20
                                 A 50,50  0  0,0 30,40  Z'" path_lens.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_lens.gif"
     ><IMG SRC="path_lens.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This type of arc is a key feature.  It allows you to give what is an otherwise
straight line, a small but distinct curve very easily. </P>

For example instead of a simple triangle like this...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 20,55  L 25,10  L 70,5 L 20,55 Z' "   triangle.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="triangle.gif"
     ><IMG SRC="triangle.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can replace each line with an arc using a large radius
to give them just a slight curve.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=triangle_curved.gif >
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 20,55  A 100,100 0 0,0 25,10
                                A 100,100 0 0,0 70,5
                                A 100,100 0 0,0 20,55 Z' " triangle_curved.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="triangle_curved.gif"
     ><IMG SRC="triangle_curved.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The end points of the lines have no changes, all that has happened is that
each '<CODE>L</CODE>' was replaced by an arc segment.  The size of the arc
however should be proportional to the length of the line.  As I did not do
this the longer diagonal line has a far stronger deeper curve, than the other
two. </P>

Remember when resizing or scaling the object being draw you should also scale
the radius by the same amount as that lines length so the curve is resized
accordinally, so the arc also scales correctly. </P>

Note that the 'sweep' flag controls if the curve bulges outward or inward,
according to the direction each path segment is drawn (see above).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=triangle_bulge.gif >
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 20,55  A 100,100 0 0,0 25,10
                                A 100,100 0 0,1 70,5
                                A 100,100 0 0,1 20,55 Z' " triangle_bulge.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="triangle_bulge.gif"
     ><IMG SRC="triangle_bulge.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The 'static' looking triangle of straight edges, now looks a bit like a sail
filling with a wind. </P>

If you really want to make the line perfectly straight without converting them
back into true line segments, you can turn off the curve by using an arc radius
of zero. </P>

Arcs are thus not only good for generating ellipses and circles, but it is
useful for drawing straight and slightly curved line segments.  It is a very
versatile general point-to-point draw path. </P>

One simple alternative to using Elliptical Arcs for generating separated
curved line segments is to use <A HREF="#quad" >Quadratic Bezier Segments</A>
instead.  the main difference is that a single control point is used, rather
than a circular radius to define the arc.  This also allows you to bias the
arc toward one end of the line segment, but at the cost of making it harder to
generate a symmetrical arc. </P>

You can of course 'mix-n-match' by using both. </P>

<A NAME="piechart"></A>
<B>Pie Chart Example</B></P>

To finish off using arcs, lets give an example of using for them to generate
circular wedges.  Of course you may need to use some external trigonometric
mathematics (how good was your senior high school math?) to determine the end
path points that are required.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 140x130 xc:white -stroke black \
    -fill red   -draw "path 'M 60,70 L   60,20   A 50,50 0 0,1 68.7,20.8 Z'" \
    -fill green -draw "path 'M 60,70 L 68.7,20.8 A 50,50 0 0,1 77.1,23.0 Z'" \
    -fill blue  -draw "path 'M 68,65 L 85.1,18.0 A 50,50 0 0,1  118,65   Z'" \
    -fill gold  -draw "path 'M 60,70 L  110,70   A 50,50 0 1,1   60,20   Z'" \
    -fill black -stroke none  -pointsize 10 \
    -draw "text 57,19 '10' text 70,20 '10' text 90,19 '70' text 113,78 '270'" \
    piechart.jpg
</samp></pre></TD></TR></TABLE></TD><TD>
 <A HREF="piechart.jpg"
    ><IMG SRC="piechart.jpg"             WIDTH=140  HEIGHT=130
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that all the arcs are drawn to the left of the 'line path', and are
flagged accordingly (using the 'sweep' flag).  But if the arc covers an angle
larger than 180 degrees, the 'large' flag needs to be set. see the last 'gold'
component in the example above. </P>

Also note that you should draw each section completely, even though this means
you may have to draw bordering lines twice.  If you don't you will probably
either not completely fill that section with color, or the fill color will
overlay a previously drawn section outline. </P>

The only way to avoid doubling up multiple lines is to draw all the filled
areas, then repeat so as to draw the outlines.  That is you will need to
drawing everything twice, ensuring things match up properly.  Thus, doubling
up of the outlines is probably the simplest solution. </P>


<A NAME="cubic"></A>

<B>Cubic Bezier</B> curves can be defined using a '<CODE>C</CODE>' function
defining two control points, and the final end point.  For continuing Cubic
Bezier curves that use a mirror image of the last control point (for a
continuous curve), you can use a '<CODE>S</CODE>' function. </P>

Here is an example.  Because of the complexity of this function, I
pre-prepared a canvas showing the location of the control points, as well as
the 'assumed mirror' of the last control point.

<!-- <CODE EXECUTE>
  magick -size 100x60 xc:skyblue -fill none  -stroke dodgerblue \
          -draw "line 10,30 10,4 line 50,4 50,56 line 90,30 90,56" \
          -fill dodgerblue -stroke dodgerblue \
          -draw "circle 10,4 10,1  circle 50,4 50,1  circle 90,56 90,59" \
          -fill none -draw "circle 50,56 50,59" \
          path_cubic_canvas.gif
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  # Cubic Bezier:    C  control_1_x,y control_2_x,y  x,y
  # Smooth " :       S  control_2_x,y  x,y

  magick path_cubic_canvas.gif  -fill white -stroke black \
          -draw "path 'M 10,30  C 10,4 50,4 50,30  S 90,55 90,30' " \
          path_cubic.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_cubic.gif"
     ><IMG SRC="path_cubic.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The line connecting the control point to the final point on the path of that
path segment (control line) basically defines the direction of the curve
though that point on the path.  A long control line will produce a smoother
curve at that point, while a short line generates a sharper curve at that
point. If the control point matches the point of the curve (control line is
zero in length) the curve with have a sharp discontinuity at that point, as if
only straight line segments were used. </P>

As a more practical example, the following bit of code is extracted from the
<A HREF="../scripts/generate_logo" >IM Examples Logo Generator Script</A>
which creates the curvy splash area of the <A HREF="../images/logo.gif" >IM
Examples Logo</A> </P>

The tricky part of the example is that I magick the Cubic Bezier path string
I use, into another path showing the control lines used to generate the bezier
curve.  This lets me see the curve's control line angles and lengths, making
it a lot easier to adjust the results. Only one set of points needs to be
adjusted to show both curve and controls, keeping mistakes to a minimum.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
   curve="M 12,27  C 7,37  18,50 18,60  S  0,80 10,94
          S 40,74 50,78  S 60,99 76,95  S 72,70 75,65
          S 95,55 95,42  S 69,37 66,32  S 67,2  53,7
          S 43,17 35,22  S 17,17 12,27  Z"
   c_ctrls=`echo $curve | \
              sed '1s/\([0-9]\)  *\([0-9]\)/\1 M \2/;
                   s/S/M/g; s/C/ /;' -`
   magick -size 100x100 xc:white \
           -draw "stroke None  fill Green  path '$curve'" \
           -draw "stroke Red   fill None   path '$c_ctrls'" \
           curvy_splash.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="curvy_splash.gif"
     ><IMG SRC="curvy_splash.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you look closely at the image you will see that the start and end of the
curve has two control lines facing in opposite directions.  For a closed
continuous path, both start and end control lines should be at the same angle
(just in mirror direction), and of course the same length. This is important
to remember, as it is easy to get this wrong. </P>

All the other points along the curve only has a single control point/line
which points in the <I>opposite direction</I> to the direction the curve is
drawn.  The longer that line segment, less 'sharp' the curve is at that
control point, with a zero length producing a 'point'. </P>

The '<CODE>S</CODE>' function internally generates the mirror control
point/line for the next segment from the data of the previous segment, so as
to produce a smooth continuation of the curve. </P>

For more examples of this path function see, <A
HREF="http://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands" >SVG:
Cubic Bezier Curve Commands</A>. </P>


<B>Manually Generating a Bezier Curve</B> is relatively straight forward
without needing any fancy GUI tools. </P>

<UL>
<LI>First define all the coordinate points you want you curve to go though,
    repeat the starting coordinate at the end of the list.
<LI>Now expand this list by doubling all the x,y coordinate points into pairs
    and add a '<CODE>S</CODE>' (Smooth Cubic) function before every pair.  The
    first number in each pair is the control point connected to the second
    number representing the point on the curve.  The first point pair however
    has this reversed, with the first point being the start of the curve and
    the second representing the first and only inverted control point.
<LI>Change the function letter of the first pair of coordinates from an
    '<CODE>S</CODE>' into an '<CODE>M</CODE>', then add a '<CODE>C</CODE>'
    between this pair of coordinates. Finally remove the
    '<CODE>S</CODE>' from the second pair of coordinates, to complete the
    initial Cubic ('<CODE>C</CODE>') function.
<LI>Complete the path by adding a final '<CODE>Z</CODE>' to close the curve.
<BR>See the example sequence above as to how it should look.
</P>
<LI>At this point you can test draw your path. The path will only consist of
    straight line segments as all control lines will be of length zero.
<LI>All you need to do is now slowly and carefully adjust the position of the
    controlling line segment (the first coordinate of each '<CODE>S</CODE>'
    pair) to get the final curve you want. Do not make control lines too long,
    or in the wrong direction or you'll get a very funny looking curve.
<LI>To help see your changes and find mistakes, use the conversion
    "<CODE>sed</CODE>" command above to draw the control lines between the
    path control points and the curve control point.  Note however that zero
    length control lines are not visible, but as the lin will produce a sharp
    point the position should be obvious.
<LI>Finally ensure the first control point/line after a '<CODE>C</CODE>' is
    exactly opposite that of the of the ending control/line, at that same
    position. </P>
</UL> </P>

<B>Interactive Curve Generation</B> is also possible by using some vector
graphic editors. </P>

For example <I>Luis Guerra</I> reports that "<A
HREF="http://www.inkscape.org/" >Inkscape</A>" generated bezier curves can be
made accessible using the "Edit -&gt; XML Editor" function then selecting the
path or shape you want the control points for. </P>

<BLOCKQUOTE><I>
Do you know of other ways of extracting a bezier curve (giving either two or
one control point per point on curve) using a GUI tool.  Or perhaps some other
technique for generating such curves?  Email me! I'd love to hear about it.
You will be credited with the technique as others have.
</I></BLOCKQUOTE></P>


<A NAME="quad"></A>

<B>Quadratic Bezier</B> is a simplification of the Cubic Bezier function, when
the two control points are merged into a single control point. Again you can
start the curve with a '<CODE>Q</CODE>' function, and then use a
'<CODE>T</CODE>' function to continue the curve, mirroring the last control
point.

<!-- <CODE EXECUTE>
  magick -size 100x60 xc:skyblue -fill none  -stroke dodgerblue \
          -draw "path 'M 10,30 20,4 80,56 90,30'" \
          -fill dodgerblue  -draw "circle 20,4  20,1" \
          -fill none        -draw "circle 80,56 80,59" \
          path_quad_canvas.gif
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  #  Quadratic Bezier:  Q  control_x,y  x,y
  #  Smooth " :         T  x,y

  magick path_quad_canvas.gif  -fill white -stroke black \
          -draw "path 'M 10,30   Q 20,4 50,30   T 90,30' " \
          path_quad.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="path_quad.gif"
     ><IMG SRC="path_quad.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

I should warn you however that the '<CODE>T</CODE>' continuing function really
only works for paths which connect points that are equally spaced. I do not
recommend its use. </P>

The advantage of Quadratic Curves is as a replacement for <A HREF="#arcs"
>Elliptical Arcs</A> as it uses an actual position, rather than radius for the
arc. It can also bias the arc in favor of one end over another, which not
practical when using <A HREF="#arcs" >Elliptical Arcs</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=triangle_bulge.gif >
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "path 'M 20,55  Q 30,32 25,10
                                Q 50,1 70,5
                                Q 50,45 20,55 Z' " triangle_bulge_2.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="triangle_bulge_2.gif"
     ><IMG SRC="triangle_bulge_2.gif"      WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In this case the arcs are not so uniform, and you get something like
an upside-down shark fin, rather than a sail. </P>

Remember Quadratic Arcs are parabolas, while Elliptical Arcs basically
generate circular segments.  This may be the key to determined which type of
arc'ing line segment you should use.  </P>

For more examples of this path function see, <A
HREF="http://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands"
>SVG: Quadratic Bezier Curve Commands</A>. </P>


<A NAME="transform"></A>
<H3> Warping of the Drawing Surface</H3>

On top of these abilities, the drawing surface on which the objects are drawn
can be warped in various ways to allow you to do some amazing things. </P>

First you can apply some general drawing surface modifications such as...
'<CODE>translate</CODE>', '<CODE>rotate</CODE>', '<CODE>scale</CODE>',
'<CODE>skewX</CODE>', '<CODE>skewY</CODE>', and '<CODE>affine</CODE>'. </P>

For example given a 'path' of lines we can "</CODE>translate</CODE>" the
origin or 0,0 point of the drawing surface to another location.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=transform_translate.gif>
  magick -size 100x60 xc:skyblue \
          -draw "translate 50,30
                 image over 3,3 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "  transform_translate.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="transform_translate.gif"
     ><IMG SRC="transform_translate.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice that the '<CODE>0,0</CODE>' or origin of the drawing area is now
centered on the image, though the Y axis remains negative at the top and
positive at the bottom of the image. </P>

The "<CODE>rotate</CODE>" operation will rotate the drawing surface
so anything later drawn on that surface will be drawn rotated. Of course it
will rotate around the translated origin, so it is a good idea to use both
transformation operators together.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=transform_rotate.gif>
  magick -size 100x60 xc:skyblue \
          -draw "translate 50,30    rotate -30
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "  transform_rotate.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="transform_rotate.gif"
     ><IMG SRC="transform_rotate.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

"<CODE>scale</CODE>" will magnify and shrink the drawing surface around the
origin.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=transform_scale.gif>
  magick -size 100x60 xc:skyblue \
          -draw "translate 50,30    scale 1.5,1.5
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "  transform_scale.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="transform_scale.gif"
     ><IMG SRC="transform_scale.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

One common use of "<CODE>scale</CODE>" is to flip the Y axis so that the a
positive Y value is upward.  Of course the origin should also be moved either
to the center, or the lower left corner, to keep things in order.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=transform_flip.gif>
  magick -size 100x60 xc:skyblue \
          -draw "translate 50,30    scale 1,-1
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "    transform_flip.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="transform_flip.gif"
     ><IMG SRC="transform_flip.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And finally, "<CODE>skewX</CODE>" and "<CODE>skewY</CODE>" shear the
image in the X and Y directions.  For example, here we use "<CODE>skewX</CODE>"
to give the vertical Y axis of the image a slant.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=transform_skewY.gif>
  magick -size 100x60 xc:skyblue \
          -draw "translate 50,30   skewX 20
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "    transform_skewY.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="transform_skewY.gif"
     ><IMG SRC="transform_skewY.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These operators have equivalents outside the MVG "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" string, for general use.
However these command line versions are operators and are applied immediately
to images already existing in memory rather that to a drawn surface only which
vector objects have yet to be drawn.  For more details see <A
HREF="../distorts/#summary" >Distorting Images</A>. </P>

<BR>


<A NAME="affine"></A>
<H3> Affine Warping of the Drawing Surface</H3>

All five of the above canvas transformations can be combined into a general
Affine Matrix Operator.  either by using the MVG primitive
'<CODE>affine</CODE>' or setting the affine transformation using "<CODE><A
HREF="../option_link.cgi?affine" >-affine</A></CODE>" before calling "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>". </P>

Affine transformations use a set of '<I>Matrix Coefficients</I>' which defines
how the coordinates you give should be modified into actual drawing coordinates.
</P>

For more details on how these 'coefficients' actually work, see
<A HREF="../distorts/affine/" >Affine Matrix Transforms</A>. </P>

For example... To just set a central origin relative to while objects are
drawn...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 100x60 xc:skyblue \
          -draw "affine 1,0,0,1,50,30
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "  affine_null.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_null.gif"
     ><IMG SRC="affine_null.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Flip image over...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 100x60 xc:skyblue \
          -draw "affine 1,0,0,-1,50,30
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' " affine_flip.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_flip.gif"
     ><IMG SRC="affine_flip.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Rotate by 30 degrees around the origin...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 100x60 xc:skyblue \
          -draw "affine .866,-.5,.5,.866,50,30
                 image over 4,4 0,0 'terminal.gif'
                 fill white  stroke black
                 path 'M 0,20 -45,20 20,-25 -25,-25'
                 fill none  stroke red
                 path 'M 0,10 0,-10  M 10,0 -10,0' "    affine_rot.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="affine_rot.gif"
     ><IMG SRC="affine_rot.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


For more complex Affine transformations you can make use of the <A
HREF="../distorts/affine/#affine_scripts" >Affine Helper Scripts</A> that were
created for the purpose.  These scripts magick things like a rotation angle
and center point into affine coordinates that you can directly use in your
"<CODE><A HREF="../option_link.cgi?draw" >-draw</A> affine</CODE>", or
"<CODE><A HREF="../option_link.cgi?affine" >-affine</A></CODE>" setting. </P>


<A NAME="push_context"></A>
<H3>Push/Pop Context</H3>

Some MVG primitives actually rely on the use of these transforms to be used
properly.  For example the <A HREF="#primitive_circle" >Ellipse Primitive</A>
can only be directly specified with orthogonally aligned axis.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "ellipse 50,30 30,15 0,360"   ellipse_orthogonal.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="ellipse_orthogonal.gif"
     ><IMG SRC="ellipse_orthogonal.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However by using <A HREF="#transform" >Drawing Transforms</A> we can easlly
add a 'angle of rotation' to the ellipse.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=ellipse_rotated.gif>
  magick -size 100x60 xc:skyblue -fill white -stroke black \
          -draw "push graphic-context
                 translate 50,30   rotate 30
                 fill white  stroke black
                 ellipse 0,0 30,15 0,360
                 pop graphic-context"       ellipse_rotated.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="ellipse_rotated.gif"
     ><IMG SRC="ellipse_rotated.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that 'center' of the ellipse (the point of rotation) was first
translated, before a rotation was applied.  The '<CODE>ellipse</CODE>'
was then drawn at that translated position at '<CODE>0,0</CODE>'. </P>

The above also shows two new MVG drawing primitives. '<CODE>push
graphic-context</CODE>' and  '<CODE>pop graphic-context</CODE>'.  This are not
strictly needed in the above example, but they are recommended when doing
major drawing transformations. </P>

What the '<CODE>push</CODE>' and '<CODE>pop</CODE>' primitives do is save the
current drawing state or 'graphic-context', then restore it again afterward.
Any drawing settings that are changed between the two primitives will be
forgotten.  That includes and surface warping, such as
'<CODE>translate</CODE>' and '<CODE>rotate</CODE>', as well as the color
settings '<CODE>fill</CODE>' and '<CODE>stroke</CODE>', or anything else that
modified the drawing 'state'.  </P>

These primitives make it easy to draw very complex objects with many
transformations, and then restore things back to a more 'normal' situation for
later drawing operations.  You can see a more practical demonstration of this
in <A HREF="#arrows" >Drawing Arrows</A> below. </P>

<A NAME="push_objects" ></A>
<H3>Push/Pop Special Objects</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV>

<PRE>
More settings used specifically for MVG handling of SVG format.

    font-family   font-stretch   font-style   font-weight
    encoding 'UTF-8'

    push defs

      push gradient 'def_name' linear X1,Y1 X2,Y2
        stop-color 'color' where
        stop-color 'color' where
          # where is a point between the two pixels given (0 = X1,Y1  1= X2,Y2)
        gradient-units 'objectBoundingBox|userSpaceOnUse'
        affine ....
      pop gradient

      push gradient 'def_name' radial CX,CY FX,FY R
        # Here CX,CY is the center of the radial gradient of radius R
        # the FX,FY is the focal, and is usually the same a CX,CY
        # unless you are trying to warp the gradient in a specific direction
        stop-color 'color' where
        ...
      pop gradient

    pop defs

    push graphic-context
      fill 'url(#def_name)'
      ... draw things here ...
    pop graphic-context

For examples see <I>Florent Monnier's</I> development site...
  <A HREF="http://www.linux-nantes.fr.eu.org/~fmonnier/OCaml/MVG/"
         >http://www.linux-nantes.fr.eu.org/~fmonnier/OCaml/MVG/</A>
</PRE>

<A NAME="reading">
<H3>Reading MVG Files</H3>
</A>

As you can see in the above examples the MVG "<A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" arguments can become very long.  In fact the conversion of
SVG to MVG can produce some extremely long MVG drawing arguments (see below).
</P>

However the general command line interface of IM allows you to read any string
argument from a file by using a "<CODE>@filename</CODE>" argument instead.
This is handy as it means you can read in your very long and complex MVG
drawing commands from a separate file. </P>

For example, If I put MVG operations into a file called
"<CODE>draw_circles.mvg</CODE>", I can then draw it like this...

<!-- <CODE EXECUTE SCRIPT IMAGE=mvg_circles.mvg TXT2GIF >
  ( echo "fill green   circle 41,39 44,57"
    echo "fill blue    circle 59,39 56,57"
    echo "fill red     circle 50,21 50,3"
  ) > mvg_circles.mvg
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="90%" ALIGN=center>
<TR><TD COLSPAN=2 width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:skyblue  -draw @mvg_circles.mvg  mvg_draw.gif
</samp></pre></TD></TR></TABLE></TD></TR>
<TR><TD ALIGN=right>
  <A HREF="mvg_circles.mvg"
     ><IMG SRC="mvg_circles.mvg.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD><TD ALIGN=left>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mvg_draw.gif"
     ><IMG SRC="mvg_draw.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Not only that but ImageMagick also understands reading "MVG:" image file
format directly allowing you to draw such commands more directly.  However
unless the MVG file defines a canvas, you may need to specify the initial
canvas ("<A HREF="../option_link.cgi?size" >-size</A></CODE>" and "<A
HREF="../option_link.cgi?background" >-background</A></CODE>") for it to draw
onto.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="90%" ALIGN=center>
<TR><TD COLSPAN=2 width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60  -background limegreen  mvg_circles.mvg  mvg_file.gif
</samp></pre></TD></TR></TABLE></TD></TR>
<TR><TD ALIGN=right>
  <A HREF="mvg_circles.mvg"
     ><IMG SRC="mvg_circles.mvg.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD><TD ALIGN=left>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mvg_file.gif"
     ><IMG SRC="mvg_file.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can move the initial canvas settings into the MVG image by adding a
'<CODE>viewbox</CODE>' to the MVG file, with appropriate background color fill
draws. That completes the MVG image file as a complete image definition.

<!-- <CODE EXECUTE SCRIPT IMAGE=mvg_circles2.mvg TXT2GIF >
  ( echo "viewbox 0 0 100 60"
    echo "fill khaki   rectangle 0,0 100 60"
    cat mvg_circles.mvg
  ) > mvg_circles2.mvg
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="90%" ALIGN=center>
<TR><TD COLSPAN=2 width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick   mvg_circles2.mvg    mvg_image.gif
</samp></pre></TD></TR></TABLE></TD></TR>
<TR><TD ALIGN=right>
  <A HREF="mvg_circles2.mvg"
     ><IMG SRC="mvg_circles2.mvg.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  </TD><TD ALIGN=left>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mvg_image.gif"
     ><IMG SRC="mvg_image.gif"          WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  There is currently only one way of reading an external MVG file from inside
  a MVG argument string, and that is using a '<CODE>image</CODE>' drawing
  primitive. Unfortunately this converts the MVG include into a raster image
  BEFORE overlaying that image onto the drawing surface. </P>

  In other words there is currently no MVG 'include' function.
  </I><CODE> :-( </CODE>
</FONT></TD></TR></TABLE></P>


<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<PRE>
You can generate the low level draw operations of IM, using the "<CODE><A
HREF="../option_link.cgi?render" >+render</A></CODE>" to record them. </P>

When you then give a "<CODE><A HREF="../option_link.cgi?render"
>-render</A></CODE>" setting/operator, IM will immediately draw those saved
operations. </P>

Strangely just outputting to a "MVG" file also seems to do this...
     magick ...   -draw '....'  draw_commands.mvg

NOTE: if you draw a curve while outputting a MVG format file, the file lists
the curve as a series of short line segments, rather than the original curve.

You can of course go the whole way and use the more universal SVG format.
See "<A HREF="#svg" >SVG format handling</A>" below.
</PRE>


<H3>MVG Alpha Composition</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV>

<PRE>
I have not seen any use of Alpha composition (other than 'painters' algorithm
which is basically a 'over' alpha composition) for the drawing of objects.

However that is not to say it can not be done.

If you like to compose your rectangle, ellipse, circle, or whatever with a
different alpha composition (such as 'DstOver' which is an Under-like
composition),  then draw your figure on a blank transparent canvas the same
size as the original and compose it onto your image.

However as SVG allows you to use alpha composition to draw text and other
items onto images, I would imagine that it will be a future addition.

Stay Tuned!
</PRE>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="symbols"></A>
<H2>Drawing Symbols</H2>

Sometimes you have a set of points on an image where you want to draw
reference symbols, like crosses, circles, etc... Unfortunately at this time IM
does not have commands to draw such symbols easily, but with a little bit of
extra work you can draw such symbols. </P>

<A NAME="symbol_drawing"></A>
<H3>Symbol Drawing Techniques</H3>

The trick to drawing multiple symbols in a given list of locations, is to
generate the MVG drawing commands using a shell script, or whatever API you
are using, so as to transform the given a set of points into the appropriate
set of drawing commands.  </P>

For example here I magick a line of points, into a 'plus' at each of
those points...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=points_plus.gif>
  # Define a string of X and Y coordinates
  # comma between values, space between coordinates.
  points="6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6"

  # magick each point into a draw command for a cross (using 'awk')
  # the 'tr' converts spaces into 'newlines' (one point per line).
  crosses=`echo $points | tr -s ' ' '\012' |\
     awk -F, '{ print "line " $1-3 "," $2 " " $1+3 "," $2 ;
                print "line " $1 "," $2-3 " " $1 "," $2+3 ; }' -`

  # draw a red line between the points, and blue crosses on the points.
  magick -size 100x100 xc:white \
          -draw "fill none stroke red   polyline $points " \
          -draw "fill none stroke blue  $crosses " \
          points_plus.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="points_plus.gif"
    ><IMG SRC="points_plus.gif"
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above uses "<CODE>tr</CODE>" to separate each point (two numbers) into one
point per line, then uses "<CODE>awk</CODE>" to do all the mathematical
calculations needed to draw the 'plus' over the given point.  You can use
anything you like for this as I am simply applying a form of text macro
expansion on the input point list.  Just about any programming language can do
this.  For the above shell script case I just found "<CODE>awk</CODE>" to be
the simplest and fastest means. </P>

Actually you can even use Imagemagick itself to do that 'macro' expansion using
the "<code>magick</code>" format option...  For example here I use it to
calculate a point on the circumference of the circle, for this 'point symbol'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=points_circle.gif>
  # Define a string of X and Y coordinates
  # comma between values, space between coordinates.
  points="6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6"

  # circle radius (or symbol size) to draw around each point.
  radius=3.5

  # magick each point into a draw command for a cross
  # In this case, points are space separated by the shell
  circles=$(for point in $points; do
             x=$(echo "$point" | cut -d, -f1)
             y=$(echo "$point" | cut -d, -f2)
             # use IM to do some floating point math, EG:  y2=$y+$radius
             y2=$(magick xc: -format '%[fx:'"$y"'+'"$radius"']' info:)
             echo "circle $x,$y $x,$y2"
           done)

  # Draw a red line between the points, and blue circles on the points.
  magick -size 100x100 xc:white \
          -draw "fill none stroke red   polyline $points " \
          -draw "fill none stroke blue  $circles " \
          points_circle.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="points_circle.gif"
    ><IMG SRC="points_circle.gif"
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now the draw strings you generate can get fairly long, and could start to
cause problems with the length of your final command.  So rather than
converting the points into long strings which we then pass to IM on the
command line, you can pipe draw commands to IM as a file instead. </P>

I also this time use a <A HREF="#paths" >SVG Path</A> drawing method instead
of the <A HREF="#primitives" >Draw Primitive</A> drawing methods. Also the
symbol I generate are triangles around each point. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=points_tri.gif>
  # Define a string of X and Y coordinates
  # comma between values, space between coordinates.
  points="6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6"

  # magick each point into a draw commands to draw a triangle
  for point in $points; do
     echo "path 'M $point  m 0,-5 -4,+8 +8,0 -4,-8'"
  done |\
    magick -size 100x100 xc:white \
          -fill none -stroke red  -draw "path 'M $points' " \
          -fill none -stroke blue -draw '@-' \
          points_tri.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="points_tri.gif"
    ><IMG SRC="points_tri.gif"
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The <A HREF="#paths" >SVG Path</A> actually makes this easier, by allowing
relative pixel moves, allowing you to design the symbol so it only requires
a single initial absolute move '<CODE>M</CODE>' before giving the sequence of
'moves' and 'lines' to draw the symbol.  Because of this you actually do not
need any floating point calculations at all, as IM draw will do the
positioning mathematics needed. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The relative move <A HREF="#paths" >SVG Path</A> item '<CODE>m</CODE>' is
  broken before IM v6.4.3-5.  If your IM is older than this, the above (and
  next) examples may not draw anything.  You can fix this for older versions
  by replacing the relative moves '<CODE>m</CODE>' in the above with an
  appropriate sequence of relative lines, '<CODE>l</CODE>'.
</I></FONT></TD></TR></TABLE></P>

Now you can take this even one step further, feed a fully formed MVG file,
complete with draw canvas specification, directly into IM as a pipeline of
drawing commands.  This time lets do a 'cross' which is similar to the
first 'plus' example above which needed a lot of calculations.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=points_cross.gif>
  # Define a string of X and Y coordinates
  # comma between values, space between coordinates.
  points="6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6"

  # Generate a MVG file for IM to draw all components
  ( echo "viewbox 0 0 100 100   fill white  rectangle 0,0 100 100"
    echo "fill none stroke red   path 'M $points'"
    echo "fill none stroke blue  path '"
    for point in $points; do
      echo "  M $point  m -2,-2 +4,+4  m -4,0 +4,-4"
    done
    echo "'"
  ) | magick mvg:- points_cross.gif
</samp></pre></TD></TR></TABLE></TD><TD>
    <A HREF="points_cross.gif"
      ><IMG SRC="points_cross.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This uses the special shell programming technique where anything and everything
that is 'echoed' within the shell parenthesis will be fed into the final
"<code>magick</code>" command as a MVG file.  The first 'echo' defines and
fills the drawing canvas for the image, while the 'while' loop converts each
'point' giving into a circle of the given radius. </P>

The advantage of this method is that you don't get any string limitation that
you may get using the other two methods.  </P>

Other symbols that you could generate include boxes, diamonds, error-bars,
etc... </P>

Also see '<A HREF="#circles" >Drawing Circles</A> below, for other circle
methods, including a no-calculate relative 'path' circle draw. </P>


<A NAME="symbol_alts"></A>
<H3>Alternatives to Drawing Symbols</H3>

There are other ways of adding symbols to images, other than directly drawing
them. </P>

<H4>Symbol Fonts</H4>

You can extract symbols from a <A HREF="../text/#symbol" >Symbol Font</A> and
save them as a small bitmap. You can also use small pre-defined but colorful
images for this too. </P>

However this may have trouble exactly positioning the font relative to
a specific pixel. That is to say it is not a very precise technique. But you
can compose any image at any pixel location.

For example these symbols were extracted from a number of fonts, for specific
use in these example pages.

<DIV ALIGN="center">
<IMG SRC="../img_www/left.gif" ALIGN=middle ALT="<=">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/right.gif" ALIGN=middle ALT="=>">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/multiply.gif" ALIGN=middle ALT="x">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/plus.gif" ALIGN=middle ALT="+">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/union.gif" ALIGN=middle ALT="+">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/intersection.gif" ALIGN=middle ALT="+">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=middle ALT="o">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/mph_thinning.gif" ALIGN=middle ALT="o">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/mph_dilate.gif" ALIGN=middle ALT="o">
<IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1 ALIGN=middle ALT=" ">
<IMG SRC="../img_www/fft_convolve.gif" ALIGN=middle ALT="o">
</DIV></P>

Examples of composting images onto a larger background are given in the
section on <A HREF="../layers/#composite" >Layering Images</A>.  However
a looped method may be more useful, such as given in <A
HREF="../layers/#layer_prog" >Programmed Positioning of Layered Images</A>.
</P>

<I>FUTURE: example of layering images using coordinates</I> </P>

<H4>Morphology</H4>

Another alternative is to use <A HREF="../morphology/#intro" >Morphology</A>,
to '<A HREF="../morphology/#dilate" >Dilate</A>' a single pixel, using special
'shape' kernels such as '<CODE><A HREF="../morphology/#disk" >Disk</A></CODE>'
and '<CODE><A HREF="../morphology/#ring" >Ring</A></CODE>' and '<CODE><A
HREF="../morphology/#plus" >Plus</A></CODE>', or even your own <A
HREF="../morphology/#user" >User Defined Kernel</A>. </P>

For example...
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:black -fill white \
          -draw 'point 20,15 point 55,30 point 40,60'  points_pixels.gif
  magick points_pixels.gif -morphology Dilate Ring    points_rings.gif
  magick points_pixels.gif -morphology Dilate Plus:4  points_pluses.gif
  magick points_pixels.gif -morphology Dilate Cross:3 points_crosses.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="points_pixels.gif"
     ><IMG SRC="points_pixels.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="points_rings.gif"
     ><IMG SRC="points_rings.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="points_pluses.gif"
     ><IMG SRC="points_pluses.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="points_crosses.gif"
     ><IMG SRC="points_crosses.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The result can then be converted directly into a colored overlay by using the
<A HREF="../masking/#alpha_shape" >Alpha Shape Operator</A>. </P>

The big advantage of this is that you don't actually need to know the
individual locations of each symbol. Or how many symbols there are. But that
can also be a disadvantage.  A major Disadvantage is that the positions are
only at integer locations.  You can not 'draw' using a floating point
'sub-pixel' positioning. </P>


<H4>Convolution</H4>

An almost identical technique is to use '<A HREF="../convolve/#convolve"
>Convolve</A>', with specially designed kernels, which allows you to set
various shades of gray, rather than just a simple on/off result, as above.
</P>

By using a different <A HREF="../morphology/#user" >User Defined Kernel</A>,
for each channel of the image (red, green, blue, and alpha), it is even
possible to create multi-colored symbol from each pixel coordinate. </P>

<A HREF="../images/marker.png"
   ><IMG SRC="../images/marker.png"            WIDTH=19 HEIGHT=30
         ALIGN=right VSPACE=0 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

For this I use a special script "<CODE><A HREF="../scripts/image2kernel"
>image2kernel</A></CODE>" I wrote to magick a colored image (see right) into
separate floating point convolution kernels for each of the channels.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE IMAGE=marker_R.dat>
  image2kernel -q marker.png marker.dat
</samp></pre></TD></TR></TABLE>
</DIV></P>

This generates four files, such as  "<CODE><A HREF="marker_R.dat"
>marker_R.dat</A></CODE>", one for each channel of the very small input image.
which are <A HREF="../morphology/#user" >User Defined</A> representations of
the image (with the origin centered in the image). </P>

Now using those kernel data files we can <A HREF="../convolve/#convolve"
>Convolve</A> those single points into our colorful marker image on
a transparent background.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick points_pixels.gif -alpha off \
          \( -clone 0 -morphology Convolve @marker_R.dat \) \
          \( -clone 0 -morphology Convolve @marker_G.dat \) \
          \( -clone 0 -morphology Convolve @marker_B.dat \) \
          \( -clone 0 -morphology Convolve @marker_A.dat \) \
          -delete 0 -channel RGBA -combine point_markers.png
</samp></pre></TD></TR></TABLE>
  <A HREF="points_pixels.gif"
     ><IMG SRC="points_pixels.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="point_markers.png"
     ><IMG SRC="point_markers.png"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.7.6-9 The <A HREF="../color_basics/#combine" >Combine
  Operator</A> requires the transparency channel of the image to be given as
  'opacity' values rather than alpha values, as such the resulting alpha channel
  created needs to be negated.  EG:

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  ... "`cat marker_A.dat`" -negate \) \
</samp></pre></TD></TR></TABLE>
</DIV></P>

</I></FONT></TD></TR></TABLE></P>

Only small images should be used, with the pixel points spread out enough that
the symbols do not overlap.  This because <A HREF="../convolve/#convolve"
>Convolve</A> will add together overlapping areas, making them brighter than
expected. </P>

The above has been converted into an UNIX shell script "<CODE><A
HREF="../scripts/convolve_image" >convolve_image</A></CODE>", to make it
easier to use. </P>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  convolve_image  points_pixels.gif marker.png   point_markers.png
</samp></pre></TD></TR></TABLE>
</DIV></P>

This technique came out of a discussion on the IM Forums <A
HREF="../forum_link.cgi?t=17259&p=64696" >A Fun Experience with IM</A>. The
user wanted to place tiny people, on a background image of a football field so
that their positions spell out a persons name, in the picture. </P>

<H4>Layered</H4>

A different technique such as <A HREF="../layers/" >Layers of Images</A>,
positioned using a list of the pixel that you extracted from the source image,
may be the better approach.  You can overlay more distant symbol images first,
before the foreground images, and you can programmically pick, or randomise,
what symbols replaces what point. </P>

For an example of this see <A HREF="../layers/#layer_pins" >Pins in a Map</A>.
</P>

<BR>

<A NAME="circles"></A>
<H3>Drawing Circles</H3>

The draw options provide you with a number of ways to do something very
basic... Drawing Circles. </P>

You can, for example, draw a circle though any point on its circumference.
Thus you will need to calculate a center point and a second point that is the
radius (say 25 pixels) away from the first point.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:  -stroke Firebrick  -fill tomato  -strokewidth 2 \
          -draw 'circle 50,30 50,55'    circle_circle.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_circle.gif"
     ><IMG SRC="circle_circle.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A> noted
that by using a translation you can remove the need to calculate the circles
edge coordinate, but can just give the radius directly.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=circle_circle_trans.gif>
  magick -size 100x60 xc:  -stroke SeaGreen  -fill PaleGreen  -strokewidth 2 \
          -draw 'translate 50,30 circle 0,0 25,0'    circle_circle_trans.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_circle_trans.gif"
     ><IMG SRC="circle_circle_trans.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However when drawing multiple circles the above will need either separate
"<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" operations for
each circle, or use <A HREF="#push_context" >Context Pushing</A>. </P>

Using an ellipse you can directly specify the radius as axis lengths

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:  -stroke Sienna  -fill Wheat  -strokewidth 2 \
          -draw 'ellipse 50,30 25,25 0,360'    circle_ellipse.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_ellipse.gif"
     ><IMG SRC="circle_ellipse.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also generate a circle by drawing a very very short line with
'<CODE>stroke-linecap round</CODE>'. The stroke width then sets the circles
diameter.  NOTE the line must have some length (no matter how small) or draw
will draw nothing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:  -stroke Blue  -strokewidth 50 \
          -draw 'stroke-linecap round line 50,30 50,30.0001' \
          circle_line.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_line.gif"
     ><IMG SRC="circle_line.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This technique, unfortunately can not outline the generated circle, but for
covering large areas, large stroke widths can be useful. See <A
HREF="#wide_strokes" >Some simple examples</A> below. </P>

This method makes use of the <A HREF="#paths" >SVG Path</A> drawing method
so that the circle can be drawn without needing to calculate any extra
coordinates.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x60 xc:  -stroke Blue  -fill DodgerBlue  -strokewidth 2 \
          -draw "path 'M 50,30  m 0,25  a 1,1 0 0,0 0,-50  a 1,1 0 1,0 0,50'" \
          circle_path.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_path.gif"
     ><IMG SRC="circle_path.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Only the initial absolute move '<CODE>M</CODE>' is needed to define the
center, the '<CODE>25</CODE>' and '<CODE>50</CODE>' in the rest of the path
components that follow define the circle radius and diameter relative to this
center.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The relative move <A HREF="#paths" >SVG Path</A> item '<CODE>m</CODE>' is
  broken before IM v6.4.3-5.  If your IM is older than this, the circle may
  only appear as a single pixel. You can fix this for older versions by
  replacing the '<CODE>m</CODE>' in the above with a '<CODE>l</CODE>'.
</I></FONT></TD></TR></TABLE></P>

<A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A> added the
following bezier circle method.  It is very close to a real circle (though not
exact), and requires a floating point calculation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=circle_bezier.gif>
  r=25;  cx=50;  cy=30;
  x1=25;     x2=75;      # = cx ± radius
  y1=-3.25;  y2=63.25;   # = cy ± radius*1.275
  magick -size 100x60 xc:  -stroke Purple  -fill Violet  -strokewidth 2 \
          -draw "bezier $x1,$cy $x1,$y1  $x2,$y1 $x2,$cy" \
          -draw "bezier $x1,$cy $x1,$y2  $x2,$y2 $x2,$cy" \
          circle_bezier.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_bezier.gif"
     ><IMG SRC="circle_bezier.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If drawing an exact circle is not important, you can use this 4 Bezier segment
SVG path, that only uses the X and Y bounds of the circle for its calculation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=circle_bezier_path.gif>
  r=25;  cx=50;  cy=30;
  x1=25;    x2=75;      # X bounds = cx ± radius
  y1=5;     y2=55;      # Y bounds = cy ± radius
  magick -size 100x60 xc:  -stroke Tomato  -fill Gold  -strokewidth 2 \
     -draw "path 'M $cx,$y1 Q $x1,$y1 $x1,$cy T $cx,$y2 $x2,$cy $cx,$y1 z'" \
     circle_bezier_path.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_bezier_path.gif"
     ><IMG SRC="circle_bezier_path.gif"        WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you like one that is drawn completely relative to a center starting point,
you can use this technique. Only the radius value is used, making it simple to
generate, using only string functions in an API.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=circle_bezier_path_rel.gif>
  magick -size 100x60 xc:  -stroke Orange  -fill LemonChiffon  -strokewidth 2 \
     -draw "path 'M 50,30  m 0,25  q 25,0 25,-25  t -25,-25  -25,25  25,25 z'"\
     circle_bezier_path_rel.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="circle_bezier_path_rel.gif"
     ><IMG SRC="circle_bezier_path_rel.gif"        WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Can you think of other ways to draw circles? </P>


<A NAME="arrows"></A>
<H3>Drawing Arrows
<FONT SIZE=-1>-- position, rotate and scale symbols</FONT></H3>

Using the above techniques you can create a special symbols such as an arrow
head, that you can position so its point is at the very end of a line, and
draw over it..  If you draw the arrow after the line (typical situation) then
the arrow will be drawn on top of the line. </P>

However their are three types of arrows, that can be defined, and each type
is defined in different ways depending on the use it is put to. </P>

<UL>
<LI><B>Measurement</B> where you simply want to mark the ends of a line
    with an arrow head to indicate the limits of a measurement in some
    engineering diagram.  Very simple. </P>

<LI><B>Vectors</B>, showing direction and intensity of some value.
<BR>For example in a weather wind chart. A tail is required and the 0,0 point
    is the end of the tail.  Often a large grid of such vectors is created.
    </P>

<LI><B>Indicators</B>, that point out some detail.
<BR>For this the 0,0 point probably should be either the tip, or some distance
    in front of the arrow itself.
</UL></P>

<H4>Measurement Arrows</H4>

Simply adding an arrow head to the end a line is relatively easy to do.  You
basically create a 'arrow head' <A HREF="#symbols" >symbol</A>, and draw it at
the right position. </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=arrow_horizontal.gif>
  arrow_head="l -15,-5  +5,+5  -5,+5  +15,-5 z"

  magick -size 100x60 xc: -draw 'line 10,30 80,30' \
          -draw "stroke blue fill skyblue
                 path 'M 80,30  $arrow_head' " \
          arrow_horizontal.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arrow_horizontal.gif"
     ><IMG SRC="arrow_horizontal.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I drew the symbol so that its starting point is the very end of the
line.  This way it can draw backward on top of the previously draw line,
making a very nice an neat symbol. </P>

Arrows however have a direction associated.  You could create a huge number of
arrow definitions at many different angles, and many programs do this.  But as
the arrow is a vector, so why not rotate the arrow as a vector.  The IM draw
command has drawing rotations (<A HREF="../draw/#transform" >Canvas
Warping</A>) built-in, so lets use them. </P>

This also has the advantage of moving the position out of the
'<CODE>path</CODE>' definition of the arrow head, allowing you to specify the
whole path as a 'constant'...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=arrow_rotate.gif>
  arrow_head="path 'M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z'"

  magick -size 100x60 xc: -draw 'line 25,55 70,10' \
          -draw "stroke blue fill skyblue
                 translate 70,10 rotate -45
                 $arrow_head
                " \
          arrow_rotate.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arrow_rotate.gif"
     ><IMG SRC="arrow_rotate.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you like to change the size of the arrow, add a "scale" draw option after
the rotate.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=arrow_scale.gif>
  arrow_head="path 'M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z'"

  magick -size 100x60 xc: -draw 'line 25,55 70,10' \
          -draw "stroke blue fill skyblue
                 translate 70,10 rotate -45 scale 2,2
                 $arrow_head
                " \
          arrow_scale.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arrow_scale.gif"
     ><IMG SRC="arrow_scale.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how it enlarged leaving the 'tip' of the arrow where you specify. This is
a very important aspect of handling arrows, as it is only the end point, and
angle of the line you are adding the arrow to that matters. </P>

The order of the 'transforms' is important, and really in reverse of the order
they are actually carred out.  That is scale is applied to coodinates first,
then rotate, and then translate.  If the coodinate transforms was not done in
that order, we would end up also scaling the final placement of the arrow, and
it would not be where we expect it to be. </P>

Also as the scale has two numbers, and the original arrow head symbol was
designed horizontally (angle zero), you can separately scale the width of the
arrow to its height. Also note how the stroke width also scaled with the size
of the arrow head, keeping things consistent.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=arrow_scale_aspect.gif>
  arrow_head="path 'M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z'"

  magick -size 100x60 xc: -draw 'line 25,55 70,10' \
          -draw "stroke blue fill skyblue
                 translate 70,10 rotate -45 scale 2,1
                 $arrow_head
                " \
          arrow_scale_aspect.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arrow_scale_aspect.gif"
     ><IMG SRC="arrow_scale_aspect.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Now as you are warping the canvas to draw individual arrows, perhaps with many
other drawing operations, you may like do them all in one "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" operation.  Say to draw the
line and then add arrows at BOTH ends, requiring different sets of colors,
positions, rotations, and may be even different scales.  That means we need to
limit the scope of the canvas warp to the drawing of each individual arrow
head. If you don't limit the scope you may start to effect other later drawing
operations later and can never be quite sure what you are generating. </P>

To limit the scope of the warp (and all other drawing attributes) you wrap the
section involved in a "<CODE>graphic-context</CODE>" ...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=arrow_context.gif>
  arrow_head="path 'M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z'"

  magick -size 100x60 xc: \
          -draw "stroke black fill none
                 path 'M 10,40 A 50,50 0 0,1 90,40'
                 push graphic-context
                   stroke blue fill skyblue
                   translate 10,40 rotate 135
                   $arrow_head
                 pop graphic-context
                 push graphic-context
                   stroke firebrick fill tomato
                   translate 90,40 rotate 45
                   $arrow_head
                 pop graphic-context
                " \
          arrow_context.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arrow_context.gif"
     ><IMG SRC="arrow_context.gif"              WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The '<CODE>push</CODE>' essentially saves all the current drawing attributes
away for future use, while the '<CODE>pop</CODE>' restores those attributes
replacing whatever settings (colors, warps, positions etc) with the previously
saved settings.   This means that after 'popping' the 'canvas warp' is
canceled, and draw is returned to the state it was in before things were
modified. </P>

The above technique is just one way of generating arrows, a good one when
drawing arrows as part of measuring distances, such as in technical drawings.
</P>

<H4>Vector Arrows</H4>

Vectors as mentioned show both direction and intensity of some value.
That means that the length of the arrow is variable, and the arrow head could
be at just about any position away from the vectors starting point. </P>

Now you could do some heavy math to calculate the position that the arrow head
should be places given the vectors length and angle, but their is a much
better way, which lets ImageMagick do those calculations for you. </P>

The solution is to draw the vectors length as a horizontal line of the right
length in the <A HREF="../draw/#transform" >Warped Canvas Space</A>.  When
that line has been draw, simply translate the drawing space again to the end
of the line while the canvas remains 'warped'.  You are now positioned
correctly, with the right rotation to draw the 'arrow head' of the vector as
normal. </P>

For example, here I generate a 70 pixel long vector at a -35 degree angle.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=arrow_with_tails.gif>
  vector_head="path 'M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z'"
  indicator="path 'M 10,0  l +15,+5  -5,-5  +5,-5  -15,+5  m +10,0 +20,0 '"

  magick -size 100x100 xc: \
          -draw "stroke black fill none  circle 20,50 23,50
                 push graphic-context
                   stroke blue fill skyblue
                   translate 20,50 rotate -35
                   line 0,0  70,0
                   translate 70,0
                   $vector_head
                 pop graphic-context
                 push graphic-context
                   stroke firebrick fill tomato
                   translate 20,50 rotate 40
                   $indicator
                   translate 40,0 rotate -40
                   stroke none fill firebrick
                   text 3,6 'Center'
                 pop graphic-context
                " \
          arrow_with_tails.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arrow_with_tails.gif"
     ><IMG SRC="arrow_with_tails.gif"              WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<H4>Indicator Arrows</H4>

In the above I also demonstrated an indicator arrow pointing to the start
point of the previous vector arrow. </P>

However instead of drawing the arrow like I did previously, I created it as
a reversed arrow symbol, that starts 10 pixels away from the origin (or start
point).  That is a symbol is located at position I want to indicate, so
I don't actually want the arrow directly on top of that position, but a litte
away from it. </P>

Now while indicators are simpler to handle than vectors, typically not needing
a variable length, you typically want to add text at the far end of the
indicator to specify what is being indicated.  As before it can be difficult
to calculate that position, so why bother.  </P>

The solution for positioning the text is also the same as for vectors.  Keep
the original warped space used to draw the indicator arrow, and translate the
origin to the tail end of that arrow (40 pixels horizontally in warped space).
Now that we have re-positioned things, we can un-rotate the warp around that
new position, so you can draw the text as normal (with a slight offset). </P>

Unfortunately while the default text justification of 'left' works in the
above, you can not currently specify a text justification in MVG, as
a separate setting to gravity.  If this is a problem put in a request on the
IM bugs forum, and hopefully text justification (as separate to gravity
positioning) will become a reality, especially as it is actually part of SVG
specification. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="objects"></A>
<H2>Drawing Objects</H2>

<A NAME="wide_strokes"></A>
<H3>Wide Strokes of Color</H3>

You don't have to completely enlose a fill area with a path or outline
to create various shapes.  Using very large and wide <A HREF="#stroke"
>Strokes</A> you can generate big areas and swatches of color on a canvas.
</P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example a broad stroke elliptical arc can generate a nice area of color
that I have actually seen used in creating a poster.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc: -fill none -stroke powderblue \
          -draw 'stroke-width 70 ellipse -30,0 90,90 10,50' \
          -rotate 180  arc_background.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="arc_background.gif"
     ><IMG SRC="arc_background.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or you can generate the rather complex smile of a clown.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick -size 100x100 xc: \
          -draw 'fill none stroke-linecap round
             stroke-width 40 stroke tomato ellipse 50,0 70,70 65,115
             stroke-width 2  stroke black  ellipse 50,0 70,70 60,120
             stroke-width 40 stroke palegreen line 50,40 50,40.01' clown.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="clown.gif"
     ><IMG SRC="clown.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<I>What can you come up with?</I> Let us know. </P>

<BR>

<A NAME="cylinders"></A>
<H3>Cylinders</H3>

In a <A HREF="../forum_link.cgi?t=17550" >IM Forum Discussion</A> there was
a heavy discussion on drawing cylinders, and specifically shaded cylinders,
using ImageMagick draw commands. </P>

The trick to cylinder drawing is to draw '<CODE>roundrectangle</CODE>'
primitives, in such a way that the ends form ovals.  That is if the cylinder
is say 50 pixels wide, you round the corners of the rectangle by 25 and 12
pixels respectivally. That is half the rectangle width, and then half again.
</P>

A cylinder thus becomes just two rounded rectangles drawn on top of each
other.  The second ligher colorfilled 'end oval' being sized to exactly double
that of both corner dimentions.   For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x100 xc:white -stroke snow4 \
          -fill chartreuse3    -draw 'roundrectangle 5,5 55,95 25,12' \
          -fill chartreuse2    -draw 'roundrectangle 5,5 55,29 25,12' \
          cylinder.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="cylinder.gif"
     ><IMG SRC="cylinder.gif"       WIDTH=60 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By replacing the first fill color with a gradient shade (using a <A
HREF="../canvas/#tile_memory" >In Memory Tiling technique</A>) you can make
the cylinder look a bit more 3d-like...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 60x100 xc:white -stroke snow4 \
          \( -size 1x60 gradient:chartreuse1-chartreuse4 -rotate -90 \
             -write mpr:shading +delete \) \
          -tile mpr:shading  -draw 'roundrectangle 5,5 55,95 25,12' +tile \
          -fill chartreuse2  -draw 'roundrectangle 5,5 55,29 25,12' \
          cylinder_shade.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="cylinder_shade.gif"
     ><IMG SRC="cylinder_shade.gif"       WIDTH=60 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


By slowly refining the cylinder drawing (as was discussed in the IM forum),
you can go a very long way to generating very complex and visually appealing
cylinders.  This included the addition of enclosing semi-transparent glass
cylinders, shadow effects, and labeling. </P>

The final result of that discussion is a script "<CODE><A
HREF="../scripts/cylinder_bar" >cylinder_bar</A></CODE>", generating
a cylinder percentage bar...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  cylinder_bar 95 cylinder_95.png
</samp></pre></TD></TR></TABLE>
  <A HREF="cylinder_95.png"
     ><IMG SRC="cylinder_95.png"            WIDTH=320 HEIGHT=200
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The script can generate an image of any size, adjusting all parameters
appropriatally basied on that size and other settings defined at the top of
the script.  In also includes the concept of a 'glass thickness', to create
a gap between an enclosing semi-transparent glass cylinder, and the colored
cylinder within. </P>

Note the very subtile shadings of the cylinder especially when the end of the
green cylinder overlaps the glass cylinder end!  It is amazing what you can do
with a little bit of fore-thought. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="text"></A>
<H2>Drawing Special Characters in the Text String</H2>

<A NAME="quote"></A>
<H3>To Quote or Backslash?</H3>

One of the biggest problem people have with -draw is the drawing of
characters that also have special significance to UNIX shells and the DOS
command line or even other languages like C, Perl, PHP, R, or Visual Basic.
</P>

The biggest culprit in this regard are the two types of quoting characters, as
well as variable substitutions characters like dollars '<CODE>$</CODE>' and
the shell and ImageMagick escape character, backslash '<CODE>\</CODE>'. </P>

Basically as the MVG argument to "<CODE><A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" needs to be quoted, <I>and</I> the '<CODE>text</CODE>'
string argument within also may need some extra quoting as well. </P>

To solve this, users typically use two different quote characters, one for the
shell and a different one for the MVG text string.

<DL><DD><CODE><B>
  -draw '... text 0,0 "string" ...'
</B></CODE></DL></P>

Note that this is the only real option for windows users, which has its own
quoting problems and methods. </P>

Alternatively they would swap the quotes, and use...

<DL><DD><PRE><B>
  -draw "... text 0,0 'string' ..."
</B></PRE></DL>

Which allows you to include shell variable substitutions (using
'<CODE>$</CODE>' without escaping. </P>

The selection of the right form will solve most problems, but some characters
still present difficulties, and each solution depend on exactly what set of
quotes you use, as they also define how special characters should be escaped.
</P>

Here are the four cases of quoting, and special character handling...

<UL>
<LI>Using Single Quotes for the shell argument,
<BR>with Double Quotes around the MVG text string.</P>

    The simplest technique for handling draw text strings is to use a single
    quote for the wrapping shell argument.  This however means that to include
    an apostrophe in the drawn string you need to leave the shells 'single
    quote mode' and supply that apostrophe outside the shells single quotes.
    </P>

    For example here is how to handle the four special characters I talked
    about.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 250x50 xc:none  -box white  -pointsize 20 -gravity center \
          -draw 'text 0,0 "  '\''  \"  $  \\  " ' \
          -trim +repage  text_special_sd.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="text_special_sd.gif"
     ><IMG SRC="text_special_sd.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

    Note that as the dollar sign is not needing escaping, you also can not use
    it to substitute the contents of a shell variable. </P>

    It is important to remember that the backslash is the <I>only</I> special
    character that the IM draw string handles. Also its reason for existence
    is purely to allow you to escape any 'IM draw string quotes', such as we
    used above for the double quotes.  Beyond this, all the other weirdness is
    caused by the UNIX command line shell, and not IM. </P>

    PC-DOS has its own weirdness, and I would appreciate input on escaping
    special characters when using IM from environment. </P>

<LI>Using Double Quotes for the shell argument,
<BR>with Single Quotes around the MVG text string.</P>

    If you do want want to insert a 'shell variable' into the drawn string,
    then you will have to use double quotes for the outside shell argument.
    This makes the whole matter much more complex, as you lose the protection
    of the shell and you now have to not only escape the dollar
    '<CODE>$</CODE>' signs, but also backslashes '<CODE>\</CODE>' as well.
    </P>

    On the other hand, the shell will not then need to use single quote
    characters as its end-of-argument de-limiting character, so that aspect is
    simplified.

    Lets summarize the results for our short list of special characters.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 250x50 xc:none  -box white  -pointsize 20 -gravity center \
          -draw "text 0,0 '  \\'  \"  \$  \\\\  ' " \
          -trim +repage  text_special_ds.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="text_special_ds.gif"
     ><IMG SRC="text_special_ds.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

    Notice that if you want to draw a backslash itself, the MVG text string
    needs the backslash to be doubled (as in the previous example), but the
    shell itself also needs each of those backslashes doubled, producing a
    total of four backslashes just to produce one such character. </P>

    This doubling can very quickly become overwhelming and confusing,
    requiring lots of backslashes to achieve what you want. Just take is slow
    and easy, and you will figure it out for your situation. </P>


<LI>Using Single Quotes for the shell argument,
<BR>with Single Quotes around the MVG text string. </P>

    Lets finish this off with a summary of the final two quoting combinations.
    I'll leave you to figure out how they are decoded by the shell and MVG.
    </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 250x50 xc:none  -box white  -pointsize 20 -gravity center \
          -draw 'text 0,0 '\''  \'\''  "  $  \\  '\'' ' \
          -trim +repage  text_special_ss.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="text_special_ss.gif"
     ><IMG SRC="text_special_ss.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<LI>Using Double Quotes for the shell argument,
<BR>with Double Quotes around the MVG text string. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 250x50 xc:none  -box white  -pointsize 20 -gravity center \
          -draw "text 0,0 \"  '  \\\"  \$  \\\\  \"" \
          -trim +repage  text_special_dd.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="text_special_dd.gif"
     ><IMG SRC="text_special_dd.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

</UL>

As you can see "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>"
arguments from the command line have to deal both with the command line shell
as well as backslash and quote escaping within the MVG text string.  The
results can be confusing and tricky.  Just remember that the shell treats the
two types of quotes differently, while the MVG text string does not. </P>

Of course in complex scripts, the better way may be to avoid the shell and any
scripting problems entirely.  You can do this by reading the "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" arguments from a MVG draw
file. </P>

<DL><DD><CODE><B>
  -draw @drawfile.mvg
</B></CODE></DD></DL>

Of course you will still need to backslash whatever quote character you are
using, as well as for any backslashes within the text.  However this is lot
simpler than trying to dealing with a shell own quoting and escaping system at
the same time as IM's.

<!-- <CODE EXECUTE SCRIPT IMAGE=text_quotes.mvg TXT2GIF >
  echo 'text 0,0  "Anthony'\''s Examples  --  '\''  \"  $  \\  "' \
     > text_quotes.mvg
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="90%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 500x50 xc:lightblue  -font Candice -pointsize 36 \
          -gravity center     -draw @text_quotes.mvg      text_quotes.gif
</samp></pre></TD></TR></TABLE>
</TD></TR><TR><TD ALIGN=left>
  <A HREF="text_quotes.mvg"
     ><IMG SRC="text_quotes.mvg.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=right>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
   <A HREF="text_quotes.gif"
      ><IMG SRC="text_quotes.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

The first image is from one of the "<CODE>MVG</CODE>" text files I used. It
contains no shell escapes or quoting.  As such only the MVG quoting and
escapes are present. </P>

Note that in the above if I had used single quotes for the MVG text string,
the only change is that I would need to backslash the single quote characters
rather than the double quote characters in the string. </P>


<A NAME="percent">
<B>About Percent Characters</B> </P>

Just one final point about special 'escape' characters in the  "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A> text</CODE>" operator.  Percent
characters '<CODE>%</CODE>' should draw 'as is'.  You should not need to do
anything special to draw them.  If they don't draw 'as is', then you have an
old version of IM and should upgrade ASAP. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
    Up until IM version 6.2.4, the '<CODE>%</CODE>' character was used as an
    escape character to include extra image information in the drawn text
    string.  This is no longer the case as such escapes were confusing and
    incorrect when SVG images also tried to draw percent characters.
</I></FONT></TD></TR></TABLE></P>


This use of percent 'escapes' (as well as '<CODE>\n</CODE>' newline escapes)
was deemed incompatible with the "<CODE><A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" operator, and MVG format's intended use for handling SVG
image formats.  As such from IM version 6.2.4 onward, % escapes do not work,
and backslashes only escape itself and the surround quotes.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    magick -size 250x50 xc:none -box white  -pointsize 20 -gravity center \
            -draw 'text 0,0 "%w\n%h"'    -trim +repage text_escapes.gif
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="text_escapes.gif"
      ><IMG SRC="text_escapes.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For more details of the 'percent bug', and ways to avoid it when using
"<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" in older
ImageMagick's, see the <A HREF="../bugs/draw_percent/" >Drawing a Percent
Bug</A> page. </P>


<A NAME="annotate">
<B>Annotate instead of Draw</B> </P>

The better way of avoiding these types of problems is to use "<CODE><A
HREF="../option_link.cgi?annotate" >-annotate</A></CODE>" rather than draw for
text drawing.  This operator is a wrapper around the draw operator and allows
the use of all the capabilities of draw, but in a simpler form. </P>

Basically this operator only need one set of quoting (for the shell).  This
makes dealing with special characters a much much simpler. </P>

Unfortunately while you no longer need to escape quotes for IM, you now have
<A HREF="../basics/#arg_percent" >Percent Escapes</A>, such as
'<CODE>@</CODE>' file reads, '<CODE>\n</CODE>' newlines, and other percent
escape expansions. </P>

For example, using single quotes...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    magick -size 200x50 xc:none  -box white  -pointsize 20 -gravity center \
            -annotate 0 '\@  '\''  "  $  \\  %% ' \
            -trim +repage  annotate_s.gif
</samp></pre></TD></TR></TABLE></TD><TD>
    <A HREF="annotate_s.gif"
      ><IMG SRC="annotate_s.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

and for double quotes...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    magick -size 200x50 xc:none -box white -pointsize 20 -gravity center \
            -annotate 0 "\@  '  \"  \$  \\\\  %% " \
            -trim +repage  annotate_d.gif
</samp></pre></TD></TR></TABLE></TD><TD>
    <A HREF="annotate_d.gif"
      ><IMG SRC="annotate_d.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However all annotation quotes and escapes are completely ignored if you use
the '<CODE>@</CODE>' escape to read the string from a file. </P>

For example here we include information on an images width and height!

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    magick -size 200x50 xc:none -box white -pointsize 20 -gravity center \
            -annotate 0 '%w\n%h' -trim +repage    annotate_percents.gif
</samp></pre></TD></TR></TABLE></TD><TD>
    <A HREF="annotate_percents.gif"
      ><IMG SRC="annotate_percents.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However all escapes are completely ignored when read an annotation string from
a file.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    echo -n '@ %w\n%h' |\
      magick -size 200x50 xc:none -box white -pointsize 20 -gravity center \
              -annotate 0 '@-'  -trim +repage  annotate_file.gif
</samp></pre></TD></TR></TABLE></TD><TD>
    <A HREF="annotate_file.gif"
      ><IMG SRC="annotate_file.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


For more information see <A HREF="../text/#annotate" >Annotate Text Drawing
Operator</A>, and especially <A HREF="../text/#escape_chars" >Annotate Escape
Characters</A>.  </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="svg"></A>
<H2>IM and SVG handling</H2>

<A NAME="svg_drivers"></A>
<H3>SVG Input Drivers: RSVG vs MSVG</H3>

Handling the actual SVG image format is a very complex business. The engine
needs to handle all its aspects, as defined by the <A
HREF="http://www.w3.org/TR/SVG/" >SVG -- Scalable Vector Graphics</A>
document.  Something that requires a lot of programming effort, and time. </P>

Therefore, ImageMagick provides two methods in the handling of SVG format
images. The first is to use an open source RSVG library, to magick the SVG
format into a raster image that IM has no problems handling.  This engine is
complete in just about all aspects of SVG handling. </P>

The second method is for IM to try to magick SVG into MVG, using a built-im
method called <B>MSVG</B>.  MSVG tries to magick a SVG image into the IM "<A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" operators "MVG" drawing
language.  A lot of the functionality of the draw MVG was created specifically
for this purpose. Unfortunatally while the basic line drawing and coloring is
present, it is far from being a complete SVG convertor. </P>

You can force the use of the internal MSVG converter by reading the SVG image
using using the special input format "<CODE>MSVG:</CODE>" (added IM v6.3.4).
But if the RSVG library is present most ImageMagick's will use it instead
to do render SVG images. </P>

To find out what your IM will do use...
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=svg_handling.txt>
  magick -list format | grep SVG
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="svg_handling.txt"
     ><IMG SRC="svg_handling.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see by the "<CODE>RSVG</CODE>" in parenthesis, my own IM will use
the RSVG library, with the version given, that is present on my computer. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR valign="top"><TD width="100%" ALIGN=justify>

Here I 'draw' a small, hand made, SVG image, "<A HREF="../images/diagonal.svg"
>diagonal.svg</A></CODE>" (contributed by the forum user <I><A
HREF="../forum_link.cgi?u=8538" >penciledin</A></I>), which creates
a rectangle with a simple diagonal gradient, on a white background.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick diagonal.svg  diagonal_rsvg.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="diagonal_rsvg.gif"
     ><IMG SRC="diagonal_rsvg.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Perfect. A proper diagonal gradient is produced. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR valign="top"><TD width="100%" ALIGN=justify>

However if you render this using the internal MSVG (the default if the RSVG
library is not present)...

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick msvg:diagonal.svg  diagonal_msvg.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="diagonal_msvg.gif"
     ><IMG SRC="diagonal_msvg.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!-- <CODE EXECUTE ASSERT>
  magick -list format | grep ' SVG\* ' | grep -q 'XML' && echo >&2 \
    "ASSERTION FAILURE: magick is using internal MSVG rather than RSVG\!"
  [ "`compare -metric PAE diagonal_*.gif null: 2>&1 |\
         sed 's/ .*//'`" -lt 40000 ] && echo >&2 \
    "ASSERTION FAILURE: MSVG and RSVG conversion library outputs are equal\!"
</CODE> -->

As you can see the internal MSVG conversion fails, returning a vertical
gradient rather than a diagonal one. </P>

You can also see the actual MVG commands IM generates by converting a SVG
directly into a MVG file.

<DIV ALIGN=center>
<!-- <CODE EXECUTE>
  txt2gif diagonal.svg
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="diagonal.svg.txt"
     ><IMG SRC="diagonal.svg.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE TXT2GIF>
  magick msvg:diagonal.svg diagonal.mvg
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="diagonal.mvg"
     ><IMG SRC="diagonal.mvg.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>
You can probably see how the MSVG convertor tried to magick SVG to MVG
drawing commands. </P>

Things the current internal MSVG is known to fail with include...
<UL>
<LI> Non-vertical Gradients  (no conversion to new MVG gradient handling)
<LI> Text along a curved path
<LI> Text justification (as separate to gravity)
</UL>

However most basic drawing actions are handled. </P>

Remember also that the MVG language can actually handle things that SVG can
not, including the use of gravity for positioning image and text.  Gravity is
not part of the the SVG specification, though it is an integral part of IM
text and font handling. </P>

Also remember that MVG does not have the same container mechanism that SVG has.
The internal MSVG converter replaces the XML containers with the pushing and
popping of graphic contexts (see the MVG output above), which has the same
effect. </P>


<A NAME="svg_settings"></A>
<H3>SVG settings</H3>

The SVG image format is a vector format (See <A HREF="../formats/#vector" >A
word about Vector Image formats</A>), and as such the image normally does not
have a default 'size'.  Instead it is 'drawn' or 'rendered' at a particular
"<CODE><A HREF="../option_link.cgi?density" >-density</A></CODE>" just like
postscript (default density is 72 dpi). </P>

Also if the SVG does not 'paint' the background, you can specify the
background color to use by using the "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" setting. </P>

For example here is another small SVG image "<CODE><A HREF="../images/home.svg"
>home.svg</A></CODE>", which has been 'rendered' using 3 different densities,
with 3 different backgrounds, including a transparent background.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -density 36                      home.svg  home_1.gif
  magick             -background skyblue home.svg  home_2.gif
  magick -density 144 -background none    home.svg  home_3.png
</samp></pre></TD></TR></TABLE>
  <A HREF="home_1.gif"
     ><IMG SRC="home_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="home_2.gif"
     ><IMG SRC="home_2.gif"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="home_3.png"
     ><IMG SRC="home_3.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note that I used a PNG format image for the larger transparent background
version of the above example. This produces a cleaner image than a GIF image
format would produce due to semi-transparent edge pixels.  PNG is always
recommended when transparency is involved in the final image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  I have found that some SVG images will not scale. That is they have been
  defined terms of 'pixels', rather than real-world lengths such as 'points',
  'inches' or 'millimeters'. As a consequence while the "<CODE><A
  HREF="../option_link.cgi?density" >-density</A></CODE>" setting may change
  the overall image size (in real-world units), the size of 'pixels' does not
  change, and so the image itself does not change size.  Such SVG images are
  however quite rare. </P>

  Worse still a few SVG image use a mix of 'pixel' and 'point' measurments,
  and unless the author did thid on purpose, you could get a real mess and you
  try to use it as a different density that what the author intended. These
  are fortunatally even rarer. </P>

  A simple fix is typically just change all 'pixels' units in the SVG to
  'points', but it should not be done blindly, in case the use of 'pixels'
  was used on purpose.

</I></FONT></TD></TR></TABLE></P>

<BR>

<A NAME="svg_output"></A>
<H2>SVG Output Handling</H2>

As of IM v6.4.2, IM can magick ANY bitmap image into an SVG vector graphic!
The conversion is not always successful, but larger and/or simpler images
(like a bitmap mask) will magick very well. </P>

For example here I magick a horrible bitmap shape into a SVG image, then
magick it back again, so as to smooth the bitmap into a proper anti-aliased
shape.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -pointsize 72 -font Candice label:A -threshold 50% \
          -trim +repage -bordercolor white -border 5x5 A.gif
  magick A.gif  A.svg
  magick A.svg  A.png
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5>
<TR><TD>
  <A HREF="A.gif"
     ><IMG SRC="A.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="A.svg"
     ><IMG SRC="A.svg.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</tt></TR></TABLE>
</TD><TD>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <A HREF="A.png"
     ><IMG SRC="A.png"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>
<!--<CODE EXECUTE>
  txt2gif -fmt A.svg
</CODE>-->

For this to work however the 'development' "<CODE><A
HREF="http://autotrace.sourceforge.net/" >AutoTrace</A></CODE>" library must
be installed, and IM configured with a "<CODE>--with-autotrace</CODE>" switch.
</P>

If the "<CODE><A HREF="http://autotrace.sourceforge.net/"
>AutoTrace</A></CODE>" library is not installed and compiled into IM, then the
SVG output generated will be a huge number of single pixel circles, generating
a binary result, rather than a smooth SVG outlined image. Such images are huge
by comparision, and often take a very long time to render by by SVG render.
</P>

A better default raster to vector technique, is actually needed. probably
using Morphology skeletion and MAT techniques. </P>


<!-- The delegate has vanished!

There is a "<CODE>autotrace:</CODE>' <A HREF="../files/#delegates" >input
delegate</A> command to do exactly what the last example did when reading in
a bitmap image, so as to smooth the resulting image in memory.  This does not
require IM to be compiled with the autotrace library, but only the
"<CODE>autotrace</CODE>" command to be present for it to work.

-->

There was an "<CODE>autotrace:</CODE>' <A HREF="../files/#delegates" >input
delegate</A>, to 'smooth input bitmap images', that did all the above steps in
one go using the "<CODE>autotrace</CODE>" command directly.  However the last
time I looked this delegate had vanished. </P>

This was how you would use it...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick autotrace:A.gif  A_traced.png
</samp></pre></TD></TR></TABLE></TD><TD>
   <A HREF="A_traced.png"
      ><IMG SRC="A_traced.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course this will NOT get you the SVG output from the
"<CODE>autotrace</CODE>" command, just filter the input image through SVG to
smooth it. </P>


An an alternative, you can actually use the "autotrace" command directly, as
shown in the examples <A HREF="../transform/#edge_vector" >Raster to Vector
Edging</A> and <A HREF="../morphology/#autotrace_skeleton" >Skeleton using
Autotrace</A>. </P>

You may also like to look at the results by <A
HREF="../forum_link.cgi?u=39994" >cancerberosgx</A>, at <A
HREF="../forum_link.cgi?p=167161" >Generating SVG Images</A> who looked at
solutions for converting photos. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="other"></A>
<H2> Non-IM Vector Graphic Editors</H2>

ImageMagick is a pixel array processor, It will generally not save vector
images ('MVG' is the only exception to this), only read them and magick them
to pixel arrays. </P>

The same is true of other pixel image editors, such as Gimp, Photoshop,
and so on. </P>

For editing and handling vector based images use programs such as
</P>

<TABLE>
<TR valign="top"><TD>Sodipodi&nbsp; <TD>
    SVG based Vector Graphics Editor
<TR valign="top"><TD>Xfig <TD>
    Simple, but very good, Vector Object Editor <BR>
    (Great for signs, maps, and arranging photos on a page)
<TR valign="top"><TD>Dia
<TR valign="top"><TD>AutoTrace <TD>
    Convert a shape in a bitmap array to vector outlines
<TR valign="top"><TD>Sketch <TD>
    Python based vector editor with curved text.
</TABLE></P>

This is of course not a complete list. Even many word processors, such as
OpenOffice, Word, and TeX, generally have various simple, though often
difficult to use, object editors. </P>

However for general converting a vector graphic format to a different vector
format, <B><I>do not use ImageMagick</I></B>.  ImageMagick is, and always will
be, essentially a raster image or bitmap graphics converter and manipulator.
For more information see <A HREF="../formats/#vector" >A word about Vector
Image formats</A>. </P>

</DIV></P>
<HR><!-- ---------------------------------------------------------------- -->
</div></main><footer class="magick-footer"><div class="container-fluid">
Created: 24 March 2004 <BR>
Updated: 14 March 2011 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://imagemagick.org/Usage/draw/</CODE>
</div></footer></body></HTML>

