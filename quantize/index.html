<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Quantization -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://imagemagick.org/Usage/quantize/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Color Quantization and Dithering</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#intro"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Color Reduction Introduction</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(what is involved)</FONT>
<DD><A HREF="#handling"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > The Colors in an Image</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(what colors are used by an image)</FONT>
    <UL>
    <LI><A HREF="#extract"  >Extracting Image Colors</A>
    <LI><A HREF="#compare"  >Comparing Two Colors</A>
    </UL>
<DD><A HREF="#colors"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Color Quantization</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(reducing the number of colors in an image)</FONT>
    <UL>
    <LI><A HREF="#colors"
        >The Color Quantization Operator</A>
    <LI><A HREF="#quantize"
        >Color Quantization and Colorspace</A>
    <LI><A HREF="#quantize_not_exact"
        >Quantization does not Preserve Colors</A>
    <LI><A HREF="#color_trans"
        >Color Quantization and Transparency</A>
    </UL>
<DD><A HREF="#dither_error"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Error Correction Dithering</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(Or Pseudo-Randomized Dithering)</FONT>
    <UL>
    <LI><A HREF="#dither"
        >E-Dither Methods</A>
    <LI><A HREF="#dither_how"
        >How an E-Dither Works</A>
    <LI><A HREF="#dither_sensitive"
        >E-Dither Change Sensitive</A>
    <LI><A HREF="#dither_speckle"
        >E-Dither Pixel Speckling</A>
    <LI><A HREF="#monochrome"
        >Monochrome Dithered Bitmap Images</A>
    <LI><A HREF="#two_color"
        >Two Color Quantization</A>
    <LI><A HREF="#remap"
        >Dither using Pre-Defined Color Maps</A>
    <LI><A HREF="#remap_common"
        >Common or 'Best' Colormap</A>
    <LI><A HREF="#web_safe"
        >Using Web-Safe Colors</A>
    <LI><A HREF="#remap_colormaps"
        >Uniform Color Maps</A>
    <LI><A HREF="#332_colormap"
        >Uniform 332 ColorMap</A>
    <LI><A HREF="#16bit_colormap"
        >TrueColor 16bit or 556 Colormap</A>
    <LI><A HREF="#gamma_colormap"
        >Gamma Corrected Uniform ColorMaps</A>
    <LI><A HREF="#posterize"
        >Posterize, Recolor Using an Uniform Color Map</A>
    </UL>
<DD><A HREF="#threshold"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Threshold Dithering Methods</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <UL>
    <LI><A HREF="#threshold"
        >Threshold Images</A>
    <LI><A HREF="#random-threshold"
        >Random Dither with Thresholding</A>
    </UL>
<DD><A HREF="#ordered-dither"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Ordered Pattern Dithers</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(Using a tiled threshold map)</FONT>
    <UL>
    <LI><A HREF="#diffused"
        >Diffused Pixel Dithering</A>
    <LI><A HREF="#halftone"
        >Digital Halftone Dithers</A>
    <LI><A HREF="#halftone_offset"
        >Halftone Offset Dithering</A>
    <LI><A HREF="#thresholds_xml"
        >XML Threshold Maps</A>
    <LI><A HREF="#od_posterize"
        >Ordered Dither with Uniform Color Levels</A>
    <LI><A HREF="#od_levels"
        >Better Ordered Dither Results</A>
    </UL>
<DD><A HREF="#diy_dither"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > DIY Dither Patterns and Threshold Maps</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(dither images in your own way)</FONT>
    <UL>
    <LI><A HREF="#diy_multi"
        >Multi-Image Bitmap Dither Patterns</A>
    <LI><A HREF="#diy_threshold"
        >DIY Ordered Dither Threshold Maps</A>
    <LI><A HREF="#diy_hlines"
        >DIY Horizontal Line Dither</A>
    <LI><A HREF="#diy_symbols"
        >Dithering with Symbol Patterns</A>
    </UL>
</DL>

Reducing the number of colors or replacing specific colors is a very complex
and difficult step in in Image Processing, and that is the topic covered in
this example pages. This includes determining the what colors to use (color
quantization), and how to place those colors on the image (dithering, and
patterning). It also includes the generation of bitmap or two color images,
and even handling Boolean (on/off) transparency. </P>

This is so important that color reduction or quantization often happens
automatically and behind the scene, just so ImageMagick can perform its
original primary task of converting images from one file format to another,
less colorful format, such as GIF, XPixmap, and XBitmap formats. Knowing how
this works can allow you greater control of the process, so as to improve the
resulting image stored in a specific image file formats. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="intro"></A>
<H2>Color Reduction Introduction</H2>

Color reduction is a very important aspect of ImageMagick.  For example to
magick a JPEG or PNG image containing millions of colors, into a GIF image
containing a maximum of 256 color, you really have to be able to reduce colors
in an efficient and effective way.  Often during an image format conversion,
this happens automatically behind the scenes, but there are other times when
you want to do this manually. </P>

Reducing the number of colors in image is a typically a three step process,
<OL>
<LI>First you typically need to survey the colors an image uses.  Not only to
    see how many colors are actually used, but how often a particular color is
    used.  It is no good preserving one specific color, if only a single pixel
    is using that color, though sometimes you still need to do that.
<LI>Next you need to somehow decide on the final color set to which you want
    to limit your image.  You may want IM to try and determine the 'best' set
    of colors for a specific image.  Other times you may want something more
    general and global that can be used on any image.  You may even want to
    specifically add or remove a color from the set of colors that will be
    used.
<LI>And finally you need to modify the image so as to only use the colors you
    have selected. Preferably you want it so the results will look good, or
    perhaps you want it so that it will compress, compare, or optimize well.
    </OL>

To further complicate matters, these steps are often interlinked, as one
method of replacing colors, often can only be applied using specific sets of
colors. And if you are using a specific set of colors, doing some sort of
color survey is not needed, or perhaps you need to make exceptions for
specific colors. </P>

Basically while color reduction is often automatically handled behind the
scenes, it is good to at least be aware just what it is happening, and what
its effects will be. </P>

<H4>Color Survey</H4>

This is probably the lest important, and while IM provides you with methods to
perform a survey, it is rarely done by users for the purposes of color
reduction.  I will leave further discussion to the relevant section, <A
HREF="#extract" >Extracting Image Colors</A>. </P>

<H4>Color Selection (Quantization)</H4>

For a good initial overview see <A
HREF="http://en.wikipedia.org/wiki/Color_quantization" >Wikipedia, Color
Quantization</A>. </P>

There are four basic methods for the selection colors. </P>

These four color control methods: <A HREF="#colors" >Quantization</A>, <A
HREF="#remap" >Predefined Color Map</A>, <A HREF="#posterize" >Uniform
Colors</A>, and <A HREF="#threshold" >Threshold</A>; all have their
limitations, as you will see.  </P>

Here is an example of each of these four methods...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png +dither    -colors 32          color_quantize.gif
  magick colorwheel.png +dither -remap colortable.gif  color_predefined.gif
  magick colorwheel.png +dither   -posterize 3         color_uniform.gif
  magick colorwheel.png \
                  -separate -threshold 50% -combine     color_threshold.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/colorwheel.png"
     ><IMG SRC="../images/colorwheel.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="color_quantize.gif"
     ><IMG SRC="color_quantize.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="color_predefined.gif"
     ><IMG SRC="color_predefined.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="color_uniform.gif"
     ><IMG SRC="color_uniform.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="color_threshold.gif"
     ><IMG SRC="color_threshold.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The number of colors in each of the final images is only a representative set,
but approximately 32 colors in each case (except for threshold which only has
8).  From this you can get an idea of what you can expect from each of them.
</P>

All the other methods have a fix set of colors (according to the operators
argument) regardless of the image that is being color reduced. </P>

Only the first method ("<CODE><A HREF="../option_link.cgi?colors"
>-colors</A></CODE>") will actually pick colors based on the current image
contents. As the test image is predominately white, a lot of lighter colors is
selected.  </P>

It surveys the colors in an image using a technique known as "Adaptive Spatial
Subdivision" using oct-trees.  Then attempts to choose a specific set of colors
to best match a specific image, within the limits given. See the <A
HREF="#colors" >Color Quantization Operator</A> below. </P>

The "<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>" lets you
give IM your own set of predefined colors (See <A HREF="#remap" >User Defined
Color Maps</A>). </P>

The color map "<CODE><A HREF="../images/colortable.gif" >colortable.gif</A></CODE>" used
in the above, is a set of 32 colors specifically picked for use in an old  <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/" >X Window Icon
Library</A> and is designed with cartoon like icons in mind.  (See <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/docs/colors.html" >AIcon
Library, X Icon Color Selection</A> for details). </P>

Using "<CODE><A HREF="../option_link.cgi?posterize" >-posterize</A></CODE>"
can also mathematically divide up each color channel into a set of color
levels or intensities producing a 'uniform color map'. That is a color map
with each channel set to a constant set of values or intensities. </P>

And finally can "<CODE><A HREF="../option_link.cgi?threshold"
>-threshold</A></CODE>" all or specific color channels of the image,
essentially making each color channel purely Boolean or on/off.  That is each
color channel can be given a value of zero or MaxRGB (IM 'Q' level dependant).
This however only produces a minimal set of about about 8 colors.  A very
limited color set. </P>

Threshold is also equivalent to a "<CODE><A
HREF="../option_link.cgi?posterize" >-posterize</A></CODE>" level '1' which
picks 2 colors. </P>


<H4>Applying a Color Set</H4>

Once you have a set of colors, the next problem is to apply the color to an
image so that the existing colors are replaced by the selected set of colors.
This is known as 'Dithering', and is named as such because of its, "should
I pick this, or should I pick that?", either-or nature. </P>

Basically the idea of dithering is to place pixels of different colors near
each other in such a way as to fool the eye into seeing more colors in the
image than is actually used. That is the color in that area of the image more
closely matches the original color of the image, because of the way the human
eye 'merges' neighbouring colors together. </P>

One of the best introductions to Dithering is on <A
HREF="http://en.wikipedia.org/wiki/Dither" >Wikipedia</A> though you will need
to skip over the 'Audio Dithering' section at the start.  This presents an
excellent set of examples of the benefits of using a dithered pattern of
pixels, when you have a limited set of colors. </P>

The basic styles of color replacement include...
<UL>
<LI>Direct Color Mapping (threshold, and posterization)
<LI>Random Dither (purely random placement of pixels)
<LI>Error Correction Dithers (pseudo-randomized patterns of pixels)
<LI>Ordered Diffused Pixel Dither (regular patterns of pixels)
<LI>Digital Halftoning (dots of different sizes)
</UL></P>

<B>Direct mapping</B> if the nearest color in a given set is what was shown
above.  Basically you get distinct areas of solid, unchanging colors.  When
this is applied to an image of slowing varying color, such as a real life photo
of sky, you get bands of colors across the image, especially in what would
otherwise be a smooth gradient of colors, such as in sky areas. The result is
typically regarded as not being very good.  </P>

The only time direct color mapping is usually thought of as acceptable is for
logos, symbols, icons, and cartoon-like images. It is actually rarely an
option. This is why you generally have to turn off the normal dithering
method, if you do not want directly map colors in your images. </P>

Dither however has its own problem.  Once an image is dithered, a pattern of
colors becomes part of the image.  Once such a pattern is present, it is
extremely difficult to remove.  Also it is generally a bad idea to re-apply
dithering to an image multiple times, as that just degrades the image. </P>

Because of this, most of the quantization examples below will generally show
you how to create un-dithered versions for each technique.  It is done that
way so you can see what color selections are being made before dithering hides
that information. </P>

<B>Random dithering</B> is the simplest dithering method created.  It is also
regarded as the worst possible dithering method.  However it has some special
uses.  Within IM only works with two colors, so it is usually restricted to
special case bitmap dithering. For more see <A HREF="#random-threshold"
>Random Dither with Threshold</A> below. </P>

<B>Error Correction Dithering</B> is generally regarded as being the best
general method of dithering colors across images as it will produce the
closest approximation to the original color of areas in the image. It is also
currently the only method that can dither <I>any</I> set of colors, and as
such can be used for all four color reduction techniques. See <A
HREF="#dither_how" >How E-Dithers work</A> below for more detail. </P>

However Error Correction Dithering has some serious <A
HREF="#dither_sensitive" >problems</A>, especially with regards to animations
of images. </P>

The last two dithering techniques <B>Ordered Diffused Pixel</B> and <B>Digital
Halftoning</B> is also regarded as a good method, and one that works well for
animations, but currently it cannot use any set of colors, only a fixed set of
uniform colors. </P>

It does provide a means of coloring an image using patterns, allowing you to
produce interesting effects otherwise not easy to produce.  </P>

<BR>

All these aspects of color reduction are important techniques, and with
understanding you can improve the results of your image operations, beyond the
generalised defaults that IM provides. It is well worth the studying. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="handling"></A>
<H2>The Colors in an Image</H2>

Information about images, such as the number of colors used and the overall
spread can be very important to programs and scripts that are trying to make
decisions about the best techniques to use.  Here I look at some of the
methods you can use to determine this type of information, and not just for
color reduction. </P>

<A NAME="extract"></A>
<H3>Extracting Image Colors</H3>

<H4>Extracting the color table</H4>

You extract a color palette from an image using a verbose "<CODE><A
HREF="../basics/#identify" >identify</A></CODE>", using any of these methods
which basically all does exactly the same thing.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  magick identify -verbose  image.png
  magick image.png miff:- | magick identify -verbose -
  magick image.png  -verbose -magick identify null:
  magick image.png  -verbose info:
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The output from any of the above verbose identification will not return
  the color tables or histogram if there are more than 1024 colors!  As such
  for large colorful images this is a hit or miss affair, and not
  recommended, though it can still be useful.
</I></FONT></TD></TR></TABLE></P>

The better way however is to generate a "<CODE><A HREF="../files/#histogram"
>histogram:</A></CODE>" of the image and extract the comment that is
included in the result.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
              <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=tree_histogram.txt>
  magick tree.gif  -format %c  -depth 8  histogram:info:-
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="../images/tree.gif"
      ><IMG SRC="../images/tree.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tree_histogram.txt"
      ><IMG SRC="tree_histogram.txt.gif"
            ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE>info:</CODE>" output format was added to IM v6.2.4.
  For IM versions before this use..
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=95% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  magick tree.gif histogram:- | magick identify -depth 8 -format %c -
</CODE></PRE></TD></TR></TABLE>
</DIV></P>
</I></FONT></TD></TR></TABLE>

The problem with these methods is that you are given a plain text output
of the colors, which you will need to parse for your own needs. </P>

However as of IM v6.2.8-8, the "<CODE><A HREF="../option_link.cgi?unique-colors"
>-unique-colors</A></CODE>" operator will magick an image into a smaller one
containing just one pixel per unique color found in the original image, all in
a single row. </P>

This means you can magick an image into a simpler color table image, listing
each color present.  The width of the image returns the number of colors, and
if you need to actually list the colors you can output it to a "<CODE><A
HREF="../files/#txt" >txt:</A></CODE>" image format. </P>

For example here is the color table for the tree image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=tree_colors.txt>
  magick tree.gif -unique-colors -scale 1000%  tree_colors.gif
  magick tree.gif -unique-colors -depth 16  txt:-
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tree_colors.gif"
     ><IMG SRC="tree_colors.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tree_colors.txt"
    ><IMG SRC="tree_colors.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

This reduced color table is also very important as a way of storing a colormap
of generated colors in a very small file.  Such maps are particularly
important for the "<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>"
color reduction operator. (See <A HREF="#remap" >Pre-Defined Color Maps</A>
below) </P>


If you like to get an image containing not just the colors in an image but
the color counts, here is one color-histogram solution what was developed from
a <A HREF="../forum_link.cgi?f=1&t=19538&p=76915" >IM Forum Discussion</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT OUT=unique_color_histogram.png>
  magick rose: -colors 256 -format %c histogram:info:- |
    sed 's/:.*#/ #/' |
      while read count color colorname; do
        magick -size 1x$count xc:$color miff:-
      done |
        magick - -alpha set -gravity south -background none +append \
                unique_color_histogram.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"        WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="unique_color_histogram.png"
     ><IMG SRC="unique_color_histogram.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that I had to <A HREF="#colors" >Color Reduce</A> the image, as the
built-in "<CODE>rose:</CODE>" image contains 3020 unique colors, which would
take a long time and generate a very long image. The GIF image of the rose
shown above contains the same set of color reduction. </P>

The resulting image still contains the same number of pixels, though padded
with extra transparent pixels, and as you can see shows a predominance of
greenish greys, strong reds, as well as a very strong peak of pure white. </P>

This may not be the best general color histogram method, but it works well for
this image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The order of the colors for both "<CODE><A HREF="../file/#histogram"
  >histogram:</A></CODE>" and "<CODE><A
  HREF="../option_link.cgi?unique-colors" >-unique-colors</A></CODE>"
  operator, is undefined, but appears to be sorted by red, then green, and
  finally blue channel value.  This may not the best way for a specific image,
  but it is impossible to generally sort 3-dimensional colors into
  a 1-dimensional order.
</I></FONT></TD></TR></TABLE></P>

<H4>Extracting the Average Color</H4>

The average color of an image can be found very quickly by using "<CODE><A
HREF="../option_link.cgi?scale" >-scale</A></CODE>" to reduce an image to a
single pixel.  Here for example is the average color of the built-in
"<CODE>rose:</CODE>" image.  I output the color using the <A
HREF="../transform/#fx_escapes" >FX Escape Format</A> which returns a color
string that can be used directly IM without change.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=rose_average.txt>
  magick rose: -scale 1x1\! -format '%[pixel:s]' info:-
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rose_average.txt"
    ><IMG SRC="rose_average.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The problem with using the "<CODE>%[pixel:...]</CODE>" <A
HREF="../transform/#fx_escapes" >FX Escape</A> is that it may return a color
name such as '<CODE>white</CODE>' or '<CODE>silver</CODE>' instead of a RGB
value. </P>

However you can simulate this by using three <A
HREF="../transform/#fx_escapes" >FX Escapes</A> to return the actual RGB
values at the bit depth wanted.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=rose_fx_rgb.txt>
  magick rose: -scale 1x1\! \
     -format '%[fx:int(255*r+.5)],%[fx:int(255*g+.5)],%[fx:int(255*b+.5)]' info:-
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rose_fx_rgb.txt"
    ><IMG SRC="rose_fx_rgb.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As of IM v6.3.9 there are a number of new  "<CODE><A
HREF="../option_link.cgi?format" >-format</A></CODE>" escapes that can be
useful to extract more specific information about images without needing to
parse a verbose "<CODE><A HREF="../basics/#identify" >identify</A></CODE>" or
"<CODE><A HREF="../files/#info" >info:</A></CODE>" output. </P>

For example you can get the average red channel colour by getting the
'<CODE>%[mean]</CODE>' greyscale value from  of the images, red channel image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=rose_red_mean.txt>
  magick rose: -channel R -separate -format '%[mean]' info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rose_red_mean.txt"
    ><IMG SRC="rose_red_mean.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<H4>Extracting a Specific Color</H4>

From the command line there are two basic ways of extracting a specific pixel
color from an image.  Either use an <A HREF="../transform/#fx_escapes" >FX
Escape</A> such as "<CODE>%[pixel:...]</CODE>" or "<CODE>%[fx:...]</CODE>"
(see above) on a specific pixel location...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=rose_pixel.txt>
  magick rose: -format '%[pixel:p{40,30}]' info:-
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rose_pixel.txt"
    ><IMG SRC="rose_pixel.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Alternatively you can simplify the image by using "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" to cut out a single pixel
that you may be interested in, and use any of the previous methods.  For
example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=rose_pixel_crop.txt>
  magick rose: -crop 1x1+40+30 -depth 8 txt:-
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rose_pixel_crop.txt"
    ><IMG SRC="rose_pixel_crop.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<H4>Counts of a Specific (or near) Color</H4>

This can be used to get the pixel count or percentage of a specific color.
</P>

What you do is make anything not that color black, and then make that color
white.  For example lets get the number of colors in the "<CODE>yellow</CODE>"
sun in the 'tree' image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=tree_sun_pixels.txt>
  magick tree.gif -fill black +opaque yellow \
                   -fill white -opaque yellow \
                   -print "yellow sun pixels = %[fx:w*h*mean]\n"   null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tree_sun_pixels.txt"
    ><IMG SRC="tree_sun_pixels.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

There is one cavat, it will not work if the color under test is itself black.
To handle black (or very dark colors) swap the fills to map non-black colors
to white and then <A HREF="../color_mods/#negate" >Negate</A> the results to
generate the white mask of all black pixels.  </P>

Remember the "<CODE><A HREF="../option_link.cgi?print" >-print</A></CODE>"
option is equivalent to using "<CODE>-format ... -write info:</CODE>" and can
be used anywhere within your image processing.  I then junked the unwanted
image using the special "<CODE><A HREF="../files/#null" >null:</A></CODE>"
file format.  You can also save the image to use as a mask for later work too.
</P>

Note that while this will work fine for small images, with much larger images
(like high resolution digital photos) the 'mean' will not be accurate enough
to get an exact pixel count!  Basically the above use of 'mean' is sutiable
for generating a ratio, but not for exact pixel counts.  To get an exact pixel
count you are better of using a histogram 'comment' output that has exact
pixel counts (see above).  </P>

The above can also used a <A HREF="../color_basics/#fuzz" >Fuzz Factor</A>
option "<CODE><A HREF="../option_link.cgi?fuzz" >-fuzz</A></CODE>" before the
"<CODE><A HREF="../option_link.cgi?opaque" >-opaque</A></CODE>" operator to
specify 'near' colors as well. </P>


<A NAME="compare"></A>
<H3>Comparing Two Colors</H3>

So you have two specific colors and you want to magick compare them.

You can use "<B><CODE>compare</CODE></B>" get the RMSE (on standard error)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=compare_navy.txt>
  magick compare -metric RMSE xc:Navy xc:blue null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="compare_navy.txt"
    ><IMG SRC="compare_navy.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

This is good as it will get you the distance between the two colors, both in
terms of values, and as a normalized percentage of the distance from black to
white. </P>

However this method will not handle transparency properly. For example
comparing 'fully-transparent black'  vs  'fully-transparent white'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=compare_transparency.txt>
  magick compare -metric RMSE xc:'#0000' xc:'#FFF0' null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="compare_transparency.txt"
    ><IMG SRC="compare_transparency.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Transparent colors should actually have a zero distance as fully transparent
is the same regardless of the underlying color.  Instead we got a 4-d
hypercube distance).  As such the above method of color distance is only
suitable for comparing fully-opaque colors only. </P>

<BR>

Rather than getting an actual distance, you can also use a <B><A
HREF="../color_basics/#fuzz" >Fuzz Factor</A></B> to check is two colors are
close. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=compare_blue-navy.txt>
  magick compare -fuzz 20% -metric AE xc:Navy xc:Blue null:
  magick compare -fuzz 30% -metric AE xc:Navy xc:Blue null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="compare_blue-navy.txt"
    ><IMG SRC="compare_blue-navy.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Remember however that the result will be '<CODE>1</CODE>' if the pixels do not
match (number of error pixels).

To get the actual 'fuzz' factor distance that separates the values you can use
the 'FUZZ' metric.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=compare_blue-navy_fuzz.txt>
  magick compare -metric FUZZ xc:Navy xc:Blue null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="compare_blue-navy_fuzz.txt"
    ><IMG SRC="compare_blue-navy_fuzz.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The 'normalized' value shows that the actual distance is 28.7%. </P>


Using <A HREF="../color_basics/#fuzz" >Fuzz Factor</A>, is different to
calculating the RMSE when transparency is involved. That is because the fuzz
factor is designed so that any two fully-transparent colors are treated as
being equal. </P>

As such 'fully-transparent black' and 'fully-transparent white' are exactly
equivelent (producing a value of 0 or no error pixels)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=compare_fuzz_trans.txt>
  magick compare -metric FUZZ xc:'#0000' xc:'#FFF0' null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="compare_fuzz_trans.txt"
    ><IMG SRC="compare_fuzz_trans.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Another method of color comparing is to try and <A
HREF="../color_basics/#replace" >Replace Colors</A> with an appropriate <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A> percentage. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=fuzz_navy.txt>
  magick xc:Navy  -fuzz 20% -fill Blue -opaque Blue txt:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="fuzz_navy.txt"
    ><IMG SRC="fuzz_navy.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV>

As '<CODE>Navy</CODE>' did not change to '<CODE>Blue</CODE>' it is more than
20% different to '<CODE>Blue</CODE>'. Where as

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=fuzz_navy2.txt>
  magick xc:Navy  -fuzz 30% -fill Blue -opaque Blue txt:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="fuzz_navy2.txt"
    ><IMG SRC="fuzz_navy2.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV>

This did change the color to '<CODE>Blue</CODE>', so we now no know that
'<CODE>Navy</CODE>' is somewhere between 20% and 30% distant from each other.
</P>

To do this in a script use something like...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  fuzz=%1
  color1="red"
  color2="#e00"

  color2=`magick xc:"$color2" -format '%[pixel:s]' info:`
  result=`magick xc:"$color1" -alpha set -channel RGBA -fuzz $fuzz \
            -fill $color2 -opaque $color2 -format '%[pixel:s]' info:`
  if [ "$result" = "$color2" ]; then
    echo "Colors match according to Fuzz Factor"
  else
    echo "Colors DO NOT match"
  fi
</CODE></PRE></TD></TR></TABLE>
</DIV> </P>

The special options "<CODE>-alpha set -channel RGBA</CODE>" are important to
allow us to for fuzzy matching of transparent and near transparent colors.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="colors"></A>
<H2>Color Quantization</H2>
<H3>Color Quantization Operator</H3>

The primary work horse of color quantization, and what is used internally for
all automatic color reduction, is the "<CODE><A
HREF="../option_link.cgi?colors" >-colors</A></CODE>" operator. </P>

This implements a "Adaptive Spatial Subdivision" color reduction algorithm,
and is an extremely good color reduction algorithm. </P>

Here is a typical example, I have an image of a 'colorwheel' image containing a
lot of colors, and we ask IM to reduce the number of colors down to only 64
colors, using various <A HREF="#dither" >dither methods</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png  -dither None       -colors 64  colors_64_no.gif
  magick colorwheel.png  -dither Riemersma  -colors 64  colors_64_rm.gif
  magick colorwheel.png  -dither FloydSteinberg \
                                             -colors 64  colors_64_fs.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/colorwheel.png"
     ><IMG SRC="../images/colorwheel.png"          WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colors_64_no.gif"
     ><IMG SRC="colors_64_no.gif"          WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_64_rm.gif"
     ><IMG SRC="colors_64_rm.gif"          WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_64_fs.gif"
     ><IMG SRC="colors_64_fs.gif"          WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

IM will by default use a 'dither' to shade the colors over the image.  This
prevents the sudden changes in color over smoothly changing gradients. </P>

If you turn off dithering (using '<CODE>None</CODE>' or a "<CODE><A
HREF="../option_link.cgi?dither" >+dither</A></CODE>" setting) you can clearly
see what colors were merged together to generate what IM regarded as the best
set of colors for this specific image. You can also see the sudden color
changes that gradients of color will produce if dithering was not done. </P>

Of course this image uses a lot more colors than what most images use. As such
while a 64 color limit is often acceptable for many images, it is completely
unacceptable for this image. In other words color quantization tries to find
the best set of colors for a particular image. </P>

Here are example of color quantization for part of IM logo, using an extremely
small number of colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo: -resize 40% -crop 100x100+105+50\! -normalize  logo.png
  magick logo.png  +dither             -colors 8  colors_8_no.gif
  magick logo.png  -dither Riemersma   -colors 8  colors_8_rm.gif
  magick logo.png  -dither FloydSteinberg \
                                        -colors 8  colors_8_fs.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo.png"
     ><IMG SRC="logo.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colors_8_no.gif"
     ><IMG SRC="colors_8_no.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_8_rm.gif"
     ><IMG SRC="colors_8_rm.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_8_fs.gif"
     ><IMG SRC="colors_8_fs.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Compare that with some results for the built-in "<CODE>rose:</CODE>" photo
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  +dither             -colors 16 colors_16_no.gif
  magick rose:  -dither Riemersma   -colors 16 colors_16_rm.gif
  magick rose:  -dither FloydSteinberg \
                                     -colors 16 colors_16_fs.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"        WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colors_16_no.gif"
     ><IMG SRC="colors_16_no.gif"        WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_16_rm.gif"
     ><IMG SRC="colors_16_rm.gif"        WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_16_fs.gif"
     ><IMG SRC="colors_16_fs.gif"        WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see cartoon-like images require far less colors than a real
photograph to produce a reasonable result.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Only one Color Quantization algorithm, "Adaptive Spatial Subdivision", is
  currently implemented in IM, and as it works very well, there has been
  little need to add others. However with feedback this algorithm is being
  steadily improved. </P>

  ASIDE: As a reference the "<CODE><A HREF="http://www.lcdf.org/gifsicle/"
  >Gifsicle</A></CODE>" program lists a number of other color quantization
  methods (using it "<CODE>--color-method</CODE>" option). I have no idea as
  to how well these color quantization methods magick compare to IM.  If you find a
  good reference to different methods of color quantization, please mail me.

</I></FONT></TD></TR></TABLE></P>

<!-- <CODE EXECUTE ASSERT>
  colors=256   # number of colors for test

  generate=`magick -size 100x$colors gradient:blue-red -format %k info:`
  # magick -size 100x$colors gradient:blue-red -format '%c' histogram:info:

  quantize=`magick -size 100x$colors gradient:blue-red +dither \
            -colors $colors -format %k info:`
  dither_rm=`magick -size 100x$colors gradient:blue-red \
             -dither Riemersma -colors $colors -format %k info:`
  dither_fs=`magick -size 100x$colors gradient:blue-red \
             -dither FloydSteinberg -colors $colors -format %k info:`

  if [ "$dither_rm" -ne "$colors" ] ||
     [ "$dither_fs" -ne "$colors" ]; then
    cat >&2 <<EOF
ASSERTION FAILURE: Quantization OR Dither reduced colors when not needed
  number of colors = $colors   colors
     => generate     `printf %3d $generate`  (from gradient:)
     => quantization `printf %3d $quantize`  (+dither -colors $colors)
     => dithering R  `printf %3d $dither_rm` (-dither Riemersma)
     => dithering FS `printf %3d $dither_fs` (-dither FloydSteinberg)
EOF
  fi
</CODE> -->

<A NAME="internals"></A>
<H3>Color Quantization Internals</H3>

The process of selecting the limited number of colors to use in an image is
called Color Quantization, and is a very complex process involving a number of
factors. A full technical description of it is given on the ImageMagick web
site <A HREF="https://imagemagick.org/script/quantize.php" >Color
Reduction Algorithm</A>. However I'll try to example some of the more
important aspects of this here. </P>

Probably the biggest factor is the actual colors used in an image.  It is no
good picking a particular color for an image if their are very few pixels that
are 'close' to that color.  As such the color choice depends not only on the
colors used in an image, but the number of pixels 'close' to the color.  </P>

I can demonstrate this quite easily by trying to reduce two different two
color images to a single common color.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 4x1 xc:blue -draw 'fill red   point 0,0' \
                                                -scale 20 colors_rb.gif
  magick -size 4x1 xc:red   -draw 'fill blue point 3,0' \
                                                -scale 20 colors_br.gif
  magick colors_rb.gif  -colors 1  colors_rb2.gif
  magick colors_br.gif  -colors 1  colors_br2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="colors_rb.gif"
     ><IMG SRC="colors_rb.gif"    WIDTH=80 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colors_rb2.gif"
     ><IMG SRC="colors_rb2.gif"    WIDTH=80 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="colors_br.gif"
     ><IMG SRC="colors_br.gif"    WIDTH=80 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colors_br2.gif"
     ><IMG SRC="colors_br2.gif"    WIDTH=80 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the single final color depends not only on the colors present,
but the amount of each color in the image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 20x640  gradient: -rotate 90  gradient.png
  magick gradient.png   +dither  -colors 5   colors_gradient.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="colors_gradient.gif"
     ><IMG SRC="colors_gradient.gif"    WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the color quantization is uniform, within the current colorspace.
</P>

<PRE>FUTURE: Just what are the effects of the "<CODE><A
HREF="../option_link.cgi?treedepth" >-treedepth</A></CODE>"  setting?
Mail me if you know</PRE>


<A NAME="quantize"></A>
<H3>Color Quantization and ColorSpace</H3>

The other big influence on what colors are selected is defining exactly what we
mean by colors that are 'close' or 'nearby'.  This is defined by the
colorspace used for the quantization (color selection), and is (as of IM
v6.2.8-6) controlled by the "<CODE><A HREF="../option_link.cgi?quantize"
>-quantize</A></CODE>" colorspace setting. </P>

The "<CODE><A HREF="../option_link.cgi?quantize" >-quantize</A></CODE>" setting
becomes particularly important when a very small number of colors are chosen.
To demonstrate, lets reduce a standard '<A HREF="../images/colorwheel.png"
>colorwheel</A>' image using various different color spaces and defining
different 'color distances'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE>
  for S in    RGB CMY sRGB GRAY \
              XYZ LAB LUV  \
              HSL HSB HWB  \
              YIQ YUV OHTA ; do \
     magick colorwheel.png   -quantize $S   +dither -colors 16 \
             -fill black -gravity SouthWest -annotate +2+2 $S \
             colors_space_$S.gif; \
  done
</CODE></PRE></TD></TR></TABLE>
  <A HREF="colors_space_sRGB.gif"
     ><IMG SRC="colors_space_sRGB.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_CMY.gif"
     ><IMG SRC="colors_space_CMY.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_RGB.gif"
     ><IMG SRC="colors_space_RGB.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_GRAY.gif"
     ><IMG SRC="colors_space_GRAY.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="colors_space_XYZ.gif"
     ><IMG SRC="colors_space_XYZ.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_LAB.gif"
     ><IMG SRC="colors_space_LAB.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_LUV.gif"
     ><IMG SRC="colors_space_LUV.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="colors_space_HSL.gif"
     ><IMG SRC="colors_space_HSL.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_HSB.gif"
     ><IMG SRC="colors_space_HSB.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_HWB.gif"
     ><IMG SRC="colors_space_HWB.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="colors_space_YIQ.gif"
     ><IMG SRC="colors_space_YIQ.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_YUV.gif"
     ><IMG SRC="colors_space_YUV.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_space_OHTA.gif"
     ><IMG SRC="colors_space_OHTA.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the colors chosen depend heavily on how the colorspace is
organized.  The sRGB (Red, Green, Blue) color cube will generally result in at
least the colors close to the primary color being picked. </P>

The sRGB color space is particularly good at picking colors for cartoon like
images and icons, but is actually a bad color space for general picture-like
photos. </P>

The CMY color space is exactly the same as sRGB color space as the color
channels are simply negated to magick between sRGB and CMY colorspaces.  As
such the quantization colors end up with roughly the same solution.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The CMYK colorspace (not shown) also produces the same but for different
  reasons. Because internal the 'K' channel and an images 'colormap' use the
  same data pointer (See <A HREF="../basics/#palette" >Palette Channel</A>),
  IM converts it back to CMY before quantization.  </P>

</I></FONT></TD></TR></TABLE></P>

The sRGB colorspace as expected produces a simular result as RGB, but is
warped to remove the number of near-black colors in the colorspace.  As such
there is less colors for the center of the colorwheel to select from,
producing a larger 'not quite so black' spot.  </P>

The XYZ colorspace is also very very similar to linear RGB colorspace.
The big difference here is that the color axis has shifted so as to better
contain ALL the posible colors we can (and even colors we normally cannot)
see,  as such the color data in the colorwheel are compressed a bit more, and
as a result the quantizations seems to become spread out more. </P>

The LAB and LUV color spaces are based on a different but simular color axis
to each other. That results a different arrangement of color quantizations.
</P>

The special color spaces involving a 'Hue' channel, such as HSL (Hue
Saturation, Lightness), HSL (Hue, Saturation, Brightness), and HWB (Hue,
White, Black), all have a cyclic color wheel representation of color as part
of its color space.  Actually it was using a HSL color space what was used to
generate this color wheel.  See  <A HREF="../color_basics/#colorwheel"
>Generating a Colorwheel</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  At the time of writing, the color distance algorithm IM uses does not take
  into account the cyclic nature of the 'Hue' of the colorspace. The algorithm
  for this is very different.  Because of this a strong discontinuity occurs
  along the 'red' path, where the 'Hue' wraps around, and results in
  very few red colors being selected in the color quantization process.
</I></FONT></TD></TR></TABLE></P>

The YIQ, YUV are designed to produce more natural 'pastel' and 'mid-tone'
shades of colors that are much better suited for photographs and images of the
real world involving subtle shades of colors, and especially skin tones. </P>

Helmut Dersch notes on <A
HREf="http://www.all-in-one.ee/~dersch/barrel/barrel.html" >his web site</A>
that you should consider using a LAB colorspace for distortions. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  In older versions of IM (specifically IM version 5) the color space that
  was used for quantization was set with the "<CODE><A
  HREF="../option_link.cgi?colorspace" >-colorspace</A></CODE>" option.
  However in IM version 6 this operator is used for modifying how images are
  stored in memory, and as such is not a setting for color quantization.
  </P>

  As such in IM v6.2.8-6, the "<CODE><A HREF="../option_link.cgi?quantize"
  >-quantize</A></CODE>" setting was provided to do this job.  However it is
  only as setting for the "<CODE><A HREF="../option_link.cgi?colors"
  >-colors</A></CODE>", Color Quantization process.  It will not do anything
  for the replacement and dithering of colors using operators such as
  "<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>" and "<CODE><A
  HREF="../option_link.cgi?posterize" >-posterize</A></CODE>", or the various
  dithering techniques.
</I></FONT></TD></TR></TABLE></P>

For a complete list of the colorspaces available see the "<CODE><A
HREF="../option_link.cgi?colorspace" >-colorspace</A></CODE>" operator. </P>

You can see more effects of the colorspace on color selection by looking at
the examples on <A HREF="../misc/#spots" >Random Spots of Solid Color</A>.
There color quantization is used to reduce the number of colors in a
randomized image using various colorspaces. </P>


<A NAME="quantize_not_exact">
<H3>Quantization does <B>NOT</B> Preserve Colors</H3>

Note that in all the above images a pure-black color is never actually picked
by Color Quantization.  Mind you their is only one pure black pixel, and not
many near-black colors in the image in any case.  As a result the only black
that appears in the final image was added later as part of the labeling of the
image. </P>

Even the '<CODE>GRAY</CODE>' color space image did not produce a pure-black
color.  In fact none of the images contains any of the primary or secondary
colors, such as: red, blue, green, cyan, magenta!  The only exception to this
is white, as the images did contain quite an amount of pure white color,
making it a 'preferred color' (see below). </P>

This situation however is not a bug! </P>

First, a '<CODE>black</CODE>' color was generally not selected in the above
examples, usually because as their is very little black in the original image,
so the Color Quantization generally did not worry too much about dark colors.
In fact it generated more of the lighter colors as these are more common in
the image. See the previous section for a specific example.  </P>

Secondly, as quantization is trying to pick colors that are close to the
maximum number of existing color pixels in an image,  this is best achieved by
NOT matching a 'pure' primary or secondary color as these are the always at
the very extremes of the color space being used. An 'off-color' will tend to
match more colors than a 'primary' color, so these are more often selected.
</P>

So let me be clear...
<DIV ALIGN=center><B>
     Color Quantization ("<CODE><A HREF="../option_link.cgi?colors"
         >-colors</A></CODE>") will generally avoid picking primary colors!
</B></DIV></P>

As of IM version 6.3 the Color Quantization function was modified to try to
include colors that are very common in the original image. As such if an image
contains an area of a single color (such as '<CODE>white</CODE>' in the above),
that color will generally be included in the final color map. </P>

This improves the situation somewhat, especially for 'cartoon' like images or
images on a solid color background.  The 'solid' color will generally be
picked so as to help avoid <A HREF="#dither_speckle" >Dither Speckling</A>
which we will look at below. </P>


<B>Specific Color in Colormap Solutions</B></P>

At the moment there is only a few ways to guarantee a 'specific color' gets
included into the selected colors for later dithering. </P>

One way is to quantize the image as normal, but then output the generated
color map (using "<CODE><A HREF="../option_link.cgi?unique-colors"
>-unique-colors</A></CODE>").  Now you can adjust that color map so your
specific color is really that color.  Finally you can use the <A HREF="#remap"
>Remap Colors</A> operator to dither the image using the provided color map.
</P>

The colormap may no longer be the BEST colors for the image, and some other
colors probably should also be adjusted, but it will be close to the colormap
that you wanted. </P>

Alternatively, append (enlarging the image) large patches of the specific
colors wanted to be preserved in the image, before using "<CODE><A
HREF="../option_link.cgi?colors" >-colors</A></CODE>".  The addition of the
large 'swatch' of a specific color, will make that color more likely to be
picked in the final color map. Also all the other colors will then
automatically be adjusted to fit that color map better). </P>

If this works, the swatches of colors you added should remain unchanged (not
dithered). Afterwards you can then <A HREF="../crop/#crop" >Crop</A> the image
to remove the added swatches.  If it doesn't work, then IM should have at
least added a color close to the wanted 'specific color' so only a slight
adjustment of the generated colormap needed before using <A HREF="#remap"
>Remap Colors</A> to the original image.  </P>

<I>If you try this, regardless of success or failure, please let me know how
it went for you.</I></P>

Ideally, what I would like to see a way to specify a small
number of specific colors, that must be part of the final color map, and then
somehow ask IM to pick the best colors for rest of the colors in the color
map, for a specific image. </P>


<A NAME="color_trans"></A>
<H3>Color Quantization and Transparency</H3>

ImageMagick by default not only generates fully opaque colors, but also
attempts to generate semi-transparent colors. In this way, images containing
transparent shadows or other overlay effects will not loose those effects.
</P>

However as IM v6.2.6, color quantization that involves transparency was
modified so as to treat all fully-transparent colors as being the same color.
This is a linear modification, so colors which are only half-transparent are
also thought to be closer together than if they were fully opaque. </P>

Because of this modification IM Color Quantization will still generate
semi-transparent colors, but will concentrate more on the opaque colors
and less on the fully transparent colors in the image. </P>

For example here I generate a <A HREF="../canvas/#gradient_colorspace"
>Rainbow Gradient</A> of colors, with the image fully-opaque at the top, and
fully-transparent at the top.  I have displayed the images on a background
pattern so that you can see just how transparent the image is.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick xc:red xc:yellow xc:green1 xc:cyan xc:blue \
          +append -filter Cubic -resize 100x100\!  -size 100x100 \
          gradient: +matte -compose CopyOpacity -magick composite alpha_gradient.png
  magick alpha_gradient.png  +dither  -colors 256  alpha_colors_256.png
  magick alpha_gradient.png  +dither  -colors 64   alpha_colors_64.png
  magick alpha_gradient.png  +dither  -colors 15   alpha_colors_15.png
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=1 WIDTH=80% CELLPADDING=10 BACKGROUND="../images/bg.gif"><TR>
<TD ALIGN=center>
  <A HREF="alpha_gradient.png"
     ><IMG SRC="alpha_gradient.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="alpha_colors_256.png"
     ><IMG SRC="alpha_colors_256.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_colors_64.png"
     ><IMG SRC="alpha_colors_64.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_colors_15.png"
     ><IMG SRC="alpha_colors_15.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see, when we ask IM to reduce the number of colors needed by this
image, it created a lot more opaque colors and used fewer highly transparent
colors for the more translucent parts.  The result is a very good spread of
colors selected, especially when the number of colors is very small. </P>

However just as I pointed out above, not only do <A HREF="#quantize_not_exact"
>primary colors not get picked</A>, but the fully-transparent color will also
not get picked for exactly the same reasons. In actual fact even fully-opaque
colors will not get picked!  In other words every color in the color quantized
images in the previous example is semi-transparent. </P>

Let me just make that clear.
<DIV ALIGN=center><B>
           When transparency is involved, IM Color Quantization
<BR> may not select any fully-opaque or even a fully-transparent color!
</B></DIV></P>

Of course as of IM v6.3, and the 'common color' bug fix (see <A
HREF="#quantize_not_exact" >Quantization does NOT Preserve Colors</A> above),
that is less likely to happen if the image contains a lot of opaque and
fully-transparent colors, which is commonly the case. </P>

As some images can contain a lot of semi-transparent colors, such as images
involving smoke or shadows effects, you may like to do a trial run, to make
sure a fully-transparent color is selected for inclusion in the resulting
image.  You can then map the most-transparent color to fully-transparent,
and do the <A HREF="#remap" >Remap Colors</A> yourself. </P>

If you really want to be sure you get both fully-opaque and fully-transparent
colors in the resulting image you can <A HREF="../color_mods/#normalize"
>Normalize OR Contrast-Stretch</A> the alpha channel. </P>

For example here I ensure the main color selects are made opaque by using
"<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>".  Though this is probably a little heavy handed
for a more normal situation.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick alpha_gradient.png  +dither  -colors 15 \
          -channel A -contrast-stretch 10%  alpha_colors_15n.png
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=1 WIDTH=80% CELLPADDING=10 BACKGROUND="../images/bg.gif"><TR>
<TD ALIGN=center>
  <A HREF="alpha_gradient.png"
     ><IMG SRC="alpha_gradient.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="alpha_colors_15.png"
     ><IMG SRC="alpha_colors_15.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="alpha_colors_15n.png"
     ><IMG SRC="alpha_colors_15n.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

This is NOT a problem for GIF images which do not allow semi-transparent
colors, or JPG which does not allow transparency, or even PNG which do not
need quantization to save properly.  It only becomes a problem in special
cases where you may force a color reduction in an image when lots of
semi-transparent colors are involved.  </P>

Remember for the GIF format saving semi-transparent colors is an useless
endeavor.  As such if you plan to do color quantization yourself for such an
image format, you need to tell IM to ignore image transparency when generating
its reduced color set.  you can do that by using the special "<CODE><A
HREF="../option_link.cgi?quantize" >-quantize</A></CODE>" color space setting of
'<CODE>transparent</CODE>'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick alpha_gradient.png -quantize transparent \
                            +dither  -colors 15   alpha_colors_15qt.png
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=1 WIDTH=80% CELLPADDING=10 BACKGROUND="../images/bg.gif"><TR>
<TD ALIGN=center>
  <A HREF="alpha_gradient.png"
     ><IMG SRC="alpha_gradient.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="alpha_colors_15qt.png"
     ><IMG SRC="alpha_colors_15qt.png"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Notice how the color quantization completely ignored the transparency of the
colors, and did not touch the images alpha channel at all.  This means you can
process the alpha channel in a more appropriate way for your image, completely
separately to the other colors.  In fact you can do so either before or
after using "<CODE><A HREF="../option_link.cgi?colors" >-colors</A></CODE>"
without problems.  It will make no difference in the result. </P>

This quantization color space is thus recommended when reducing the number of
colors for an image you plan to save to a format with Boolean or no
transparency, such as GIF or XPM image formats.  </P>

If you count up the number of colors generated you will also see that it
generated exactly the number of colors requested.  As such if you you also
need a fully transparent color (likely) then you need to reduce the argument
of "<CODE><A HREF="../option_link.cgi?colors" >-colors</A></CODE>" by at least
one, to leave space for it in the images final color table. </P>

Thus to handle the GIF file format 256 color color table limit, you will need
to reduce colors to 255, and not 256, leaving the extra space for the
fully-transparent color index, as defined by the "<CODE><A
HREF="../option_link.cgi?tranparent-color" >-transparent-color</A></CODE>"
setting.  Adjust this for a smaller color table sizes. </P>

This quantization behaviour is automatic when IM saves to the GIF file format,
but is important when you need to DIY the quantization yourself while
generating global or shared color tables. </P>

Of course you do still need to handle the semi-transparent pixels, so they are
correct for what you want your image to look like. </P>

<PRE>FUTURE: This last part will probably move to a new section on 'Dithering
Alpha Channel' to be created in the near future. And a reference to this
section added here. </PRE>

Here are some examples of dithering just the alpha channel to just a Boolean
or on/off setting, without effecting the rest of the color channels in the
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick alpha_gradient.png \
          -channel A   -threshold 50%       alpha_dither_threshold.gif
  magick alpha_gradient.png \
          -channel A -ordered-dither checks alpha_dither_checks.gif
  magick alpha_gradient.png \
          -channel A -ordered-dither o8x8   alpha_dither_ordered.gif
  magick alpha_gradient.png \
          -channel A -ordered-dither h8x8a  alpha_dither_halftone.gif

  magick alpha_gradient.png -channel RGBA -separate \
          \( +clone -monochrome \) \
          +swap +delete -combine alpha_dither_monochrome.gif
  magick alpha_gradient.png -channel RGBA -separate \
          \( +clone -dither FloydSteinberg -monochrome \) \
          +swap +delete -combine alpha_dither_monochrome_fs.gif
  magick alpha_gradient.png -channel RGBA -separate \
          \( +clone -remap pattern:gray50 \) \
          +swap +delete -combine  alpha_dither_map.gif
  magick alpha_gradient.png -channel RGBA -separate \
          \( +clone -dither FloydSteinberg -remap pattern:gray50 \) \
          +swap +delete -combine  alpha_dither_map_fs.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="alpha_dither_threshold.gif"
     ><IMG SRC="alpha_dither_threshold.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_dither_checks.gif"
     ><IMG SRC="alpha_dither_checks.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_dither_ordered.gif"
     ><IMG SRC="alpha_dither_ordered.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_dither_halftone.gif"
     ><IMG SRC="alpha_dither_halftone.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="alpha_dither_monochrome.gif"
     ><IMG SRC="alpha_dither_monochrome.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_dither_monochrome_fs.gif"
     ><IMG SRC="alpha_dither_monochrome_fs.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_dither_map.gif"
     ><IMG SRC="alpha_dither_map.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="alpha_dither_map_fs.gif"
     ><IMG SRC="alpha_dither_map_fs.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  When dithering a copy of the Alpha Channel, so you can dither it using
  either "<CODE><A HREF="../option_link.cgi?monochrome"
  >-monochrome</A></CODE>", or "<CODE><A HREF="../option_link.cgi?remap"
  >-remap</A></CODE>", make sure the image is a pure grayscale image, and not
  a shape mask containing transparency.  If you don't you will probably end up
  with non-linear effects from the alpha channel still being present. </P>

  There are a number of ways of extracting and restoring the alpha channel
  from an image, as a gray-scale mask so you can dither it.  The above uses
  the <A HREF="../channel/#separate" >Channel Separation</A> and <A
  HREF="../channel/#combine" >Combine</A> to do this.  Other methods use <A
  HREF="../basics/#alpha_extract" >Alpha Extraction</A> with <A
  HREF="../compose/#copyopacity" >CopyOpacity Composition</A>.

</I></FONT></TD></TR></TABLE></P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="dither_error"></A>
<H2>Error Correction Dithering</H2>

As discussed in the introduction an error correction dither is generally
regarded the best choice for producing the truest representation of the
original image with a reduced color set.  It also limits itself to
any pre-defined palette of colors, whether it was user supplied, or as
determined by the IM color quantization routines. </P>

Because of this it is the logical default choice for general color reduction
as provided by the IM operators, "<CODE><A HREF="../option_link.cgi?colors"
>-colors</A></CODE>", "<CODE><A HREF="../option_link.cgi?remap"
>-remap</A></CODE>", "<CODE><A HREF="../option_link.cgi?posterize"
>-posterize</A></CODE>" and "<CODE><A HREF="../option_link.cgi?monochrome"
>-monochrome</A></CODE>".

<A NAME="dither"></A>
<H3>E-Dither Methods</H3>

As of version 6.4.2-9, IM now provides more than one type of dithering style
or method, which can be selected using the "<CODE><A
HREF="../option_link.cgi?dither" >-dither</A></CODE>" setting. Before this IM
was limited to a variation of the <A
HREF="http://www.compuphase.com/riemer.htm" >Riemersma Dither</A>, or <A
HREF="http://www.compuphase.com/hilbert.htm" >Hilbert Curve Dither</A>. which
you can set using "<CODE>-dither Riemersma</CODE>". </P>

Now you can also select a Floyd-Steiberg Dither using "<CODE>-dither
FloydSteinberg</CODE>".  You can see what types of dither methods has been
implemented in your version of IM using...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=dithers.txt>
  magick -list dither
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="dithers.txt"
     ><IMG SRC="dithers.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

For example here is the color wheel dithered using different dithering methods.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png -dither Riemersma      -colors 16 dither_riemersma.gif
  magick colorwheel.png -dither FloydSteinberg -colors 16 dither_floyd.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dither_riemersma.gif"
     ><IMG SRC="dither_riemersma.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="dither_floyd.gif"
     ><IMG SRC="dither_floyd.gif"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the Floyd-Steinberg dither produces a much more uniform dither
pattern than the default Riemersma dither.  The biggest difference between
them is how each of them distributes the 'color error' between neighbouring
pixels.  So lets have a look at just how an E-Dither works. </P>


<A NAME="dither_how"></A>
<H3>How an E-Dither Works</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Re-Write In Progress 
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

The specific method used by IM for general dithering is a variation of the
"Hilbert Curve Error Correction Dither".  This is actually a very good
dithering technique, very well defined and reasonably quick. For a full
description (and a very similar variation) see... <A
HREF="http://www.compuphase.com/riemer.htm" >Riemersma Dither</A>. </P>

Basically each pixel in the image is looked at in a very complex path known as
a '<A HREF="http://www.compuphase.com/hilbert.htm" >Hilbert Curve</A>'.  The
pixel is assigned the color closest to that pixels value, and any difference
between the pixels original color and the selected color, is saved and added
to the next pixels color values (which is always a neighbouring pixel) before
a new color is again selected.  In this way any color variations between
selected colors and the images original color is distributed to the other
pixels in the same area.  The result is that while only specific colors will
be assigned to the final image, the same basic overall color for that area
will closely match the original image.  </P>

For example, here is a small grey image that I asked IM to dither using a set
of colors that does not include the original color. The resulting image is
magnified so you can see the individual colored pixel assigned.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=/dev/null>
  magick -size 10x10 xc:'#999999' -scale 80x80  dither_not.gif
  magick -size 10x10 xc:'#999999' \
          -remap colortable.gif   -scale 80x80  dither.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dither_not.gif"
     ><IMG SRC="dither_not.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="dither.gif"
     ><IMG SRC="dither.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  # check that dither actually generated a three color dither pattern.
  [ `magick identify -format %k dither.gif` -ne 3 ] && echo >&2 \
  "ASSERTION FAILURE: E-Dither Map did not produce a 3 color pattern\!"
</CODE> -->

As you can see the as the original images color was not in the specified color
map, the original color is approximated using a pattern of the three nearest
colors that were in the given color table. </P>

<!-- <CODE EXECUTE>
  # get the average color of the undithered and the dithered image
  magick dither_not.gif -filter box -resize 1x1\! -depth 8 txt: |\
     tail -1 | sed 's/.*#/#/; s/ .*//;' > dither_not_avg.txt
  magick dither.gif -filter box -resize 1x1\! -depth 8 txt: |\
     tail -1 | sed 's/.*#/#/; s/ .*//;' > dither_avg.txt
</CODE> -->
<!-- <CODE EXECUTE ASSERT>
  # Compare color with original image.  (result should be about 277)
  [ `magick dither_not.gif dither.gif -filter box -resize 1x1\! miff:- |\
     magick compare -metric PAE - null: 2>&1 | sed 's/ .*//'` -gt 300 ] && echo >&2 \
  "ASSERTION FAILURE: E-Dither Average larger than expected\!"
</CODE> -->

If we were to average the color generated by the above dither pattern, we
would get the color
<A HREF="dither_avg.txt"
   ><IMG SRC="dither_avg.txt.gif"
         ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>,
which is very close to the images original average color of
<A HREF="dither_not_avg.txt"
   ><IMG SRC="dither_not_avg.txt.gif"
         ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
and that is the whole point of the dither pattern that was produced.  </P>

However as the 'path' used to assign colors is complex (though generally
remains in the local area), the color assignments produce an essentially
random pattern.  It isn't technically random however as the same image will
produce the same pattern, but the results may as well be random, or at least
pseudo-random. </P>

The "F-S" dither is actually only one (the first one) of several 'Rasterized
E-Dithers' that has been developed since its inception in the early 1970's.
It is also probably the most widely implemented, even though it is not
regarded as the best one.  See the paper, <A
HREF="http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT" >Dithering
Algorithms</A>, for a more complete summary of such algorithms. </P>

As of IM v6.4.3 it is also directly available in IM, and is implemented so as
to follow a 'serpentine' path row-by-row from the top of the image to the
bottom.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=/dev/null>
  magick -size 10x10 xc:'#999999'  -dither FloydSteinberg \
          -remap colortable.gif   -scale 80x80  dither_fs.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dither_not.gif"
     ><IMG SRC="dither_not.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="dither_fs.gif"
     ><IMG SRC="dither_fs.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  # check that dither actually generated a three color dither pattern.
  [ `magick identify -format %k dither_fs.gif` -ne 3 ] && echo >&2 \
  "ASSERTION FAILURE: E-Dither Map did not produce a 3 color pattern\!"
</CODE> -->

The "Floyd-Stienberg Dither" in particular I find produces a more 'hash' like
pattern of pixels than the "Hilbert Curve Dither", and was in fact designed to
do so. </P>

Such a regular pattern can make a low level manual clean up of small color
icon images, a lot easier.  This was something I did a lot of in my past for
<A HREF="http://www.ict.griffith.edu.au/anthony/icons/" >Anthony's Icon
Library</A>, but that type of thing is not often needed anymore, except
possibly for small monochrome images. </P>


<A NAME="dither_sensitive"></A>
<H3>E-Dither Problem - Change Sensitive</H3>

One of the biggest problems you face when you use an error correction dither
is that you get an essentially random pattern of pixels, that is also highly
sensitive to changes. </P>

Here for example take the original grey image and replace one pixel with a
different color before dithering it again.  The result is a complete shift of
the dithering pattern in every pixel that is further along the path followed
by the  Hilbert Curve Dither.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=/dev/null>
  magick -size 10x10 xc:'#999999' -draw 'fill #C28 point 2,2' \
          -remap colortable.gif   -scale 80x80   dither_modified.gif
  magick compare dither.gif dither_modified.gif dither_difference.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR><TD ALIGN=center>
  <A HREF="dither.gif"
     ><IMG SRC="dither.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=1><BR>original dither</FONT>
</TD><TD ALIGN=center>
  <A HREF="dither_modified.gif"
     ><IMG SRC="dither_modified.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=1><BR>one pixel change</FONT>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <A HREF="dither_difference.gif"
     ><IMG SRC="dither_difference.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=1><BR>comparison of changes</FONT>
</TD></TR></TABLE>
</DIV></P>

As you can see just adding a single pixel to the image resulted in the dither
pattern changing dramatically!  It only takes a single bit change for the
resulting image to become different, even though overall look of an image
(when not enlarged) is still basically the same (which is the purpose of a
good dither algorithm after all). </P>

The "<CODE>compare</CODE>" image also shows the extent of the change in the
dither pattern.  In this case, approximately 80% of the pixels were assigned a
completely different color. In a Hilbert Curve Dither, a single pixel change
actually will result in every pixel that comes later being possibly different,
which means from 0 to 100% percent of the dither pattern could be
different. It just depends on where in the complex Hilbert curve the change
occurred. </P>

The Floyd-Steinberg dither however only progresses though the image in one
direction, and as such a single pixel change will modify the pattern only to
one side of the change.

<!--
<TR><TD><PRE><CODE DO_NOT_EXECUTE RANDOM OUT=/dev/null>
  magick -size 10x10 xc:'#999999' ppm:- |\
    pnmremap -mapfile=colormap.gif -fs 2>/dev/null | \
      magick - -scale 80x80   dither_fs.gif
  magick -size 10x10 xc:'#999999' -draw 'fill #C28 point 2,2' ppm:- |\
    pnmremap -mapfile=colormap.gif -fs 2>/dev/null | \
      magick - -scale 80x80   dither_fs_modified.gif
  magick compare dither_fs.gif dither_fs_modified.gif dither_fs_difference.gif
</CODE></PRE></TD></TR></TABLE>
-->

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 10x10 xc:'#999999' -draw 'fill #C28 point 2,2' \
          -dither FloydSteinberg -remap colortable.gif \
          -scale 80x80   dither_fs_modified.gif
  magick compare dither_fs.gif dither_fs_modified.gif dither_fs_difference.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR><TD ALIGN=center>
  <A HREF="dither_fs.gif"
     ><IMG SRC="dither_fs.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=1><BR>FS Dither</FONT>
</TD><TD ALIGN=center>
  <A HREF="dither_fs_modified.gif"
     ><IMG SRC="dither_fs_modified.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=1><BR>one pixel change</FONT>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <A HREF="dither_fs_difference.gif"
     ><IMG SRC="dither_fs_difference.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=1><BR>comparison of changes</FONT>
</TD></TR></TABLE>
</DIV></P>

As you can see it has exactly the same problem.  A single pixel change causing
an almost complete change in the dither pattern for the areas of the image
processed after that pixel.  That is from that row downward.  </P>

For a single image the resulting pattern of the dithered colors is
unimportant.  The average color of the pattern should give the image the
appropriate color for that area of the image.  But when you have an animation
in which one image is followed by other very similar images, with large areas
of constant color, the changing dither pattern becomes highly noticeable and
irritating as a low level background 'noise'.  </P>

For example, here I generate a 3 image animation of the same dithered color
but with a single pixel change in each frame.  I also magnify a central
region  so you can see this changing pattern more clearly.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=/dev/null>
  magick -size 80x80 xc:'#999999' \
          \( +clone -draw 'fill #C28 point 2,2' \) \
          \( +clone -draw 'fill #28C point 2,2' \) \
          -remap colortable.gif  -set delay 50 -loop 0   dither_anim.gif
  magick dither_anim.gif -crop 10x10+40+40 +repage \
                              -scale 80x80     dither_anim_magnify.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dither_anim.gif"
     ><IMG SRC="dither_anim.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="dither_anim_magnify.gif"
     ><IMG SRC="dither_anim_magnify.gif"    WIDTH=80   HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see you get a sort of churning background to the image, caused by
the pseudo-randomness generate by the E-Dither.  In most cases the colors used
are close enough together so as not to make this 'dither noise' visible.  But
when the dithering colors are visibly different (in this case forced by the
use of a colormap) it definitely becomes an issue. </P>

See <A HREF="../video/#gif" >Video Color Optimization</A> for a more practical
example of an animation showing this 'dither noise'. </P>

The change in pattern also cause problems in optimizing animations.  That is a
different pattern means that simple <A HREF="../anim_opt/#frame_opt" >frame
optimization</A> fails to reduce the size of frame overlays. For one solution
see <A HREF="../anim_opt/#color_fuzz" >fuzzy color optimization</A>, though
that only works when the churn is using very similar colors.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Unlike other dithering methods (such as <A HREF="#threshold" >threshold</A>,
  and <A HREF="#ordered-dither" >ordered-dither</A>) the "<CODE><A
  HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting does not
  effect color quantization, or error correction dithers.  Basically has it
  has no place in how these image operation work.
</I></FONT></TD></TR></TABLE></P>

Ordered dithers do not have any of these problems, containing changes to the
immediate local area of the change.  Unfortunately are also generally limited
to using a mathematically derived color set. (See <A HREF="#od_posterize"
>Ordered Dither using an Uniform Color Map</A>). </P>


<A NAME="dither_speckle"></A>
<H3>E-Dither Pixel Speckling</H3>

Another problem with E-Dithers is that they can produce the occasional
odd-colored pixels in areas which would otherwise be fairly uniform in color.
For example the occasional green, pixel in a greyscale image. Or as in the
examples below, a white pixel in an areas of otherwise plain flat blue color.
</P>

This is especially the case in large images which containing objects with
large numbers of colors, and other areas of plain solid unchanging colors.
This is especially typical of colored objects overlaid onto flat colored
backgrounds, as you often get in diagrams and drawings. </P>

You can see such an odd-colored pixel in the enlargement of the test examples
above, where an extra light purple pixel was added quite a distance from the
small single pixel change.  The odd-colored pixels added to the above is not
however readily visible and the color map does cover the image rather well,
so the odd pixels are reasonably close to the normal three colors used for
dithering the image. </P>

For a more extreme example, here I have a blurred gradient background, which I
heavily color reduced to 64 colors to really stress the error correction
dither.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x60 xc:SkyBlue \
          -fill DodgerBlue -draw 'circle 50,70 15,35' \
          -fill RoyalBlue  -draw 'circle 50,70 30,45' \
          -blur 0x5  -colors 64     speckle_gradient.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_gradient.gif"
     ><IMG SRC="speckle_gradient.gif"      WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see with this highly reduced color map, the error correction
dither did a reasonably good job of representing the original gradient. </P>

But if we add a patch of pure white to the above...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x60 xc:SkyBlue \
          -fill DodgerBlue -draw 'circle 50,70 15,35' \
          -fill RoyalBlue  -draw 'circle 50,70 30,45' -blur 0x5 \
          -fill white -draw 'rectangle 40,40 60,55' \
          -colors 64   speckle_problem.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_problem.gif"
     ><IMG SRC="speckle_problem.gif"      WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can see that the E-dither suddenly started to produce a sprinkling of
white pixels in the upper area of the image where we didn't have any before.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is an enlargement a small section so you can see these pixel more
clearly...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick speckle_problem.gif -crop 15x15+75+0 +repage \
          -scale 90x90    speckle_prob_mag.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_prob_mag.gif"
     ><IMG SRC="speckle_prob_mag.gif"      WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  # check that magnification shows at least two colors
  [ `magick identify -format %k speckle_prob_mag.gif` -eq 1 ] && echo >&2 \
  "ASSERTION FAILURE: No E-Dither Speckle was found"
</CODE> -->

The odd colored pixel is caused by two factors. </P>

First, the Color Quantization was forced to include a single pure white color
(but no other white-blue anti-aliasing colors) into the final colormap for the
image, thus allowing the dithering process to use this extra color.   </P>

But as E-Dithers slowly accumulate errors, especially in areas of extreme
colors, such as in the top section of the above image.  Eventually the errors
will add up to a value that is large enough make the one additional color the
closest match.  As such, every so often a highly contrasting white pixel is
output to 'correct the error', at a pseudo-random location.  </P>

The result is a very light speckling of white pixels.  The slower the
accumulation of error, the more spread out those white pixels are and the
more, out-of-place, they appear.  </P>

<B>The best solution</B> is to switch to some other image format that does not
have a limited color table.  For example magick your GIF format image to PNG.
This will avoid the need for color quantization (reduction) and hence the need
to dither the reduced colors. </P>

The next solution is to replace the use of E-dither with some other dithering
method, that 'localizes' any errors, such as <A HREF="#ordered-dither"
>Ordered Dithering</A>.  However that is currently not easy thing to apply in
IM at this time. See <A HREF="#od_levels" >Better Ordered Dither Results</A>,
for one such method until a more general one is found. </P>

If switching to another image format, or using a different dithering method is
not practical (and often isn't), then you are left with attempting to fix the
situation for that specific image. </P>

<B>The best fix</B>, to this is to somehow insure you have other colors just
outside the large group of colors that is causing the E-Dither error
accumulation.  However normal <A HREF="#colors" >Color Quantization</A> does
not do this. It tends to pick a set of average colors representing color
groups. What is needed is extra colors that 'picket fence' the edges of the
a large color group, rather than a simple average color. </P>

Here for example, I used a circle rather than a square, so that not only is a
pure white color added, but a number of white-blue colors also.  These were
added automatically due to the anti-aliasing of the circle edges, to smooth
its look.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x60 xc:SkyBlue \
          -fill DodgerBlue -draw 'circle 50,70 15,35' \
          -fill RoyalBlue  -draw 'circle 50,70 30,45' -blur 0x5 \
          -fill white -draw 'circle 50,45 40,40' \
          -colors 64  speckle_fixed.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_fixed.gif"
     ><IMG SRC="speckle_fixed.gif"      WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

And a magnification of the same area as before.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick speckle_fixed.gif -crop 15x15+85+0 +repage \
          -scale 90x90    speckle_fix_mag.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_fix_mag.gif"
     ><IMG SRC="speckle_fix_mag.gif"      WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  # check that magnification shows at least two colors
  [ `magick identify -format %k speckle_fix_mag.gif` -eq 1 ] && echo >&2 \
  "ASSERTION FAILURE: E-Dither Speckle found in 'Fixed image'"
</CODE> -->

As you can see the additional colors provide the extra colors, just outside
the blue-cyan gradient.   Now while these extra colors will mean there are
fewer colors available for the actual gradient, they do provide other
blue-white colors that will allow the E-dither to correct itself sooner and
more often, before the accumulated error can grow too large. </P>

That is not to say we have prevented E-dither speckling, just provided better
colors for the dither algorithm to work with.  If you study the magnified
portion of the image you will still see a speckle pattern, but the colors are
closer to the background color, and there are a lot more of them producing
a more even, spread of speckles. </P>

Another way is to generate our own color table, perhaps based on the one IM
generated, and add the appropriate colors to prevent the error accumulation.
This is however not an easy thing to do, especially with a 3-dimensional color
space. </P>

For this specific image example, one way to prevent 'speckling' is to generate
and dither the background separately, with slightly less colors that is
needed, then overlay the white box and its additional color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x60 xc:SkyBlue \
          -fill DodgerBlue -draw 'circle 50,70 15,35' \
          -fill RoyalBlue  -draw 'circle 50,70 30,45' -blur 0x5 \
          -colors 63 \
          -fill white -draw 'rectangle 40,40 60,55'  speckle_perfect.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_perfect.gif"
     ><IMG SRC="speckle_perfect.gif"      WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  colors=`magick identify -format %k speckle_perfect.gif`
  [ "$colors" -lt 10 ] && echo >&2 \
  "ASSERTION FAILURE: 64 Color Image saved with too few colors ($colors)"
</CODE> -->

This will add a 'white' color to the image, but the background will not have
any speckling effect, as white was not available when the error correction
dither was used. </P>

The result is an image with exactly 64 colors, and no speckling at all.
However this is very dependant on the image and what you are trying to
achieve, so is not a general solution to the specking problem. </P>

<BR>

A more general alternative to adding extra colors is try to remove the
speckles from the final dithered image.  That is clean up the image in some
way. </P>

However this is itself a tricky problem, as you do not what to remove pixels
which are part of the normal dithering pattern. </P>

What we need is to find color pixels which are somehow very different to all
the colors surrounding it, but which are also well isolated from all other
similar colors, by some distance. </P>

<!--  Remove as example was not working
The solution is to pass the dithered image though some time of 'speckle
filter', such as "<CODE><A HREF="../option_link.cgi?median"
>-median</A></CODE>" image filter.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick speckle_problem.gif -median 1 speckle_median.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="speckle_median.gif"
     ><IMG SRC="speckle_median.gif"      WIDTH=100  HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- magick speckle_problem.gif -despeckle -despeckle speckle_despeckle.gif
->

Note however that the dithering between the various color 'zones' was adversely
effected, and the corner of the square was also rounded by this method. </P>
-->

<I>Do you have a better image filter solution?</I> </P>

<B>Summary</B></P>

To me speckling is a very annoying problem, especially for desktop icon images
using a very limited color table.  I myself often edit smaller 'icon' images
to remove speckles or fix some of the other dithering effects, such a vertical
banding. </P>

If you know of another better solution, please let me know. </P>



<A NAME="monochrome"></A>
<H3>Monochrome Dithered Bitmap Images</H3>

The "<CODE><A HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>"
operator is a specialized form of both the "<CODE><A
HREF="../option_link.cgi?colors" >-colors</A></CODE>" operator to generate a
bitmap image. It is as such an ideal operator to demonstrate not only 'Hilbert
Curve Dithering', but also have a closer look at color selection.  </P>

Here is a typical example.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -monochrome     monochrome.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="monochrome.gif"
     ><IMG SRC="monochrome.gif"      WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The operator dithered the image solely based on their grey-scale brightness
'intensity' or 'level', however it doesn't dither the whole grey-scale range
directly but thresholds the most extreme values to their maximum values.
</P>

We can see this by asking IM to dither a gradient image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 15x640 gradient: -rotate 90 \
                   -monochrome     monochrome_gradient.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="monochrome_gradient.gif"
     ><IMG SRC="monochrome_gradient.gif"    WIDTH=640  HEIGHT=15
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  magick monochrome_gradient.gif -crop 1x1+0+0 +repage txt: |\
         tail -n 1 | grep -q -v black && echo >&2 \
  "ASSERTION FAILURE: Monochrome did not generate black."
  magick monochrome_gradient.gif -flop -crop 1x1+0+0 +repage txt: |\
         tail -n 1 | grep -q -v white && echo >&2 \
  "ASSERTION FAILURE: Monochrome did not generate white."
</CODE> -->

As you can see the gradient only has about the middle 50% of its colors
dithered by the "<CODE><A HREF="../option_link.cgi?monochrome"
>-monochrome</A></CODE>" operator.  Special thanks goes to Ivanova
&lt;flamingivanova&#64;punkass.com&gt; for pointing out this interesting fact
of the was IM works. </P>

If you like to dither using the whole grey-scale range, you can use the
"<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>" operator using
a pure black and white colormap (supplied by a built-in pattern image).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -remap pattern:gray50  mono_remap.gif
  magick -size 15x640 gradient: -rotate 90 \
                   -remap pattern:gray50     mono_remap_gradient.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="mono_remap.gif"
     ><IMG SRC="mono_remap.gif"        WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="mono_remap_gradient.gif"
     ><IMG SRC="mono_remap_gradient.gif"    WIDTH=640  HEIGHT=15
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

By more careful selection of colors using "<CODE><A
HREF="../option_link.cgi?remap" >-remap</A></CODE>" you can effectively produce
the same 'threshold' range as used by the "<CODE><A
HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>" operator, or any
other threshold range you like.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick xc:gray20  xc:white  +append   ctrl_colors.gif
  magick logo.png -colorspace Gray \
          -remap ctrl_colors.gif  -normalize  mono_remap_ctrl.gif
  magick -size 15x640 gradient: -rotate 90 \
          -remap ctrl_colors.gif  -normalize  mono_remap_grad_ctrl.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="mono_remap_ctrl.gif"
     ><IMG SRC="mono_remap_ctrl.gif"        WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<DIV ALIGN=center>
  <A HREF="mono_remap_grad_ctrl.gif"
     ><IMG SRC="mono_remap_grad_ctrl.gif"    WIDTH=640  HEIGHT=15
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

What "<CODE><A HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>"
actually does is to first magick the given image first into a grey scale
image, after that it performs a two color '<A HREF="#colors" >Color
Quantization</A>', to decide the threshold colors to dither the image with.
This is what the next section of examples will explore. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?dither" >+dither</A></CODE>" setting
  currently has no effect on the result of "<CODE><A
  HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>".  This however
  may change in the future, so make sure it is not turned off in your scripts
  when using this operator.
</I></FONT></TD></TR></TABLE></P>


<A NAME="two_color"></A>
<H3>Two Color Quantization</H3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Rather than picking the two control colors yourself, you can use color
quantization to pick the best two colors in the image by using the "<CODE><A
HREF="../option_link.cgi?colors" >-colors</A></CODE>" operator.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png   -colors 2 -colorspace gray  -normalize \
                                                 colors_monochrome.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="colors_monochrome.gif"
     ><IMG SRC="colors_monochrome.gif"    WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However the result will not be the same as using  "<CODE><A
HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>", as we didn't
magick the image to grey-scale first. </P>

Instead the image was dithered directly between the two non-grey color values
chosen.

That is the best two colors is selected to dither the image with, rather than
two gray-scale brightness levels.  Consequently it will produce a better
result for say image that only uses colors of about the same gray-scale
'level'. </P>

Here for example we use "<CODE><A HREF="../option_link.cgi?colors"
>-colors</A></CODE>", as well as a "<CODE><A
HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>" bitmap dithering
operator, on a red-blue gradient.  As you can so you can see that the results
are not the same.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 20x640 gradient:red-blue -rotate 90    gradient_rb.png
  magick gradient_rb.png   -colors 2 -colorspace gray \
                                -normalize        colors_threshold.gif
  magick gradient_rb.png       -monochrome       mono_threshold.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_rb.png"
     ><IMG SRC="gradient_rb.png"          WIDTH=640  HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="colors_threshold.gif"
     ><IMG SRC="colors_threshold.gif"      WIDTH=640  HEIGHT=20
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mono_threshold.gif"
     ><IMG SRC="mono_threshold.gif"        WIDTH=640  HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The "<CODE><A HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>"
operator in the above failed to find any differences to bitmap dither as both
blue and red are very nearly the same intensity. Using a "<CODE><A
HREF="../option_link.cgi?colors" >-colors</A></CODE>" quantization method
however had no problem in finding acceptable colors to dither between. </P>

You can also see that only the middle portion of the colors were dithered.
This is due to the color quantization picking colors in the middle of two
color 'clusters' it selected.  Colors on the 'outside' of the selected colors
in is thus effectively threshold directly to that color without dithering.
</P>

This demonstrates that colors on the outside of the quantization color space
does not get dithered, though this fact is difficult to make use of in a
practical way. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

By setting the "<CODE><A HREF="../option_link.cgi?colorspace"
>-colorspace</A></CODE>" to gray-scale before quantization, you will reproduce
the internal operation of the "<CODE><A HREF="../option_link.cgi?monochrome"
>-monochrome</A></CODE>" operator.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png -colorspace gray   -colors 2  -normalize \
                                                 monochrome_equivelent.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="monochrome_equivelent.gif"
     ><IMG SRC="monochrome_equivelent.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

And finally, by turning off the dithering, you can produce a more automatic
separation of the colors in the image than produced by using a fixed "<CODE><A
HREF="../option_link.cgi?threshold" >-threshold</A></CODE>" setting.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -colorspace gray  +dither  -colors 2  -normalize \
           threshold_two_grays.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="threshold_two_grays.gif"
     ><IMG SRC="threshold_two_grays.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Remember  "<CODE><A HREF="../option_link.cgi?monochrome"
  >-monochrome</A></CODE>" currently ignores the "<CODE><A
  HREF="../option_link.cgi?dither" >+dither</A></CODE>" setting,
  so you can't just use that operator to do a 'smart threshold'.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

If you remove the  "<CODE><A HREF="../option_link.cgi?colorspace"
>-colorspace</A></CODE>" for the color quantization stage of the image
processing, you can threshold an image based on the best color separation
(rather than greyscale color separation) possible for that image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  +dither  -colors 2  -colorspace gray -normalize \
           threshold_two_color.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="threshold_two_color.gif"
     ><IMG SRC="threshold_two_color.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="remap"></A>
<H3>Dither using Pre-Defined Color Maps</H3>

As shown above "<CODE><A HREF="../option_link.cgi?colors" >-colors</A></CODE>"
attempts to choose an optimal limited set of colors with which to represent an
image.  With "<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>" you
provide IM with the final set of colors you want to use for the image, whether
you plan to dither those colors, or just replace the ones with their nearest
neighbours. </P>

The argument is given as an image containing all the colors you would like to
use.  If you what to reduce a large image of colors to just its list of
colors, you can use "<CODE><A HREF="../option_link.cgi?unique-colors"
>-unique-colors</A></CODE>", before saving, it for later use by "<CODE><A
HREF="../option_link.cgi?remap" >-remap</A></CODE>". </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that while the "<CODE><A HREF="../option_link.cgi?remap"
  >-remap</A></CODE>" operator will accept any image to use, do not use a JPEG
  image for this image or you will get a lot of extra colors due to its 'lossy
  compression' generating extra colors. </P>

  On the other hand using JPEG to generate extra colors may help resolve the
  'speckling' problem seen previously!

</I></FONT></TD></TR></TABLE></P>

For example here I limit the colors used in the IM logo to a predefined map of
named X window colors.  The default is the '<CODE>Riemersma</CODE>' dither,
but as of IM v6.4.4 "<CODE><A HREF="../option_link.cgi?dither"
>-dither</A></CODE>" was expanded to allow the selection of other dither
methods such as '<CODE>FloydSteinberg</CODE>'.  You can of course still turn
off dithering using the "<CODE><A HREF="../option_link.cgi?dither"
>+dither</A></CODE>" option.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -dither None       -remap colortable.gif  remap_logo_no.gif
  magick logo.png  -dither Riemersma  -remap colortable.gif  remap_logo_rm.gif
  magick logo.png  -dither FloydSteinberg \
                                       -remap colortable.gif  remap_logo_fs.gif
</CODE></PRE></TD></TR></TABLE>
 <A HREF="logo.png"
    ><IMG SRC="logo.png"       WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="../images/colortable.gif"
     ><IMG SRC="../images/colortable.gif"   WIDTH=210 HEIGHT=115
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT"==&gt;">
  <A HREF="remap_logo_no.gif"
     ><IMG SRC="remap_logo_no.gif"        WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="remap_logo_rm.gif"
     ><IMG SRC="remap_logo_rm.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="remap_logo_fs.gif"
     ><IMG SRC="remap_logo_fs.gif"        WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see IM attempted to do a reasonable job of representing the image
using just the given colors, though the results is nowhere near as good as the
image you get if you allowed IM to select the color set to use. </P>

Mind you this "<CODE><A HREF="../images/colortable.gif" >colortable.gif</A></CODE>"
image was never designed for dithering images, but as a color set for
designing cartoon-like color icons for older more primitive X window color
displays (See <A HREF="http://www.ict.griffith.edu.au/anthony/icons/" >Anthony's X
Window Icon Library</A> and <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/docs/colors.html" >AIcons Color
Selection</A> for details). </P>

<!-- <CODE EXECUTE>
  magick remap_logo_no.gif -unique-colors \
          -format "%w colors" info: > remap_logo_count_no.txt
  magick remap_logo_rm.gif -unique-colors \
          -format "%w colors" info: > remap_logo_count_rm.txt
  magick remap_logo_fs.gif -unique-colors \
          -format "%w colors" info: > remap_logo_count_fs.txt
</CODE> -->

Also note that the final image did not use all 32 colors provided by this map,
though more of the colors in the map will be used when some form of dithering
was enabled (<A HREF="remap_logo_count_rm.txt" ><IMG
SRC="remap_logo_count_rm.txt.gif" ALIGN=absmiddle BORDER=0 ></A> and <A
HREF="remap_logo_count_fs.txt" ><IMG SRC="remap_logo_count_fs.txt.gif"
ALIGN=absmiddle BORDER=0 ></A> respectively), than when it was turned off (<A
HREF="remap_logo_count_no.txt" ><IMG SRC="remap_logo_count_no.txt.gif"
ALIGN=absmiddle BORDER=0 ></A>).  </P>

This last example shows just how important selecting a good colormap is.
Because of this I recommend you let IM optimize the color selection used in an
image using the "<CODE><A HREF="../option_link.cgi?colors"
>-colors</A></CODE>" operator, and modify that to suit your needs, unless you
have more pressing reasons not to do so.  </P>

One final point, while you can specify a color space in which "<CODE><A
HREF="../option_link.cgi?colors" >-colors</A></CODE>" will find the best set
of colors, you currently can NOT define a color space for the color mapping or
dithering phase.  All my experiments seem to show that the color set is
applied (both error correction dither and nearest color replacement) based on
RGB space. The "<CODE><A HREF="../option_link.cgi?quantize"
>-quantize</A></CODE>" colorspace setting is only used for the selection of
colors, not its mapping. </P>

So if using a color map is such a bad idea, why would you want use it? </P>

There are a number common reasons, usually because you need more control of
the specific palette of colors used in an image.  Another user also separated
the colormap out so he could use it on a Risograph (A digital printing
system).  </P>

<I>If you know of another reason to use the "<CODE><A
HREF="../option_link.cgi?remap" >-remap</A></CODE>" operator which I have not
presented below - Mail me.</I> </P>


<A NAME="remap_common"></A>
<H4>Common or 'Best' Colormap</H4>

The other technique, when handling multiple images, is to generate a common
color table for all the images involved. </P>

Basically you append all the images together into one large image, then use
the "<CODE><A HREF="../option_link.cgi?colors" >-colors</A></CODE>" operator to
figure out a good color map to use that is common to all the images.  Once you
have that color map image you can use it to re-color each of the original
images using this juts generated <A HREF="#map" >Pre-Defined Color Map</A>.
</P>

Alternatively, you can use the special "<CODE><A HREF="../option_link.cgi?remap"
>+remap</A></CODE>" operator, which does the same thing to a 255 color colormap.
It counts up the colors, perform the color quantization to form a good, common
colormap, then dithers the images to use that map, if needed. </P>

Both "<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?remap" >+remap</A></CODE>" forms however has one very
important feature for GIF animations.  It converts all the images to an image
"<CODE><A HREF="../option_link.cgi?type" >-type</A></CODE>" of
'<CODE>Palette</CODE>' with all the images using the same palette of colors.
</P>

The reason is that when writing a GIF image, the first images color palette,
will be used for the file formats 'global colormap'. Then as each image is
written it notes that those images use the same set of colors, so it does NOT
create a 'local colormap'.  This can save up to 256 &times; 3, or 768 bytes of
colormap space for each and every image the final GIF file. </P>

Only the "<CODE><A HREF="../option_link.cgi?remap" >-remap</A></CODE>" operators
can do this. So when handling GIF's and in particular GIF animations, it can
be an important point to remember. </P>

For more details, and an example see <A HREF="../anim_opt/#colortables" >Gif
Animations, Global Color Table</A>. </P>


<A NAME="web_safe"></A>
<H3>Web Safe Coloring</H3>

When the WWW was first created, computer displays had a limited range of colors
available, and web browsers usually used a simpler set of colors for images.
As such it was common to recolor images to this color set, to make them both
smaller, and to ensure they will look okay on users browsers.  For more detail
see <A HREF="http://www.webstyleguide.com/graphics/dither.html" >Web Style
Guide, Dithering</A>. </P>

To help with this IM provided a built-in colormap image of this special table
of 216 colors, called "<CODE>netscape:</CODE>".  So lets look at how our test
image would look on of an old web browser magick display using these colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png         -remap netscape:  remap_netscape.gif
  magick logo.png +dither -remap netscape:  remap_netscape_nd.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo.png"
     ><IMG SRC="logo.png"                 WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="../images/netscape.gif"
     ><IMG SRC="../images/netscape.gif"             WIDTH=108  HEIGHT=72
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT"=&gt;">
  <A HREF="remap_netscape.gif"
     ><IMG SRC="remap_netscape.gif"         WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="remap_netscape_nd.gif"
     ><IMG SRC="remap_netscape_nd.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This color set was a mathematically determined pallet, designed by engineers
of displays and computers, not graphic artists, and while it is is general
enough that it works reasonably well for real images such as photos, it is
very bad for images containing large flat areas of color, such as logos,
backgrounds, computer generated images such as graphs, and cartoon-like
images. </P>

Basically this works in areas of highly variable colors, but for the larger
flat areas of constant colors a dithering of three colors (in general) is
applied, such as the off-blue shirt of the IM logo test images (above). </P>

In other words, if you were designing an image or logo for use on the web, you
work generally try to use the colors in this pallet for the large flat areas,
and only have dithered colors in areas where your have varying shades of color.
</P>

The above commands lets you test your images to see how they would look on
more primitive computer displays, and to edit image to use these colors, so
they will work well.  This is particularly important for symbols and
navigation images. </P>

Of course today, thanks to the demands by game and web users, you can be
pretty well assured that most users have a modern computer magick display that does
not have those old color limitations, however the use of this "web safe
palette" is still around, as it does have other benefits, such an image
compression.  </P>

For a discussion about the use of Web-safe colors in the modern world see <A
HREF="http://www.webmonkey.com/00/37/index2a.html" >Death of the Web-safe
Color Palette?</A>, and probably a more important view from a graphic designer
that first identified this color map, <A HREF="http://www.lynda.com/hex.asp"
>Lynda Weinman</A>. </P>


<A NAME="remap_colormaps"></A>
<H3>Generating Color Maps</H3>

Determining a good color map for any image, or an specific set of images, can
be very important.  This becomes especially important when you are dealing
with a sequence of images that will be used for GIF animation.  Basically you
want to make it so they only need one color table, to use for all the frames
of the animation, rather than a separate color table for each frame. In other
words you want one single color map for all the image. </P>

You have really only two choices in this case.  You can attempt to create
a colormap that will work well for any image, or you try to optimize a color
map for the specific set of images you are applying it to. </P>

<A NAME="netscape"></A>
<H4>Web-Safe Colormap</H4>

<A HREF="../images/netscape.gif"
   ><IMG SRC="../images/netscape.gif"             WIDTH=108  HEIGHT=72
         ALIGN=right VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The first method is typically a mathematically generated color map, such as
the IM built-in "<CODE>netscape:</CODE>" color map.   This provides a set of
216 colors, which will nicely fit into the GIF formats 256 color limit, and
still have space for handling image transparency, or even adding some extra
colors for special purposes, like shadows, or text overlays.  </P>

This color map was generated by creating 6 levels of colors for each of the
three color channels, producing  6&times;6&times;6 colors or 216 colors.  The
number of the beast. </P>

As only 219 color are used it still has space (for GIF images) to add more
colors to the color map for specific purposes.  For example a transparent
color, as well as more grey scale shades.  An old Macintosh version of the
web-safe map actually did exactly this to try to improve its overall result,
but it was only used on Macintosh web clients.  </P>

This is probably the most common 'uniform' (or mathematically derived)
colormap in general use, thanks to its simplicity, and its general use on the
the World Wide Web.  </P>

<A NAME="332_colormap"></A>
<H4>Uniform 332 Colormap</H4>

Another uniform color mapping that is commonly used is the "332 RGB color
map".  The number refer to the number of bits used to represent each color
within a 8 bit color index. That is 3 bits (or 8 levels) of red, 3 for green,
and 2 bits (or 4 color levels) for blue, seeing as our eyes do not respond
well to blue.

This gives 3+3+2 bits or an 8 bit color index, or 256 colors.  Perfect for the
limited GIF color table. However it will not leave any space for a GIF
transparency color, or other special use colors. </P>

Here is one way to get IM to generate this color map...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify >
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 16x16 xc: -channel R -fx '(i%8)/7' \
                          -channel G -fx '(j%8)/7' \
                          -channel B -fx '((i>>3&1)|(j>>2&2))/3' \
          -scale 600% colormap_332.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="colormap_332.png"
     ><IMG SRC="colormap_332.png"     WIDTH=96  HEIGHT=96
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28 ><IMG
  SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD> <TD ALIGN=justify
  WIDTH=100%><FONT SIZE=-1><I> The bit-shifting operators
  '<CODE>&gt;&gt;</CODE>' and '<CODE>&lt;&lt;</CODE>' was missing from the
  "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator until IM
  version 6.2.9-2.
</I></FONT></TD></TR></TABLE></P>

A simpler way of doing the same thing is to use <A HREF="#od_posterize"
>Ordered Dither using Uniform Color Levels</A> using the operation,
"<CODE>-ordered-dither threshold,8,8,4</CODE>" (see that examples area).
A far easier and faster technique than the above <A HREF="../transform/#fx"
>DIY FX method</A>, and even allows you to use other built-in dithering maps
for better gradient handling.  </P>

The only drawback with this map is that it does not actually provide any
'gray' colors at all.  However this drawback can be a plus when dithering is
used as the slight color differences reduce the effect of color boundary
changes in a grey-scale gradient, making it just that little bit smother
looking. </P>

<A NAME="16bit_colormap"></A>
<H4>TrueColor 16bit Colormap</H4>

A similar uniform colormap to the '332 colormap' above is used by X windows
in a rarely used 16 bit visual class.  In this case, 16 bits are used for the
color index which is divided into 5 bits for red, 5 for green, and 6 for blue.
</P>

In other words, this color map is more like a "556 colormap", and is best
achieved using a <A HREF="#od_posterize" >Ordered Dither using Uniform Color
Levels</A> using a 'threshold' dithermap. Specifically the operation
"<CODE>-ordered-dither threshold,32,32,64</CODE>".

16 bit colormaps are however rarely seen as images using colormaps typically
need a 8 bit color table.  As such I won't mention it further. </P>

<A NAME="gamma_colormap"></A>
<H4>Gamma Corrected Uniform Colormaps</H4>

At this time IM does not do gamma corrected color maps directly. </P>

Instead what you should do is magick your image (assuming you have Q16 or
better compile time <A HREF="../basics/#quality" >quality</A> version of IM),
from the sRGB or whatever gamma level the image has to a linear RGB model,
before doing your dithering. </P>

This also goes for many other image processing operations, such as resize,
bluring, etc. </P>

See <A HREF="../resize/#resize_gamma" >Resizing with Gamma Correction</A> for
an example. </P>


<A NAME="posterize"></A>
<H3>Posterize, Recolor using an Uniform Color Map</H3>

The operators original purpose (using an argument of '2') is to re-color
images using just 8 basic colors, as if the image was generated using a simple
and cheap poster printing method using just the basic colors. Thus the
operator gets its name. </P>

The "<CODE><A HREF="../option_link.cgi?posterize" >-posterize</A></CODE>"
operator is actual fact is a special color reduction operator that generates a
color map based on the the number of color 'levels' given, for each color
channels in the image, dithering the image using an error correction dither.
</P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick netscape: -scale 50%  +dither  -posterize 2   posterize_2_ns.gif
  magick netscape: -scale 50%  +dither  -posterize 3   posterize_3_ns.gif
  magick netscape: -scale 50%  +dither  -posterize 6   posterize_6_ns.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/netscape.gif"
     ><IMG SRC="../images/netscape.gif"             WIDTH=108  HEIGHT=72
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT"=&gt;">
  <A HREF="posterize_2_ns.gif"
     ><IMG SRC="posterize_2_ns.gif"       WIDTH=108  HEIGHT=72
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_3_ns.gif"
     ><IMG SRC="posterize_3_ns.gif"       WIDTH=108  HEIGHT=72
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_6_ns.gif"
     ><IMG SRC="posterize_6_ns.gif"       WIDTH=108  HEIGHT=72
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see a "<CODE><A HREF="../option_link.cgi?posterize"
>-posterize</A></CODE>" argument on '<CODE>2</CODE>' means to only provide 2
colors per color channel, producing a map of just 8 colors for a 3 channel RGB
image, such as the above. Basically it will recolor images using the threshold
set of 8 colors. </P>

An argument of '<CODE>3</CODE>' will map image colors based on a colormap of
27 colors, including mid-tone colors. While an argument of '<CODE>4</CODE>'
will generate a 64 color colortable, and '<CODE>5</CODE>' generates a 125
color colormap.  Of course as mentioned above, an argument of '<CODE>6</CODE>'
will reproduce the same set of 216 colors, as provided by the in the built-in
"<CODE>netscape:</CODE>" image. </P>

Please note that a "<CODE><A HREF="../option_link.cgi?posterize"
>-posterize</A></CODE>" argument of '<CODE>0</CODE>' or '<CODE>1</CODE>' is
non-sensible, and with the latest IM releases just converts images to pure
black (which though logical, is quite useless). </P>

The result is that the image has been recolors using a mathematically derived
or 'uniform' color map. </P>

You can see this more clearly on a gradient image, producing an even
distribution of posterized gray levels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  #magick -size 20x640  gradient: -rotate 90  gradient.png
  magick gradient.png  +dither  -posterize 5   posterize_gradient.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="posterize_gradient.gif"
     ><IMG SRC="posterize_gradient.gif"    WIDTH=640   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

For example lets posterize the IM logo image at various levels...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  +dither -posterize 2  posterize_logo.gif
  magick logo.png          -posterize 2  posterize_logo_dither.gif
  magick logo.png          -posterize 6  posterize_6_logo.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo.png"
     ><IMG SRC="logo.png"                   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="posterize_logo.gif"
     ><IMG SRC="posterize_logo.gif"         WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_logo_dither.gif"
     ><IMG SRC="posterize_logo_dither.gif"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_6_logo.gif"
     ><IMG SRC="posterize_6_logo.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As a better test lets poserize the shaded "<A HREF="../images/colorwheel.png"
>colorwheel</A>" image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png  +dither  -posterize 2   posterize_2_cw.gif
  magick colorwheel.png  +dither  -posterize 3   posterize_3_cw.gif
  magick colorwheel.png  +dither  -posterize 6   posterize_6_cw.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/colorwheel.png"
     ><IMG SRC="../images/colorwheel.png"           WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT"=&gt;">
  <A HREF="posterize_2_cw.gif"
     ><IMG SRC="posterize_2_cw.gif"        WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_3_cw.gif"
     ><IMG SRC="posterize_3_cw.gif"        WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_6_cw.gif"
     ><IMG SRC="posterize_6_cw.gif"        WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And here is the same thing with dithering enabled...
<DIV ALIGN=center>
<!--
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png  -posterize 2   posterize_2_dither.gif
  magick colorwheel.png  -posterize 3   posterize_3_dither.gif
  magick colorwheel.png  -posterize 6   posterize_6_dither.gif
</CODE></PRE></TD></TR></TABLE>
-->
  <A HREF="../images/colorwheel.png"
     ><IMG SRC="../images/colorwheel.png"           WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT"=&gt;">
  <A HREF="posterize_2_dither.gif"
     ><IMG SRC="posterize_2_dither.gif"   WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_3_dither.gif"
     ><IMG SRC="posterize_3_dither.gif"   WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_6_dither.gif"
     ><IMG SRC="posterize_6_dither.gif"   WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course many of the bitmap dithers we look at in the next section can also
generate level 2 ordered dithers, using various sorts of dither styles.
However few can use a larger number of grey levels. </P>

<A HREF="#ordered-dither" >Ordered Dither</A> as of IM v6.2.9, is also a
posterization method, due to its current limitation in dithering using a
uniform colormaps.  However the dither pattern is more uniform, with a larger
selection of styles, than the pseudo-randomized dither produced by "<CODE><A
HREF="../option_link.cgi?posterize" >-posterize</A></CODE>".  Compare these
with the dithered "<CODE><A HREF="../option_link.cgi?posterize"
>-posterize</A></CODE>" versions above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png  -ordered-dither o8x8,2   posterize_2_od.gif
  magick colorwheel.png  -ordered-dither o8x8,3   posterize_3_od.gif
  magick colorwheel.png  -ordered-dither o8x8,6   posterize_6_od.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/colorwheel.png"
     ><IMG SRC="../images/colorwheel.png"           WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT"=&gt;">
  <A HREF="posterize_2_od.gif"
     ><IMG SRC="posterize_2_od.gif"       WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_3_od.gif"
     ><IMG SRC="posterize_3_od.gif"       WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="posterize_6_od.gif"
     ><IMG SRC="posterize_6_od.gif"       WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The '<CODE>threshold</CODE>' dither map (instead of '<CODE>o8x8</CODE>' used
above) effectively converts "<CODE><A HREF="../option_link.cgi?ordered-dither"
>-ordered-dither</A></CODE>" into an un-dithered posterization method. </P>

Finally the <A HREF="#ordered-dither" >Ordered Dither</A> does allow you to
specify a different number of color levels, for each individual color channel.
Something that the "<CODE><A HREF="../option_link.cgi?posterize"
>-posterize</A></CODE>" operator does not currently allow.  </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="threshold"></A>
<H2>Threshold Dithering Methods</H2>

<H3>Threshold Images</H3>

The simplest method of converting an image into black and white bitmap (to
color) image is to use "<CODE><A HREF="../option_link.cgi?threshold"
>-threshold</A></CODE>".  This is actually a simple mathematical operator that
just provides a cut-off value.  Anything equal to or below that value becomes
black, while anything larger becomes white. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png     -threshold   -1   threshold_0.gif
  magick logo.png     -threshold  25%   threshold_25.gif
  magick logo.png     -threshold  50%   threshold_50.gif
  magick logo.png     -threshold  75%   threshold_75.gif
  magick logo.png     -threshold 100%   threshold_100.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="threshold_0.gif"
     ><IMG SRC="threshold_0.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="threshold_25.gif"
     ><IMG SRC="threshold_25.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="threshold_50.gif"
     ><IMG SRC="threshold_50.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="threshold_75.gif"
     ><IMG SRC="threshold_75.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="threshold_100.gif"
     ><IMG SRC="threshold_100.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see a value of '<CODE>-1</CODE>' will magick all colors white,
while '<CODE>100%</CODE>' converts all colors to black.  A '<CODE>50%</CODE>'
is of course the most common value used. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

A value of '<CODE>0</CODE>' is a special case which turns all non-pure black
colors, white.  Of course if the image does not have pure-black colors, then
you will only get a solid white image!

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -threshold   0    threshold_black.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="threshold_black.gif"
     ><IMG SRC="threshold_black.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

If you actually want to magick all non-pure white colors to black, then
I recommend that you threshold the <A HREF="../color_mods/#negated"
>negated</A> image instead of trying to work out the right threshold value to
use (one less than IM's current 'MaxRGB'), a value that is dependant on your
specific IM's compile time in <A HREF="../basics/#quality" >Quality, or
'Q'</A> setting.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -negate -threshold 0 -negate threshold_white.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="threshold_white.gif"
     ><IMG SRC="threshold_white.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The "<CODE><A HREF="../option_link.cgi?threshold" >-threshold</A></CODE>"
operator can be classed as an ultimate 'contrast' operator, maximizing the
differences in colors by the threshold level. It is however a gray-scale
operator, meaning that the "<CODE><A HREF="../option_link.cgi?channel"
>-channel</A></CODE>" setting, can be used to adjust which color channel the
operator will be applied to. </P>

For example you can threshold each of the individual channels of the image to
produce the same effect as an un-dithered level 2 "<CODE><A
HREF="../option_link.cgi?posterize" >-posterize</A></CODE>" operation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -channel R -threshold 50% \
                     -channel G -threshold 50% \
                     -channel B -threshold 50%   threshold_posterize.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="threshold_posterize.gif"
     ><IMG SRC="threshold_posterize.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that "<CODE><A HREF="../option_link.cgi?threshold"
  >-threshold</A></CODE>" treats any transparency in an image as a matte
  channel, not an alpha channel (just as it is stored internally within IM).
  As such caution is needed if you plan to apply this operator to the alpha
  channel.  See <A HREF="../masking/#matte" >Matte Channel</A> for more
  details.
</I></FONT></TD></TR></TABLE></P>

For a more automatic thresholding technique, you can use a <A HREF="#two_color"
>Two Color Quantization</A> technique that we showed previously. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, this will threshold the image based on the best two colors found
in the image. These colors may not necessarily be greyscale or even opposites,
just the two colors that best represent the whole image.   The two colors are
then mapped (using "<CODE><A HREF="../option_link.cgi?normalize"
>-normalize</A></CODE>") to pure black and white.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE_ALREADY_DONE>
  magick logo.png  +dither  -colors 2  -colorspace gray -normalize \
             threshold_two_color.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="threshold_two_color.gif"
     ><IMG SRC="threshold_two_color.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="random-threshold"></A>
<H3>Random Dither and Threshold</H3>

The "<CODE><A HREF="../option_link.cgi?random-threshold"
>-random-threshold</A></CODE>" operator is a special form of bitmap image
converter.  In this case it uses a very simple "random dither" to determine if
a particular pixel is to become a white pixel or a black pixel. </P>

Unlike the "<CODE><A HREF="../option_link.cgi?threshold" >-threshold</A></CODE>"
or the "<CODE><A HREF="../option_link.cgi?monochrome" >-monochrome</A></CODE>"
operators, or even the variations in the previous section, the selected
channels (set with "<CODE><A HREF="../option_link.cgi?channels"
>-channels</A></CODE>") are not merged together into single grey-scale channel
and dithered as a single unit. Instead "<CODE><A
HREF="../option_link.cgi?random-threshold" >-random-threshold</A></CODE>" works
on each selected channel completely independently of each other. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Of course using the operator directly will result in a 2 level posterization
of the image using a random dither.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  magick logo.png  -random-threshold  0x100%  random_posterize.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_posterize.gif"
     ><IMG SRC="random_posterize.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Converting to gray-scale will equalize all the channels in the image, before
they are dithered.  But as each channel is dithered independent of each other
and in a random way, the result is not a bitmap image as you would expect.
Instead you will get a splatter of color pixels, especially for mid-tone
colors.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  magick logo.png  -colorspace Gray -random-threshold  0x100% \
                                                   random_greyscale.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_greyscale.gif"
     ><IMG SRC="random_greyscale.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is the correct way to generate a proper random dithered bitmap image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  magick logo.png  -colorspace Gray -channel B \
          -random-threshold 0x100%    -separate   random_monochome.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_monochome.gif"
     ><IMG SRC="random_monochome.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Basically what it did was to only dither one channel of the grey-scaled
image, and then use the "<CODE><A HREF="../option_link.cgi?separate"
>-separate</A></CODE>" channel operator to extract that channel as the
final bitmap image. Tricky but effective. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As a special feature for this operator, IM will ensure a bitmap image is
generated in the special "<CODE><A HREF="../option_link.cgi?channels"
>-channels</A></CODE>" option of '<CODE>All</CODE>' is used.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  magick logo.png  -channel All -random-threshold 0x100% random_all.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_all.gif"
     ><IMG SRC="random_all.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However please note that any alpha channel will be ignored and lost using this
method, as such it is not normally recommended. I myself only discovered this
ancient feature by accident from the source code. </P>

Now that you know how to use the operator to correctly generate bitmaps
from a color image lets look how the argument effects the range of the
dithering.  This also shows clearly the 'clumping' of pixels that this dither
produces.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  #magick -size 20x640  gradient: -rotate 90  gradient.png
  magick gradient.png  -channel All \
                        -random-threshold 0x100%  random_grad_0x100.gif
  magick gradient.png  -channel All \
                        -random-threshold 10x90%  random_grad_10x90.gif
  magick gradient.png  -channel All \
                        -random-threshold 25x75%  random_grad_25x75.gif
  magick gradient.png  -channel All \
                        -random-threshold 50x50%  random_grad_50x50.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random_grad_0x100.gif"
     ><IMG SRC="random_grad_0x100.gif"    WIDTH=640   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_grad_10x90.gif"
     ><IMG SRC="random_grad_10x90.gif"    WIDTH=640   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_grad_25x75.gif"
     ><IMG SRC="random_grad_25x75.gif"    WIDTH=640   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_grad_50x50.gif"
     ><IMG SRC="random_grad_50x50.gif"    WIDTH=640   HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

A "<CODE><A HREF="../option_link.cgi?random-threshold"
>-random-threshold</A></CODE>" setting of '<CODE>0x100%</CODE>' will produce a
purely 'Random Dither' of the image.  If the two bounds are set to the same
value (or even past each other) it will just produce a pure "<CODE><A
HREF="../option_link.cgi?threshold" >-threshold</A></CODE>" image. </P>

Using any other sets of bounds (usually specified using a percentage) will
threshold the bitmap outside the given range, while producing a random dither
pattern for the values within the given range. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The best results can be obtained by using a slightly smaller range, just as
you get using the "<CODE><A HREF="../option_link.cgi?monochrome"
>-monochrome</A></CODE>" operator.  A value of about '<CODE>30x80%</CODE>'
probably the best result for most cases.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  magick logo.png  -channel All -random-threshold 30x80%  random_30x80.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_30x80.gif"
     ><IMG SRC="random_30x80.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course the result is still not very good. But then this is the simplest and
worst form of dithering you can get. </P>

What actually happens is that the randomized dither pattern tends to produce
'clumps' of pixels rather than a smooth dither pattern. this is due to the
high frequency 'noise' in the random number generator.  However at very high
resolutions a random dither has been shown to produce an extremely good result,
if random enough. IM uses a cryptographic level of randomness so it will
likely be very random, though images are rarely used at a high enough a
resolution to make it useful in this way.  </P>

One 'fix' for this dither, that has been suggested is to use a random 'blue
noise' generator (a high frequency filter, as opposed to a low frequency 'pink
noise' filter used in sound production). This should remove the clumping of
the pixels, but is very difficult to implement digitally. No known
implementation of 'blue noise randomized dither' has been found, and unlikely
to be ever created. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="ordered-dither"></A>
<H2>Ordered Dithering</H2>

While a random dither produces random clumps of pixels, and the various error
correction dithers produce an essentially random pattern of dots, ordered
dithering is basically the opposite. It is designed to be as mathematically
deterministic as possible.  So deterministic, that you actually need to
specify the pattern for it to should use in dithering the image. </P>

The "<CODE><A HREF="../option_link.cgi?ordered-dither"
>-ordered-dither</A></CODE>" operator will dither each of the selected
"<CODE><A HREF="../option_link.cgi?channels" >-channels</A></CODE>" in the
image a given predefined pattern. The argument defines the pattern (known as a
threshold map) to use. </P>

These threshold maps fall into three basic styles. <A HREF="#diffused"
>Diffused Pixel Dithers</A> where the pixels are placed as far from each other
as possible, so as to avoid 'clumping' and tiling artifacts.  Or to clump them
together into tight dots that makes them easier to mechanically print, in a
technique known as <A HREF="#halftone" >Digital Halftoning</A>. There is also
some specialized artistic threshold maps that we will also be looking at, and
even designing our own dithering pattern or threshold maps. </P>

In each case the number of pixels that is on or off in the threshold map
depends on the grey-level intensity of the image (or individual color channel)
that is being dithered into a bitmap. </P>

The map adds pixel threshold levels in a consistent manner, so that once a
pixel turns on at a particular 'threshold' it remains on for any lighter grey
color.  This consistency is very important, otherwise artifacts are produced
along the boundaries of changes the dither pattern. </P>

The important point about this is that the result for each pixel in an image
is purely mathematically determined independently of any other pixel in the
image.  As such any small change to the original image will have absolutely no
effect on the image in any other area a problem that <A HREF="#dither_error"
>Error Correction Dithers</A> have, as we saw above. </P>

This point is vital to consistent dithering of video images and optimized
animations. </P>


<A NAME="diffused"></A>
<H3>Diffused Pixel Dithering</H3>

The original purpose of ordered dithering, and what most graphic programmers
expect to get when you use an ordered dither is sometime more correctly
termed, "Diffused Pixel Ordered Dither". </P>

What this means is that pixels are added to the tiled map as the threshold
intensity increases, so that they are as far away from each other and evenly
distributed as possible. This produces a highly consistent pattern that look
quite smooth and near invisible on most modern displays.</P>

Such patterns have been worked out for tiling sizes that are a power of 2,
namely, tile sizes of 2, 4, and 8.  Though IM also provides a reasonable
threshold pattern for a 3 by 3 threshold map tile. </P>

Here is the current set of built-in ordered dithers that IM currently
provides.  Remember the argument reflects the tile size of the ordered dither.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png    -ordered-dither o2x2    logo_o2x2.gif
  magick logo.png    -ordered-dither o3x3    logo_o3x3.gif
  magick logo.png    -ordered-dither o4x4    logo_o4x4.gif
  magick logo.png    -ordered-dither o8x8    logo_o8x8.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo_o2x2.gif"
     ><IMG SRC="logo_o2x2.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_o3x3.gif"
     ><IMG SRC="logo_o3x3.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_o4x4.gif"
     ><IMG SRC="logo_o4x4.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_o8x8.gif"
     ><IMG SRC="logo_o4x4.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note how a larger tile size allows you to simulate more 'color levels', but
also generates more noticeable defects or rectangular arrays of pixels at
certain levels.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>o8x8</CODE>' ordered dither was part of the IM core code for a
  long time, but was not used. It was only added as an option to the
  "<CODE><A HREF="../option_link.cgi?ordered-dither"
  >-ordered-dither</A></CODE>" operator IM v6.2.9, when IM Examples started
  to detail the use of this operator. </P>

  At this time the maps were given more definitive names to allow further
  expansion of the "<CODE><A HREF="../option_link.cgi?ordered-dither"
  >-ordered-dither</A></CODE>" operator, though the older backward
  compatible 'tile size' names, were retained as aliases to the new names.
  </P>

  Also the 'maps' that produced the 'o3x3' and 'o4x4' were completely revised
  to produce a better 'diffused pixel' dither pattern.  Before this the maps
  produced distinct 'clumps' of pixels. </P>

  See <A HREF="../bugs/ordered-dither/" >Ordered Dither Upgrade</A> notes
  page for examples of the old patterns before they were fixed, as well as
  other changes made during the development for the official release of the
  upgrades in IM v6.3.0.

</I></FONT></TD></TR></TABLE></P>

Of course you need to magick the image to grey-scale first to produce a
proper bitmap of all the channels in the image, however as the process is not
random you don't need to post-process the image as you need to for the <A
HREF="../option_link.cgi?random-threshold" >-random-threshold</A></CODE>"
operator simplifying things enormously.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png -colorspace Gray  -ordered-dither o2x2  logo_bw_o2x2.gif
  magick logo.png -colorspace Gray  -ordered-dither o3x3  logo_bw_o3x3.gif
  magick logo.png -colorspace Gray  -ordered-dither o4x4  logo_bw_o4x4.gif
  magick logo.png -colorspace Gray  -ordered-dither o8x8  logo_bw_o8x8.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo_bw_o2x2.gif"
     ><IMG SRC="logo_bw_o2x2.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_o3x3.gif"
     ><IMG SRC="logo_bw_o3x3.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_o4x4.gif"
     ><IMG SRC="logo_bw_o4x4.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_o8x8.gif"
     ><IMG SRC="logo_bw_o8x8.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As a reference here are each of the "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>"
'diffused pixel' patterns applied to a grey-scale gradient, so you can see
clearly what they look like.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # Threshold Non-Dither / Minimal Checkerboard Dither
  magick gradient.png   -ordered-dither threshold  od_threshold.gif
  magick gradient.png   -ordered-dither checks     od_checks.gif
  # Diffused Pixel Dither
  magick gradient.png   -ordered-dither o2x2       od_o2x2.gif
  magick gradient.png   -ordered-dither o3x3       od_o3x3.gif
  magick gradient.png   -ordered-dither o4x4       od_o4x4.gif
  magick gradient.png   -ordered-dither o8x8       od_o8x8.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="od_threshold.gif"
     ><IMG SRC="od_threshold.gif"         WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_checks.gif"
     ><IMG SRC="od_checks.gif"            WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<HR WIDTH=20% ALIGN=center>
  <A HREF="od_o2x2.gif"
     ><IMG SRC="od_o2x2.gif"              WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_o3x3.gif"
     ><IMG SRC="od_o3x3.gif"              WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_o4x4.gif"
     ><IMG SRC="od_o4x4.gif"              WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_o8x8.gif"
     ><IMG SRC="od_o8x8.gif"              WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The number of effective or pseudo-level patterns produced by a specific
ordered dither, is typically (by not always) equal to the number of pixels in
the pattern plus one.  As such a '<CODE>o3x3</CODE>' ordered dither will
produce 3&times;3+1 or 10 effective grey levels per channel (black, white, and
8 artificial gray patterns) in the resulting image. </P>

Also shown above are two special minimal dither threshold maps:<OL>
<LI>a straight '50% threshold' non-dither, which does not produce any extra
    grey levels and
<LI>a 'checks' or checkerboard dither pattern, that only inserts a single
    pattern to add an extra 'pseudo-level' to the resulting gradient.
</OL></P>


<A NAME="halftone"></A>
<H3>Digital Halftone Dithers</H3>

The "<CODE><A HREF="../option_link.cgi?ordered-dither"
>-ordered-dither</A></CODE>" was extended in IM v6.2.8-6 with a set of
digital-halftone dither patterns (thanks Glenn Randers-Pehrson). All of which
were set to produce a simple 45 degree dot pattern. With IM v6.3.0 this was
further expanded with a similar set of larger un-angled halftones.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before the release of IM v6.3.0 halftone screens were selected by using
  an argument of the form '<CODE>{number}x1</CODE>'.  With the <A
  HREF="../bugs/ordered-dither/" >Re-Development of Ordered Dither</A> this
  limitation was lifted, better naming selected, and extra halftone screens
  (orthogonal forms) was added (see example arguments below).
</I></FONT></TD></TR></TABLE></P>

Note that digital halftoning is not strictly a true halftone screen, which is
designed to handle round dots of ink mechanically deposited onto a medium such
as paper, cardboard or even metal.  Such dots can overlap, and smear during
the printing process, thus requiring some non-linear level adjustment.  This
is not needed for producing purely digital halftone effects.  For more details
of the process see the document <A
HREF="http://www.fho-emden.de/~hoffmann/hilb010101.pdf" >Dithering and
Halftoning (PDF)</A>. </P>

That said the <A HREF="#ordered-dither" >Ordered Dither</A> digital halftone
patterns do provide the same basic effect as seen in newspapers and cheaply
printed magazines. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # Halftone Screen (45 degree angle)
  magick logo.png   -ordered-dither h4x4a    logo_h4x4a.gif
  magick logo.png   -ordered-dither h6x6a    logo_h6x6a.gif
  magick logo.png   -ordered-dither h8x8a    logo_h8x8a.gif
  # Halftone Screen (orthogonal)
  magick logo.png   -ordered-dither h4x4o    logo_h4x4o.gif
  magick logo.png   -ordered-dither h6x6o    logo_h6x6o.gif
  magick logo.png   -ordered-dither h8x8o    logo_h8x8o.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo_h4x4a.gif"
     ><IMG SRC="logo_h4x4a.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_h6x6a.gif"
     ><IMG SRC="logo_h6x6a.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_h8x8a.gif"
     ><IMG SRC="logo_h8x8a.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  &nbsp; &nbsp; &nbsp;
  <A HREF="logo_h4x4o.gif"
     ><IMG SRC="logo_h4x4o.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_h6x6o.gif"
     ><IMG SRC="logo_h6x6o.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_h8x8o.gif"
     ><IMG SRC="logo_h8x8o.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Again to use the "<CODE><A HREF="../option_link.cgi?colorspace"
>-colorspace</A></CODE>" operator to generate a true bitmap dither of an
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # Halftone Screen (45 degree angle)
  magick logo.png -colorspace Gray  -ordered-dither h4x4a logo_bw_h4x4a.gif
  magick logo.png -colorspace Gray  -ordered-dither h6x6a logo_bw_h6x6a.gif
  magick logo.png -colorspace Gray  -ordered-dither h8x8a logo_bw_h8x8a.gif
  # Halftone Screen (orthogonal)
  magick logo.png -colorspace Gray  -ordered-dither h4x4o logo_bw_h4x4o.gif
  magick logo.png -colorspace Gray  -ordered-dither h6x6o logo_bw_h6x6o.gif
  magick logo.png -colorspace Gray  -ordered-dither h8x8o logo_bw_h8x8o.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo_bw_h4x4a.gif"
     ><IMG SRC="logo_bw_h4x4a.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_h6x6a.gif"
     ><IMG SRC="logo_bw_h6x6a.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_h8x8a.gif"
     ><IMG SRC="logo_bw_h8x8a.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  &nbsp; &nbsp; &nbsp;
  <A HREF="logo_bw_h4x4o.gif"
     ><IMG SRC="logo_bw_h4x4o.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_h6x6o.gif"
     ><IMG SRC="logo_bw_h6x6o.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_bw_h8x8o.gif"
     ><IMG SRC="logo_bw_h8x8o.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And finally another gradient reference image to clearly show the halftone
dither pattern, and how the pixel clumps within the dither pattern grow into
each other as the grey-level changes.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # Halftone Screen (45 degree angle)
  magick gradient.png   -ordered-dither h4x4a      od_h4x4a.gif
  magick gradient.png   -ordered-dither h6x6a      od_h6x6a.gif
  magick gradient.png   -ordered-dither h8x8a      od_h8x8a.gif
  # Halftone Screen (orthogonal)
  magick gradient.png   -ordered-dither h4x4o      od_h4x4o.gif
  magick gradient.png   -ordered-dither h6x6o      od_h6x6o.gif
  magick gradient.png   -ordered-dither h8x8o      od_h8x8o.gif
  magick gradient.png   -ordered-dither h16x16o    od_h16x16o.gif
  # Circle Halftones (black and white)
  magick gradient.png   -ordered-dither c7x7b      od_c7x7b.gif
  magick gradient.png   -ordered-dither c7x7w      od_c7x7w.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="od_h4x4a.gif"
     ><IMG SRC="od_h4x4a.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_h6x6a.gif"
     ><IMG SRC="od_h6x6a.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_h8x8a.gif"
     ><IMG SRC="od_h8x8a.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<HR WIDTH=20% ALIGN=center>
  <A HREF="od_h4x4o.gif"
     ><IMG SRC="od_h4x4o.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_h6x6o.gif"
     ><IMG SRC="od_h6x6o.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_h8x8o.gif"
     ><IMG SRC="od_h8x8o.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_h16x16o.gif"
     ><IMG SRC="od_h16x16o.gif"           WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<HR WIDTH=20% ALIGN=center>
  <A HREF="od_c7x7b.gif"
     ><IMG SRC="od_c7x7b.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_c7x7w.gif"
     ><IMG SRC="od_c7x7w.gif"             WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Up until ImageMagick version 6.2.9 all the above threshold ordered dither map
were all that was possible with IM. This has now changed, allowing users to add
their own patterns, add even contribute them to the IM community. </P>

The 'Circle' halftone thresholds were added by Glenn Randers-Pehrson, IM
v6.6.5-6. </P>


<A NAME="halftone_offset"></A>
<H3>Offset HalfTone Dither</H3>

The only problem with the above halftone dither is that it is that the exact
same threshold map (tile) is applied to all the color channels in the same
way.  That means the same set of primary color is arranged in dots with the
same 'center'. </P>

To get what is known as 'Offset Printing' the threshold pattern is rotated in
a particular pattern such that the colors form small scale 'rosette patterns'
that destroyes the more horrible looking interference (moiré) patterns that
you could otherwise develop. </P>

This diagram basically explains the process, and is explained in great detail
on the Wikipedia Page, <A HREF="http://en.wikipedia.org/wiki/Halftone"
>Halftone</A>.

<DIV ALIGN=center>
  <IMG SRC="../img_diagrams/cmyk_offset.png" WIDTH=512 HEIGHT=384
       ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note however that the rotated screens do not tile very well, as such the best
idea is to actually generate the rotated pattern directly, rather than use
a tiles threshold pattern. </P>

Here is one way to give an image an offset-halftone printing look, using small
rotated 2x2 pixel checkerboard pattern, which is about the smallest 'screen'
that can be used.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=center><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick colorwheel.png  -set option:distort:viewport '%wx%h+0+0' \
          -colorspace CMYK -separate null: \
          \( -size 2x2 xc: \( +clone -negate \) \
                +append \( +clone -negate \) -append \) \
          -virtual-pixel tile -filter gaussian \
          \( +clone -distort SRT 60 \) +swap \
          \( +clone -distort SRT 30 \) +swap \
          \( +clone -distort SRT 45 \) +swap \
          \( +clone -distort SRT 0 \)  +swap +delete \
          -compose Overlay -layers magick composite \
          -set colorspace CMYK -combine -colorspace RGB \
          offset_colorwheel.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="offset_colorwheel.png"
     ><IMG SRC="offset_colorwheel.png"        WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the four rotated 'screens' are applied to the image as a whole, it
is only the "<CODE>-combine</CODE>" step in CMYK colorspace, that actually
extracts the 4 different color channels from the screened images. </P>

Also the 'no-op' distort for the last 'black' channel is important as it will
blur the input checker pattern according to the Gaussian filter that was used
on the other channels during their rotations, even though that screen itself
is not being rotated. </P>

And here I use the scaling function of the <A HREF="../distorts/#srt" >SRT
Distort</A> used to generate the rotated tiles to create a slightly larger and
more blurry 'screen pattern'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick parrots_med.png  -set option:distort:viewport '%wx%h+0+0' \
          -colorspace CMYK -separate null: \
          \( -size 2x2 xc: \( +clone -negate \) \
                +append \( +clone -negate \) -append \) \
          -virtual-pixel tile -filter gaussian \
          \( +clone -distort SRT 2,60 \) +swap \
          \( +clone -distort SRT 2,30 \) +swap \
          \( +clone -distort SRT 2,45 \) +swap \
          \( +clone -distort SRT 2,0  -blur 0x0.7 \) +swap +delete \
          -compose Overlay -layers magick composite \
          -set colorspace CMYK -combine -colorspace RGB \
          offset_parrots.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="offset_parrots.png"
     ><IMG SRC="offset_parrots.png"        WIDTH=300 HEIGHT=200
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the pattern remains very 'square-like' especially the black screen
from which all the others are derived. </P>

FUTURE POSSIBILITY: Replace the 2 pixel checkboard in the above with
"pattern:gray50" pixel level checkerboard pattern.  Gaussian filter options
can be used to adjust the bluriness of the scaled pattern.  Alternatively, you
can blurry scale the pattern, and thresholded it, to make rounder dots.  This
can then be rotated as previously to create the 4 color screens.  </P>

It also would be better is a larger screen using a pattern of hexagonal dots
could be used, rather than the checkerboard pattern I have used above. </P>

<BR>

It is important to note that this is not really generating color dots like
true offset printing, but faking it by simply multiplying the color screens
against the original image.  You can see that this is the case due to the
sharp color change along the edges of the red parrot against the green
background.  True offset printing using only dots of pure color will not have
any middle of dot color changes.  It is the size of the pure colored dot that
should change, depending on the average of the colors in that area reprended
by the dot in the source image. </P>

To actually generate an true offset printing image only containing round dots
in each color channel of appropriate size would require a lot more work.  The
average color in each dot in each color channel will been to be determined,
and from that the appropriate size of colored dot (anti-aliased circle)
generated.  <I>Anyone like to give it a go?</I> </P>

The above was from a discussion in the IM forum discussion <A
HREF="../forum_link.cgi?f=1&t=18409&p=70730" >CMYK Halftone Effect</A> which
looks at how photoshop 'fakes it', and how ImageMagick could achieve the same
effect. </P>

This discussion is also related to <A
HREF="../forum_link.cgi?f=1&t=17389&p=67746" >B/W Halftone Dither</A> which
takes a closer look at generating true halftone screens using actual dots of
appropriate sized. That discussion however did not take it to the next step of
using offset (rotated) screens. Such screens would probably require rotating
the image to generate the dots, then rotating the dot pattern back again for
that specific color channel. </P>


<A NAME="thresholds_xml"></A>
<H3>XML Threshold Maps</H3>

From IM version 6.3.0, rather than using a fixed set of map that were built
into the source code of IM (shown previously), the maps are now read in from a
set of XML data files external to the program itself. </P>

As part of this change you can now list the available 'threshold maps' that
"<CODE><A HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>"
operator can use.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=tmaps_list.txt>
  magick identify -list threshold
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tmaps_list.txt"
     ><IMG SRC="tmaps_list.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

The above list shows not only the threshold maps available, but also the
aliases provided for backwards compatibility or alternate naming, and those
defined in my own personal "<CODE>thresholds.xml</CODE>" XML data file (saved
into the "<CODE>.magick</CODE>" sub-directory of my home). </P>

When "<CODE><A HREF="../option_link.cgi?ordered-dither"
>-ordered-dither</A></CODE>" is looking for a map, the first map that it finds
in the above list, will be used.  As such you can not override a system
defined threshold pattern. </P>

The system file "<CODE>thresholds.xml</CODE>" (the path of which is given by
the above "<CODE><A HREF="../option_link.cgi?list" >-list</A></CODE>" option),
contains a complete summary of the format of the XML file.  A format that is
simple enough (with error checks by IM) to allow users to define and create
their own ordered dither threshold maps.  </P>

For example here is a copy of the '<CODE>diag5x5</CODE>' threshold map
I defined in my personal "<CODE>threshold.xml</CODE>" file.

<DIV ALIGN=center>
<!-- <CODE EXECUTE NOIMAGE OUT=tmap_diag.txt>
  perl -ne 'print if /threshold map="diag5x5"/ .. /\/threshold/' \
       $HOME/.magick/thresholds.xml
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tmap_diag.txt"
     ><IMG SRC="tmap_diag.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

If you look it creates a simple 5x5 map of a single diagonal line that becomes
thicker as the threshold level increases.  The level numbers in the map goes
from 0 to 5, one less than the divisor, which declares how many 'grays' it
needs to divide the color gradient into. </P>

Here is a gradient dithered using this personal threshold map.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png   -ordered-dither diag      od_diag.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="od_diag.gif"
     ><IMG SRC="od_diag.gif"              WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And here is an example of using that threshold to dither the alpha
channel of a simple shadowed image, a purpose for which I designed it.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 70x60 xc:none -font Candice -pointsize 50 \
          -fill black -annotate +10+45 'A' -channel RGBA  -blur 0x5 \
          -fill white -stroke black -draw "text 5,40 'A'"   shadow.png

  magick shadow.png  -channel A  -ordered-dither diag   shadow_diag.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shadow.png"
     ><IMG SRC="shadow.png"               WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shadow_diag.gif"
     ><IMG SRC="shadow_diag.gif"          WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Pretty cool hey! More on dithering alpha channels later. First I need to also
show how to use the coloring abilities of expanded "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>"
operator.  </P>


<A NAME="od_posterize"></A>
<H3>Ordered Dither using Uniform Color Levels</H3>

With the release of IM v6.3.0, not only was the threshold maps used by
"<CODE><A HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>"
changed so as to be read from external files, but the internal operations was
enhanced to allow it to use mathematically defined 'posterized' color maps.
</P>

This means you can generate a more deterministic dithering of images than you
can achieve with 'error correction dithering'.  This is especially important
for color reductions involving animations as you will not get problems from
color differences between frames. </P>

The posterization levels is passed to the "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>" argument
using an extra comma separated list of numbers appended to the name of the
threshold map to use.  If no numbers are provided then the operator falls back
to the normal 2 color (or posterize level 1) color map. </P>

For example and argument of '<CODE>checks,6</CODE>' will use a classic <A
HREF="#web_safe" >Web Safe Color Map</A> (posterized level 6) color map (also
defined by the "<CODE>netscape:</CODE> built-in colormap image). However as
the minimal dither map of '<CODE>checks</CODE>' is used a single extra level
of dithering is added between each of the 6 color levels creating 11
pseudo-levels of colors in each channel of the image. </P>

In other words even though only 6 levels of color per channel is being used
(producing 6^3 or 216 colors) the single dither pattern between levels
increases the dither to and effective 11 levels (producing and effective 11^3
or 1331 colors). </P>

For example, here is a gray scale gradient dithered using 6 grey levels and
various threshold maps. The first map '<CODE>threshold</CODE>' is a special
non-dithering ordered dither threshold map, showing just the colors used.
</P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png   -ordered-dither threshold,6  od_threshold_6.gif
  magick gradient.png   -ordered-dither checks,6     od_checks_6.gif
  magick gradient.png   -ordered-dither o2x2,6       od_o2x2_6.gif
  magick gradient.png   -ordered-dither o4x4,6       od_o4x4_6.gif
  magick gradient.png   -ordered-dither o8x8,6       od_o8x8_6.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="od_threshold_6.gif"
     ><IMG SRC="od_threshold_6.gif"       WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_checks_6.gif"
     ><IMG SRC="od_checks_6.gif"          WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_o2x2_6.gif"
     ><IMG SRC="od_o2x2_6.gif"            WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_o4x4_6.gif"
     ><IMG SRC="od_o4x4_6.gif"            WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="od_o8x8_6.gif"
     ><IMG SRC="od_o8x8_6.gif"            WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV>

As you can see even though only 6 colors are used, with ordered dithering you
increase the effective number of colors used to define the gradient, to a
point where you can be hard pressed to notice just how few colors were
actually used!  </P>

Not only can you define the number of posterization levels for all channels,
but unlike the "<CODE><A HREF="../option_link.cgi?posterize"
>-posterize</A></CODE>" error correction dither option, you can specify the
levels for each channel.  The numbers are assigned to the channels as per the
"<CODE><A HREF="../option_link.cgi?channels" >-channels</A></CODE>" setting.
</P>

For example here we dithered the gradient using a special 332 color map (8
levels or red and green, 4 of blue) which defines a total of 256 colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png   -ordered-dither o8x8,8,8,4   od_o8x8_884.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="od_o8x8_884.gif"
     ><IMG SRC="od_o8x8_884.gif"          WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Because of the different number of color levels per channel, the above image
does not contain just pure grey colors, but includes some bluish and yellowish
pixels which cancels each other out to produce extra levels of greys. </P>

Now magick compare the <A HREF="#ordered-dither" >O-dithered</A> version against
error correction dithered version using a posterization levels of 2, and 6,
and a "332 colormap" (8 levels of red and green, 4 of blue).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png  -ordered-dither o8x8        logo_o8x8_2.gif
  magick logo.png  -posterize 2                logo_posterize_2.gif
  magick logo.png  -ordered-dither o8x8,6      logo_o8x8_6.gif
  magick logo.png  -posterize 6                logo_posterize_6.gif
  magick logo.png  -ordered-dither o8x8,8,8,4  logo_o8x8_332.gif
  magick logo.png  -remap colormap_332.png     logo_remap_332.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="logo_o8x8_2.gif"
     ><IMG SRC="logo_o8x8_2.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_posterize_2.gif"
     ><IMG SRC="logo_posterize_2.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  &nbsp; &nbsp;
  <A HREF="logo_o8x8_6.gif"
     ><IMG SRC="logo_o8x8_6.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_posterize_6.gif"
     ><IMG SRC="logo_posterize_6.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  &nbsp; &nbsp;
  <A HREF="logo_o8x8_332.gif"
     ><IMG SRC="logo_o8x8_332.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="logo_remap_332.gif"
     ><IMG SRC="logo_remap_332.gif"           WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The first image of each pair in the above is mathematically ordered dithered,
while the second is pseudo-randomly 'error correction' dithered. </P>

The last pair uses the special '332 colormap' (See <A HREF="#remap_colormaps"
>Generating Color Maps</A>), which is regarded as probably the best posterize
colormap for general images with a 256 color limit. The odd difference in
channel levels producing a slightly better shading of colors for this cartoon
like image. </P>

It was to allow the production the '332 colormap' that the "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>" operator,
included the ability to specify separate levels for each color channel.  </P>

<A NAME="od_levels"></A>
<H4>Better Ordered Dither Results</H4>

Lets take a closer look at the level 6 <A HREF="#ordered-dither" >O-Dither</A>
we just generated.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=/dev/null OUT=logo_color_6.txt>
  magick logo.png -ordered-dither o8x8,6 -format %k info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="logo_color_6.txt"
     ><IMG SRC="logo_color_6.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As you can see for this image we did not even come close to filling the GIF
color table (256 limit).  Basically as the image generally consists of mostly
blue colors, very few shades of red or even green colors from a level 6
uniform colormap was even used. </P>

However by increasing the number of posterization level we can fill the GIF
color table better, so as to produce a better <A HREF="#ordered-dither"
>O-Dithered</A> Image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=/dev/null OUT=logo_color_13.txt>
  magick logo.png -ordered-dither o8x8,13 -format %k info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="logo_color_13.txt"
     ><IMG SRC="logo_color_13.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

This produces enough colors to be only slightly smaller than the GIF color
table limits.  With the increase in the number of colors the result looks
a lot better that the results of a simple standard uniform colormap.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick logo.png -ordered-dither o8x8,13    logo_o8x8_13.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="logo_o8x8_13.gif"
     ><IMG SRC="logo_o8x8_13.gif"        WIDTH=100   HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see with a high 'levels' value, "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>" can
produce images that are comparable to color quantized, to the specific color
picking generated by color quantization and an error correction dither. </P>

The major point about these images, is not that they are of high quality.
After all a full <A HREF="#colors" >Color Quantization</A> can more easily
produce better color map for the image.  But that the low level dither pattern
within the image is fixed, regardless of any small changes that may occur.
Only the area changes will be changed in the Ordered Dithered Image. </P>

That is, they do not have the <A HREF="#dither_sensitive" >E-Dither
Sensitivity</A> to change that causes problems for <A
HREF="../anim_opt/#frame_opt" >Frame Optimization</A> in GIF animations.  (see
<A HREF="../anim_opt/#color_fuzz" >Optimization Problem</A>)</P>

Of course for an animation, you will need to "<CODE><A
HREF="../option_link.cgi?append" >-append</A></CODE>" all the images together,
before checking how many colors is actually used. And you will need to use the
special "<CODE><A HREF="../option_link.cgi?remap" >+remap</A></CODE>" option
after using the "<CODE><A HREF="../option_link.cgi?ordered-dither"
>-ordered-dither</A></CODE>" to force IM to generate a 'common global
colormap' for ALL the images, even though you have already performed color
reduction and dithering.  </P>

<I>This method of determining the number of color levels is not simple to
determine, but it does works. I hope to work out a way for IM to determine the
best level automatically, especially for GIF animations. </I></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="diy_dither"></A>
<H2>DIY Dither Patterns and Threshold Maps</H2>

Previously I show you that the new "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>" operator
can accept an user defined dithering pattern.  Here I am going to show you how
you can create your own dither pattern. Specifically a special pattern I found
useful for generating a shadows consisting of horizontal lines. </P>

<A NAME="diy_multi"></A>
<H3>Multi-Image Dither Patterns</H3>

The first thing you need to do is create a set of images defining the pattern
you want to create. The pattern should start with a solid black image of the
right size as the first image (all pixels off) and a solid white image at the
other end (all pixels on). </P>

The next image should be the middle 50% grey pattern, defining the the basic
style of the dithering you are trying to achieve. </P>

For example here is my initial DIY dither pattern. Which I save into a
multi-image GIF file (not a GIF animation)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 2x2 xc:black \
          \( +clone -draw 'fill white line 0,0 1,0' \) \
          xc:white     dpat_hlines2x2.gif
  magick montage dpat_hlines2x2.gif    -tile x1 -background none -frame 2 \
          -filter box  -geometry 32x32+5+0    dpat_hlines2x2_imgs.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dpat_hlines2x2.gif"
     ><IMG SRC="dpat_hlines2x2_imgs.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This is about the simplest set of dither pattern images you can get,
and is very similar to the 'checks' or 'Checkerboard Dither', but with
horizontal lines, rather than a checker pattern. </P>

So you can see just what this dither pattern would look like, here is a rather
simple DIY ordered dither, that makes direct use of the threshold dithering
image set.


<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png   dpat_hlines2x2.gif \
          -virtual-pixel tile  -fx 'u[floor((n-1)*u)+1]' dgrad_hlines2x2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dgrad_hlines2x2.gif"
     ><IMG SRC="dgrad_hlines2x2.gif"      WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the dither pattern is nothing fancy.

The  "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" function is a
variation of the <A HREF="../color_mods/#color_lut" >Color Lookup Tables</A>
function, namely, an IM Dither Lookup Patterns' type function.  And with a
"<CODE><A HREF="../option_link.cgi?virtual-pixel" >-virtual-pixel</A></CODE>"
setting of '<CODE>tile</CODE>', the function does not even need to know the
size of the dither pattern image you are using. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The use of "<CODE><A HREF="../option_link.cgi?virtual-pixel"
  >-virtual-pixel</A></CODE>" by the "<CODE><A HREF="../option_link.cgi?fx"
  >-fx</A></CODE>" operator using calculated indexes like this was broken
  before IM version 6.2.9-2.
</I></FONT></TD></TR></TABLE></P>

Lets try this dither pattern set again but using a simple shadowed image...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick shadow.png dpat_hlines2x2.gif  -channel A \
          -virtual-pixel tile  -fx 'u[floor((n-1)*u)+1].g' \
          shadow_dpat_hlines2x2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shadow.png"
     ><IMG SRC="shadow.png"               WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shadow_dpat_hlines2x2.gif"
     ><IMG SRC="shadow_dpat_hlines2x2.gif" WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="diy_threshold"></A>
<H3>DIY Ordered Dither Threshold Maps</H3>

The above DIY dither pattern is about as simple a dither pattern as you can
get, and as such we can magick it directly into a XML threshold map, so that
the fast built-in "<CODE><A HREF="../option_link.cgi?ordered-dither"
>-ordered-dither</A></CODE>" operator can make use of it. </P>

Here is the final XML definition, which I saved in my own personal threshold
map file "<CODE>~/.magick/thresholds.xml</CODE>" of my "$HOME" directory.

<DIV ALIGN=center>
<!-- <CODE EXECUTE NOIMAGE OUT=tmap_hlines2x2.txt>
  perl -ne 'print if /threshold map="hlines2x2"/ .. /\/threshold/' \
       $HOME/.magick/thresholds.xml
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tmap_hlines2x2.txt"
     ><IMG SRC="tmap_hlines2x2.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

The XML format is very simple, and defines a 2x2 pixel map.  The first black
image is given a value of zero, and has no pixels, so no zero values is
present.  The pixels turned on (made white) in the middle image is set to
'<CODE>1</CODE>' and the remaining or second image pixels are given a value of
'<CODE>2</CODE>'. </P>

The '<CODE>divisor=</CODE>' defines the number of images, or pseudo-color
levels (fake color levels) this dither pattern represents, so it has a value
of '<CODE>3</CODE>'.  It divides the pixel values, to defined the color level
at which that pixel is to be turned on. As such the top two pixels are turned
on for colors larger than 1/3, while the bottom two are turned on for color
values larger that 2/3.   That is each pixel value represents a 'threshold'
level, and why dither patterns are also called threshold maps. </P>

The rest of the definition defines the names (and optional alias) by which you
can refer to the threshold map for the ordered dither operator. </P>

So lets try it out...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png  -ordered-dither hlines2x2  od_hlines2x2.gif
  magick shadow.png  -channel A \
          -ordered-dither hlines2x2   shadow_hlines2x2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="od_hlines2x2.gif"
     ><IMG SRC="od_hlines2x2.gif"         WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="shadow.png"
     ><IMG SRC="shadow.png"               WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shadow_hlines2x2.gif"
     ><IMG SRC="shadow_hlines2x2.gif"     WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see the result is reasonably good, but we can do other things
to improve the result. </P>

By adjusting the threshold values in the map, we can change the boundary's, so
it does not divide the color space into 3 equal areas...

<DIV ALIGN=center>
<!-- <CODE EXECUTE NOIMAGE OUT=tmap_hlines2x2a.txt>
  perl -ne 'print if /threshold map="hlines2x2a"/ .. /\/threshold/' \
       $HOME/.magick/thresholds.xml
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tmap_hlines2x2a.txt"
     ><IMG SRC="tmap_hlines2x2a.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Note how I increased the divisor to '<CODE>10</CODE>', so as to divide the
color levels into ten equal sections.  I then changed the threshold settings
so that the pattern starts at a 30% threshold at the transparent end (black),
to 90% for fully opaque (white).

And here is the results of changing the threshold map.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png  -ordered-dither hlines2x2a  od_hlines2x2a.gif
  magick shadow.png -channel A \
          -ordered-dither hlines2x2a  shadow_hlines2x2a.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="od_hlines2x2a.gif"
     ><IMG SRC="od_hlines2x2a.gif"        WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="shadow_hlines2x2a.gif"
     ><IMG SRC="shadow_hlines2x2a.gif"     WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see this widened the range of semi-transparent pixels that use pure
horizontal lines as a dither pattern. This gives a better better shadow
effect, though it probably should only be used with a less fuzzy shadow than
the example used here. </P>

Note however that this type of change to a threshold is very uncommon. Though
justified for the intended use in this case.  Basically it does not properly
define a gradient, or allow for lighter and darker shades of patterns.  For
that we need to make a much more complex threshold map, with more pixels, and
more patterns. </P>


<A NAME="diy_hlines"></A>
<H3>DIY Horizontal Line Dither</H3>

Here I expanded the simple horizontal lines dither pattern I created above
into a set of patterns, to produce a smoother gradient from 'off' to 'on'.
This was the result.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick montage dpat_hlines.gif   -filter box   -geometry 60x20+2+0 \
          -tile x1 -background none  -frame 2   dpat_hlines_images.gif
  magick gradient.png  dpat_hlines.gif  \
          -virtual-pixel tile  -fx 'u[floor((n-1)*u)+1]' \
          dgrad_dpat_hlines.gif
  magick shadow.png dpat_hlines.gif  -channel A \
          -virtual-pixel tile  -fx 'u[floor((n-1)*u)+1].g' \
          shadow_dpat_hlines.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dpat_hlines_images.gif"
     ><IMG SRC="dpat_hlines_images.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="dgrad_dpat_hlines.gif"
     ><IMG SRC="dgrad_dpat_hlines.gif"    WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="shadow.png"
     ><IMG SRC="shadow.png"               WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shadow_dpat_hlines.gif"
     ><IMG SRC="shadow_dpat_hlines.gif" WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see it now consists of 9, 12x4 pixel images. It does not represent
all the pixel patterns that you could have, but this enhances the effect of
the lines.  Also I doubled its height so as to jitter the gaps in the lines
appropriately. </P>

Here is another example of using this dither pattern...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 120x55 xc:white  -draw 'fill #777 ellipse 50,43 30,5 0,360' \
          -motion-blur 0x15+180   -blur 0x2      sphere_shadow.png
  magick sphere_shadow.png dpat_hlines.gif \
          -virtual-pixel tile  -fx 'u[floor((n-1)*u)+1]' \
          sphere_shadow_dither.gif
  magick sphere_shadow_dither.gif   -fill red  -stroke firebrick \
          -draw 'circle 35,25 35,5'     sphere_shadow_hlines.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sphere_shadow.png"
     ><IMG SRC="sphere_shadow.png"       WIDTH=120 HEIGHT=55
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="sphere_shadow_dither.gif"
     ><IMG SRC="sphere_shadow_dither.gif"       WIDTH=120 HEIGHT=55
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="sphere_shadow_hlines.gif"
     ><IMG SRC="sphere_shadow_hlines.gif"       WIDTH=120 HEIGHT=55
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
  

The next step is to magick this set of dither patterns into single threshold
map image, rather than a set of multiple images.  This is achieved by using
some fancy image manipulations to merge all the images together.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 1x10 gradient: -flip -crop 1x1 +repage -delete 0,-1 \
          -scale 12x4\! null: \( dpat_hlines.gif -delete 0 \) \
          +matte -compose CopyOpacity -layers Composite \
          -reverse -compose Over -flatten +matte dmap_hlines.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="dmap_hlines.png"
     ><IMG SRC="dmap_hlines_mag.png"          WIDTH=120 HEIGHT=40
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE>
  magick dmap_hlines.png -scale 120x40 dmap_hlines_mag.png
</CODE> -->

The value '<CODE>10</CODE>' is one more than the number of images in the
dither pattern while "<CODE>-scale 12x4\!</CODE>" is the size of the dither
patterns being converted into a threshold map. </P>

The result is a grey-scale map, with no pure black or white colors. The grey
level used for a pixel means that if the color level is that grey value or
higher, then that pixel should be turned on.  That is each grey level is the
'threshold' level at which the color value goes from black to white. </P>

If you like to look at the image in another way, dark pixels generally result
in those pixels being turn on for more color levels. While light pixels are
only turned on when the image color becomes very bright.  This is almost
a negation of what the image actually looks like, but if you think about it it
does make sense. </P>

I also used a PNG image rather than a GIF image for the map as only one
image needs to be saved, and more importantly, to attempt to preserve 16 bit
quality levels for the threshold values.  GIF can only handle 8 bit color
levels. </P>

Now we can dither our images using, just a single image, and a much simpler
threshold comparison of each pixel directly against the dithering threshold
image (or map).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gradient.png dmap_hlines.png \
          -virtual-pixel tile  -fx 'u>=v'   dgrad_dmap_hlines.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dmap_hlines.png"
     ><IMG SRC="dmap_hlines_mag.png"     WIDTH=72 HEIGHT=24
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="dgrad_dmap_hlines.gif"
     ><IMG SRC="dgrad_dmap_hlines.gif"          WIDTH=640 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

See how much simpler a threshold map is.  You have only one image, and one
direct comparison to do per pixel, for each channel that is being dithered.
This makes dithering using a threshold map very very fast.  Much faster that
full color quantization.  This simplicity is the why ImageMagick and most
graphics software use a threshold map to hold various dither patterns. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The greater-then or equal ('<CODE>&gt;=</CODE>') test was not added to the
  "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator, until IM
  version 6.2.9-2.  If this is a problem, use the inverted test
  '<CODE>v&lt;u</CODE>' in the above.
</I></FONT></TD></TR></TABLE></P>

This simplicity however becomes a lot more complicated if the user wanted to
dither using multiple color levels. The proof of concept of this was first
worked out in the examples on the page <A
HREF="../bugs/ordered-dither/#posterize" >Posterized Ordered Dither</A> before
being incorporated into the IM core functions. </P>

Now that we have a merged threshold image, we next need to magick the above
image into a XML threshold map, that IM can directly read, and the "<CODE><A
HREF="../option_link.cgi?ordered-dither" >-ordered-dither</A></CODE>" operator
can use.  </P>

To do this we need to output our image as numbers representing the 9 grey
levels it represents. This is best done using the <A HREF="../formats/#netpbm"
>NetPBM or PBMplus</A> image format, with a depth adjustment using the "<A
HREF="http://netpbm.sourceforge.net/" >NetPbm</A>" image processing software.
This package is generally a standard linux install so most people will have it
already, or can install it from there normal software distribution. </P>

The "<CODE>pnmdepth</CODE>" number is again the number of gray levels that the
threshold image contains.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE >
  magick dmap_hlines.png pgm:- | pnmdepth 9 | pnmnoraw > dmap_hlines.pgm
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="dmap_hlines.pgm"
     ><IMG SRC="dmap_hlines.pgm.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>
<!-- <CODE EXECUTE>
  txt2gif dmap_hlines.pgm
</CODE> -->

All the numbers (other than the '<CODE>P2</CODE>' image magic identifier) in
the above are the numbers needed to generate the appropriate 'threshold map',
that you can add to your personal "<CODE>thresholds.xml</CODE>" file. For
example here is the resulting threshold map entry created from the above.

<DIV ALIGN=center>
<!-- <CODE EXECUTE NOIMAGE OUT=tmap_hlines.txt>
  perl -ne 'print if /threshold map="hlines12x4"/ .. /\/threshold/' \
       $HOME/.magick/thresholds.xml
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tmap_hlines.txt"
     ><IMG SRC="tmap_hlines.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

And here is an example of using this threshold map.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick shadow.png  -channel A  -ordered-dither hlines   shadow_hlines.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shadow.png"
     ><IMG SRC="shadow.png"               WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shadow_hlines.gif"
     ><IMG SRC="shadow_hlines.gif" WIDTH=70 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

And that is how you can generate a complex threshold map from a progression of
images. </P>


<A NAME="diy_symbols"></A>
<H3>Dithering with Symbol Patterns</H3>

Now while you can use a single threshold map or threshold image, instead of a
multi-image pattern set for most dithering operations, that does not mean that
multi-image maps don't have there own uses. </P>

You can use a set of lookup image to tile multiple areas all at once, rather
than one at a time. For example by scaling a simple image, and then replace
each pixel in an image with a particular symbol.  </P>

For example, here I take the very small 'eyes' image
<A HREF="../images/eyes.gif"
   ><IMG SRC="../images/eyes.gif"
         ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
and replace the individual pixels with various symbols, to produce such a
pattern for each pixel in the original image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick montage dpat_symbols.gif   -geometry +5+0 \
          -tile x1 -background none -mattecolor blue  -frame 3 \
          dpat_syms_images.gif
  magick eyes.gif -alpha off -colorspace sRGB -grayscale Average \
          +matte -scale 1600% -negate  \
          dpat_symbols.gif -virtual-pixel tile -fx 'u[floor(15.9999*u)+1]' \
          eyes_syms.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dpat_syms_images.gif"
     ><IMG SRC="dpat_syms_images.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="eyes_syms.gif"
     ><IMG SRC="eyes_syms.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The <A HREF="../montage/" >montage</A> is used to expand the multi-image
GIF image so that you can see it's contents, without it being 'animated'. </P>

You can adjust which "<CODE><A HREF="../option_link.cgi?grayscale"
>-grayscale</A></CODE>" intensity method you want to use, from the normal
'<CODE>Rec709Luminance</CODE>' to a darker '<CODE>Rec709Luma</CODE>', or use
a '<CODE>average</CODE>' of either a non-linear '<CODE>sRGB</CODE> colorspace,
or linear '<CODE>RGB</CODE>' colorspace.  You can even adjust the "<CODE><A
HREF="../option_link.cgi?gamma" >-gamma</A></CODE>" scaling of the values to
get the best spread of colors. </P>

There are a lot of posibilities, and what is good depends more on your symbol
arrangement than actual method chosen.  The key with the above is to somehow
ensure each color in the input image produces an unqiue symbol, and that can be
very tricky to achieve. </P>

This example can be used for creating cross-stitch or knitting guides
that hobbists can follow, generating larger scale artwork from smaller comuter
images. </P>

You can use this technique to tile greyscale images with a set of tiling color
images.  The result is a bit like the landscape maps seen in many old computer
war games.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick montage dpat_map.gif   -geometry +5+0 -tile x1  -background none  \
          dpat_map_images.gif
  magick -seed 100 \
          -size 200x200 plasma:'gray(50%)-gray(50%)' -blur 0x15 \
          -channel G -auto-level +channel -set colorspace sRGB \
          dpat_map.gif -virtual-pixel tile  -fx 'u[floor(5.999*u.g)+1]' \
          map.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="dpat_map_images.gif"
     ><IMG SRC="dpat_map_images.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="MAP.GIF"
     ><IMG SRC="map.gif"              WIDTH=200  HEIGHT=200
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that I needed to ensure that IM thought of the grayscale image as being
already in the final sRGB colorspace (as the tile images are), even though it
is actually linear RGB data that is being used for FX index lookups. Without
this the resulting 'map' is skewed toward wooded landscapes, with little
chance of water areas.  </P>

As you can see any set of images can be used for the tiles, the images don't
even need to line up with each other, or even be the same size tile.  Of
course if the tiles are the same size and are closely related to each other,
as in the case of the 3 blue 'sea' tiles, the tiled pattern can 'flow' from
one tiled area into another. </P>

By replacing the tile with images of numbers you can also generate a sort of
paint by numbers guide.  However some extra processing may be needed to border
the different areas. This is left as an exercise, mail your solutions to me,
and you can have your name in IM examples as the author for this technique.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<H2>Ordered Dither  Random notes and Future possibilities</H2>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<H3>Ordered Dither with small numbers of colors.</H3>

When using a small number of colors for a small image a pseudo-random dither
like IM's hilbert curve error correction dither, or even a simpler
Floyd-Steinberg error correction dither (see <A HREF="#dither_error" >Error
Correction Dither</A> above ) produces a horrible looking result. </P>

Ideally an  <A HREF="#ordered-dither" >Ordered Dither</A>  should be used with
low color and small icon like images to produce a much better looking result.
However at the moment ordered dither in IM can only used 'fixed'
mathematically generated color tables, and not just a collection of 'best'
colors. </P>

<H3>Ordered Dither with a map of any colors</H3>

There is some algorithm that will allow you to use a set of specific colors for
ordered dithering. </P>

Basically by adding the 'pseudo-colors' that an ordered dither algorithm can
generate (which could involve three color dithering), to the given color map,
to 'fill it out'. You can then 'map' the individual pixels of an image to this
'expanded color map'. </P>

From that initial mapping to a specific pseudo-color) the actual color can be
picked from the threshold map that generates that pseudo-color, and thus order
dither areas of that color, and thus the whole image to a given set of colors.
</P>

Because of my background in icons, and now GIF animations, I definitely would
like to see an any color ordered dither implemented, but I have yet to find
a practical reference to how to do ordered dithers with a fixed set of colors.
</P>

</DIV></P>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 11 August 2006 <BR>
Updated: 8 May 2010 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://imagemagick.org/Usage/quantize/</CODE>
</ADDRESS></BODY></HTML>

